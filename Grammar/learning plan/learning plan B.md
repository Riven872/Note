### Day 1

#### 1、JDK 和 JRE 和 JVM 分别是什么，有什么区别？

- JDK（Java Development Kit）：JDK 是 Java 开发工具包，包含了编写、编译、调试和运行 Java 程序所需的所有工具和组件，比如编译器（javac）、Java API、调试工具等。JDK 是针对 Java 开发人员的，它包含了 JRE，还有编译器和其他工具，可以用来编写和调试 Java 程序。
- JRE（Java Runtime Environment）：JRE 是 Java 运行时环境，包括了 Java 虚拟机（JVM）和 Java 标准类库（Java API）。JRE 是针对 Java 应用程序的，它提供了在计算机上运行 Java 应用程序所需的最小环境。
- JVM（Java Virtual Machine）：JVM 是 Java 虚拟机，是 Java 程序运行的环境。JVM 负责将 Java 代码解释或编译为本地机器代码，并在运行时提供必要的环境支持，比如内存管理、垃圾回收、安全性等。JVM 的主要作用是将 Java 代码转换为可以在计算机上运行的机器码，并负责程序的执行。
- 总结：
    - JDK 是 Java 开发工具包，包括了编译器、Java API、调试工具等，用于开发 Java 应用程序。
    - JRE 是 Java 运行时环境，包括了 Java 虚拟机和 Java 标准类库，用于在计算机上运行 Java 应用程序。
    - JVM 是 Java 虚拟机，是 Java 程序运行的环境，负责将 Java 代码转换为可以在计算机上运行的机器码，并提供必要的环境支持。

#### 2、什么是字节码？采用字节码的最大好处是什么？

- 字节码是 Java 程序编译后的中间代码，是一种可移植的二进制代码，可以在任何支持 JVM 的平台上运行。字节码通过将 Java 源代码编译为字节码指令序列，使得 Java 程序可以跨平台运行，即使是在不同的操作系统和硬件平台上也可以运行
- 字节码采用中间代码的形式，相比于直接将程序编译为特定平台上的机器码，有以下几个好处：
    - 可移植性：字节码是中间代码，所以可以在任何支持 JVM 的平台上运行，使得 Java 程序有很好的可移植性。也是 Java 跨平台的重要特性之一
    - 安全性：字节码需要在 JVM 中运行，所以可以对字节码进行安全检查，以确保程序不会对系统造成威胁
    - 性能：字节码是一种紧凑的二进制格式，相比于直接编译为机器码，可以更快地加载和传输，同时也可以在运行时进行动态优化，提高程序的执行效率
    - 可读性：相比于直接编译为机器码，字节码具有更好的可读性，可以方便地进行反汇编和调试
- 采用字节码作为中间代码的最大好处是提高了 Java 程序的可移植性、安全性、性能和可读性。这也是 Java 跨平台和安全性等特性的基础。

#### 3、什么是数据库事务？讲一下事务的 ACID 特性？

- 数据库事务是指数据库管理系统（DBMS）中的一个操作序列，这些操作必须作为一个不可分割的单元执行，即要么全部执行成功，要么全部失败回滚。事务通常涉及到对数据库中的数据进行读写操作。
- 事务的 ACID 特性指四个关键特征：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。
    - 原子性（Atomicity）：事务是一个原子操作，要么全部提交，要么全部回滚。当一个事务执行期间发生故障，操作系统会自动将其回滚到事务执行之前的状态，保证数据的一致性。
    - 一致性（Consistency）：事务执行结束后，数据必须保持一致性状态。在事务执行期间，数据库中的数据可以处于中间状态，但在事务完成时必须保证数据的一致性。
    - 隔离性（Isolation）：数据库系统必须保证事务之间相互隔离，不会互相干扰。隔离级别不同，会影响到事务的并发性和数据一致性，比如出现脏读、不可重复读、幻读等问题。
    - 持久性（Durability）：一旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发生故障或宕机，数据也能够保持不变。
- ACID 特性是保证事务正确性和数据一致性的重要手段。在设计数据库应用程序时，应该根据具体的业务需求和数据安全性要求，选择合适的隔离级别和事务提交策略，保证事务的可靠性和数据的一致性。



### Day 2

#### 1、Java 和 C++、Go 语言的区别，各自的优缺点？

- Java 是一种面向对象的编程语言，最初被设计用于开发嵌入式系统，现在已广泛应用于企业应用、Web 应用和移动应用开发等领域。Java 的优点包括：
    - 跨平台性强：Java 虚拟机（JVM）可以在不同的操作系统上运行 Java 程序，使得开发者可以编写一次代码并在多个平台上运行
    - 安全性高：Java 有很多安全特性，例如自动内存管理、类的访问权限控制、异常处理等，可以有效避免一些常见的安全漏洞
    - 生态系统完备：Java 的生态系统非常完善，有很多成熟的框架和工具可以帮助开发者快速构建复杂的应用
- C++ 是一种系统级编程语言，最初被设计用于操作系统和系统软件的开发，现在也广泛应用于游戏、图形图像处理、嵌入式系统等领域。C++ 的优点包括：
    - 性能高：C++ 是一种编译型语言，可以生成高效的机器代码，所以在处理大量数据和对计算效率有要求的应用场景下具有优势
    - 控制能力强：C++ 具有非常高的控制能力，可以直接操作计算机的硬件和内存等资源
    - 应用领域广泛：C++ 适用于开发大型系统、高性能应用和底层软件，如操作系统、数据库、游戏引擎等
- Go 是一种开源的编程语言，由 Google 公司开发，被设计用于开发高并发、分布式系统。Go 的优点包括：
    - 并发能力强：Go 具有轻量级的线程（goroutine）和基于消息传递的通道（channel），可以方便地实现并发编程
    - 内存管理高效：Go 的内存管理采用自动垃圾回收机制，使得开发者可以更加专注于业务逻辑
    - 语言特性简单：Go 的语法简单易懂，代码易于阅读和维护，同时提供了丰富的标准库和工具支持

#### 2、什么是 Redis？Redis 有哪些特点？Redis 有哪些常见的应用场景？

- Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，也被称为数据结构服务器。它支持多种类型的数据结构，如字符串、哈希、列表、集合、有序集合等，并提供了丰富的操作这些数据结构的命令。
- Redis的特点包括：
    - 高性能：Redis使用内存来存储数据，并且数据存储在单一的进程中，因此速度非常快。
    - 多样的数据类型：Redis支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等。
    - 持久化：Redis支持多种持久化方式，包括RDB快照和AOF日志。
    - 分布式：Redis支持分布式部署，可以将数据分布在多个节点上。
    - 简单易用：Redis提供了丰富的命令，使得操作数据非常方便。
- Redis的常见应用场景包括：
    - 缓存：Redis可以作为缓存使用，加速数据读取和响应速度。
    - 消息队列：Redis提供了列表和发布/订阅功能，可以用来实现消息队列。
    - 计数器：Redis的计数器功能非常高效，可以用来实现页面访问量、点击量等的计数。
    - 排行榜：Redis的有序集合功能可以用来实现排行榜。
    - 分布式锁：Redis可以用来实现分布式锁，保证多个进程之间的互斥访问。
    - 实时数据分析：Redis可以作为实时数据分析的缓存层，加速数据分析速度。
- Redis具有高性能、多样的数据类型、分布式、简单易用等特点，可以应用于各种场景，特别适合用来解决读写频繁的问题。

#### 3、简述计算机网络七层模型和各自的作用？

- 计算机网络七层模型是一个把网络通信协议分为七个层次的标准模型，其目的是为了让计算机网络的设计和管理更加灵活和模块化。这个模型被称为OSI模型（Open System Interconnection Model），它由国际标准化组织（ISO）于1984年发布，是一个开放的标准模型。
- 每个层次都有自己的独立功能和责任，这种分层的方式使得每个层次都可以独立工作，同时还能够很好地协调上下层之间的数据传输，而不需要依赖于其他层次的实现细节。以下是每个层次的具体功能和责任：
    - 物理层：主要负责通过物理媒介传输比特流，如电缆、光纤、无线电波等。物理层规定了物理连接的规范，包括电缆的类型、接口的规范等。
    - 数据链路层：主要负责把数据分成数据帧进行传输，并对错误进行检测和纠正。数据链路层还负责物理地址的分配、数据流量控制、错误校验等。
    - 网络层：主要负责数据在网络中的传输，包括路由选择、分组转发、数据报文的封装等。网络层还处理数据包的寻址和控制流量等。
    - 传输层：主要负责数据传输的可靠性和流量控制等，同时还包括分段、组装、连接建立和断开等功能。传输层的最重要的两个协议是TCP和UDP。
    - 会话层：主要负责建立、管理和终止会话，提供会话控制和同步等服务。会话层还负责处理多个应用程序之间的数据交换。
    - 表示层：主要负责数据格式转换、加密解密、压缩解压等服务。表示层使得应用程序可以使用不同的数据格式和编码，同时还提供了数据的安全性和完整性保护等服务。
    - 应用层：主要提供各种服务和应用程序，如电子邮件、文件传输、远程登录、Web浏览等。应用层服务可以使用不同的协议实现，如HTTP、SMTP、FTP、TELNET等。
- OSI模型是一种理论模型，在实际应用中较少使用。现在比较常用的是TCP/IP模型，它只有四层：应用层、传输层、网络层和数据链路层。



### Day 3

#### 1、Spring 框架是什么？使用 Spring 框架有哪些好处？

- Spring 框架是一个开源的 Java 企业应用程序框架，它通过依赖注入(Dependency Injection)和面向切面编程(Aspect Oriented Programming)等技术为开发者提供了一个全面的编程和配置模型。它可以降低 Java 开发的复杂度，提高代码的可维护性和可测试性，使得开发者能够更专注于业务逻辑的实现。
- Spring框架有以下好处：
    - 依赖注入(Dependency Injection)：通过 Spring 框架的依赖注入功能，开发者可以将应用程序中的不同组件之间的依赖关系交给 Spring 来管理，从而降低组件之间的耦合度，并方便后续的组件替换和维护。
    - 面向切面编程(Aspect Oriented Programming)：Spring 框架提供了面向切面编程的支持，可以将应用程序的不同功能抽象成切面，并将这些切面与应用程序中的不同组件关联起来，从而降低了应用程序中的重复代码量，并提高了代码的可重用性和可维护性。
    - 提供了多种技术整合方案：Spring 框架可以与其他的 Java 企业应用程序框架和技术进行整合，如 Hibernate、MyBatis、Struts、JSF 等，从而降低了技术整合的复杂度。
    - 支持声明式事务管理：Spring 框架提供了声明式事务管理的支持，开发者可以通过配置来管理应用程序中的事务，从而简化了事务管理的过程。
    - 提供了 IoC 容器：Spring 框架提供了一个 IoC 容器，可以对应用程序中的不同组件进行管理，并支持对组件进行 AOP 增强，从而实现了应用程序中的组件解耦和高度可配置性。
    - 便于测试：Spring 框架可以方便地进行单元测试和集成测试，提高了代码的可测试性和可靠性。

#### 2、MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用

- MySQL 包括三种类型的日志，分别是 binlog、redolog 和 undolog，它们分别有不同的作用和特点
    - binlog：binlog（Binary log）是 MySQL 中的二进制日志文件，用于记录 MySQL 服务器上的所有更新和修改操作。它可以记录所有的 DDL（Data Definition Language）和 DML（Data Modification Language）操作，包括对表结构的更改、数据的插入、修改、删除等等。binlog是在事务提交后生成的，因此可以用于恢复数据库。
    - redolog：redolog（Redo log）用于恢复数据，保证数据的一致性和持久性。当 MySQL 发生修改时，redolog 会将这些操作记录下来，并写入磁盘。这样，当 MySQL 发生宕机或崩溃时，通过重放 redolog 就可以恢复数据。
    - undolog：undolog（Undo log）用于回滚操作。当 MySQL 发生事务回滚时，undolog 会记录这些操作并将其写入磁盘。这样，当 MySQL 需要回滚时，通过重放 undolog 就可以回滚事务。
- binlog 和 redolog 都是 MySQL 中的二进制日志，但是它们的作用和实现方式有所不同。binlog 是 MySQL 记录所有的操作，而 redolog 则是用于保证数据的一致性和持久性。此外，binlog 是逻辑日志，redolog 是物理日志。binlog 记录的是SQL语句，而 redolog 记录的是数据页的修改，所以 binlog 可以跨平台使用，而 redolog 不能。undolog 和 redolog 的区别是，undolog 是用于回滚操作的，而 redolog 是用于恢复数据的。

#### 3、JDK 动态代理和 CGLIB 动态代理的区别是什么？

- JDK 动态代理和 CGLIB 动态代理都是 Java 中动态代理的两种实现方式，它们的区别主要在以下几个方面：
    - 实现方式：JDK 动态代理是通过**反射**实现的，而CGLIB动态代理是通过**继承目标类**来实现的。
    - 目标类限制：JDK 动态代理要求目标类**必须要实现接口**，而CGLIB动态代理则没有这个限制。
    - 性能：JDK 动态代理相对于 CGLIB 动态代理来说，因为实现方式不同，生成的代理类的效率会低一些。
    - 对象类型：JDK 动态代理只能代理实现了接口的类，而 CGLIB 动态代理可以代理任何类，包括 final 类。
    - 依赖库：JDK 动态代理是 Java 自带的库，不需要额外的依赖，而 CGLIB 动态代理需要依赖 cglib 库。
- JDK 动态代理适用于接口代理的场景，而 CGLIB 动态代理适用于类代理的场景。



### Day 4

#### 1、Java 中 final 关键字有什么用？

- final 关键字可以修饰类、方法和变量，作用如下：
    - final 修饰类，表示该类不能被继承。
    - final 修饰方法，表示该方法不能被子类重写。
    - final 修饰变量，表示该变量只能被赋值一次。final 修饰的变量必须在声明时或构造函数中初始化，且不能再被修改。常用于定义常量。
- 用 final 修饰的变量在编译时就已经确定了其值，因此在运行时访问比非 final 变量更快。
- 使用 final 关键字可以带来一些好处，例如：
    - 安全性：将变量声明为 final 可以防止它被改变，从而提高安全性。
    - 可读性：将常量声明为 final 可以提高代码的可读性，因为常量的值不会被修改。
    - 优化：final 变量在编译时被转换成常量，这可以提高程序的性能。

#### 2、HTTP 是哪一层的协议？简述它的作用？

- HTTP 是应用层协议，主要用于在 Web 浏览器和 Web 服务器之间传递数据。它是一种无状态的协议，即服务器不会保存关于客户端的任何信息，每次客户端发送请求，服务器都会返回响应。HTTP 协议通常基于 TCP 协议，使用 TCP 的 80 端口作为默认的传输端口。HTTP 协议主要作用包括：
    - 建立连接：客户端与服务器建立 TCP 连接，然后发送 HTTP 请求，服务器接收请求并处理。
    - 发送请求：客户端发送 HTTP 请求到服务器，包括请求方法（GET、POST、PUT等）、请求头（如User-Agent、Accept等）和请求正文（可选）等信息。
    - 处理请求：服务器接收并解析 HTTP 请求，执行请求操作（如查询数据库等），并将处理结果返回给客户端。
    - 返回响应：服务器返回HTTP响应，包括响应状态码（如200 OK、404 Not Found等）、响应头（如Content-Type、Cache-Control等）和响应正文（可选）等信息。
- HTTP 的请求报文主要包括以下几个部分：
    - 请求行：包括请求方法、URL 和 HTTP 协议版本。
    - 请求头：包括一些请求头部信息，例如 User-Agent、Host 等。
    - 空行：表示请求头结束。
    - 请求体：实际请求的数据，例如表单提交的数据等。
- HTTP 的响应报文主要包括以下几个部分：
    - 状态行：包括 HTTP 协议版本、状态码和状态消息。
    - 响应头：包括一些响应头部信息，例如 Server、Content-Type、Content-Length 等。
    - 空行：表示响应头结束。
    - 响应体：实际响应的数据，例如网页的 HTML 代码、图片、音频等。
- HTTP 的状态码指示了服务器对请求的处理结果。常见的状态码包括 200 OK（请求成功）、301 Moved Permanently（永久重定向）、404 Not Found（未找到资源）和 500 Internal Server Error（服务器内部错误）等。
- HTTP 协议的作用是规定了 Web 应用程序中客户端和服务器之间的通信方式和数据传输格式，是支持 Web 应用程序开发的基础协议。

#### 3、什么是进程和线程？它们有哪些区别和联系？

- 进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。
- **进程是操作系统资源分配的最小单位**，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通信需要通过进程间通信机制（IPC）来实现。
- **线程是程序执行的最小单位**，一个进程中可以包含多个线程，它们共享进程的内存空间和系统资源。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通信可以通过共享内存、信号量等机制实现。
- 进程和线程的区别和联系如下：
    - 资源分配：进程拥有自己的内存空间等系统资源，而线程共享进程的资源；
    - 独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源；
    - 调度：进程间调度的开销比线程大，线程的调度开销小，可以并发执行；
    - 并发性：多个进程之间相互独立，多个线程可以并发执行；
    - 同步：进程间通信需要通过 IPC 机制，线程间同步可以通过共享内存、信号量等机制实现。
- 在实际开发中，多线程应用更加常见，因为线程的开销小，执行效率高，适用于需要并发执行的场景。但需要注意线程安全问题。而多进程应用通常更加稳定，但开销较大，适用于需要独立运行的场景。



### Day 5

#### 1、Java 中 hashCode 和 equals 方法是什么？它们和 == 各有什么区别？

在 Java 中，hashCode 和 equals 方法都是 Object 类的方法。它们的作用分别如下：

- hashCode 方法返回对象的哈希码，用于支持基于哈希表的集合，如 HashMap、HashSet 等。如果两个对象的 equals 方法返回 true，则它们的 hashCode 方法必须返回相同的值，反之则不需要。
- equals 方法用于比较对象是否相等。默认情况下，equals 方法使用的是 == 操作符，即只有两个对象引用指向同一个对象时才会返回 true。但是，大部分情况下，我们需要重写 equals 方法来实现自己定义的相等规则。

两者之间的区别在于，hashCode 方法返回的是一个 int 类型的数值，而 equals 方法返回的是一个 boolean 类型的值。

hashCode 方法用于快速比较两个对象是否不同，因为如果它们的哈希码不同，那么它们肯定不相等。equals 方法则用于判断两个对象是否真正相等，这个判断比较复杂，需要根据对象的实际情况来定义。

另外，需要注意的是，== 操作符用于比较两个对象的引用是否相等，即它们是否指向同一个对象。而 equals 方法则用于比较两个对象的值是否相等。

在 Java 中，对象的值比较往往需要根据对象的实际情况来定义，因此一般需要重写 equals 方法。

#### 2、Spring 的两大核心概念是什么？简单讲一下你对它们的理解

Spring 框架的两大核心概念是控制反转（Inversion of Control，IoC）和面向切面编程（Aspect Oriented Programming，AOP）。

**控制反转**指的是将对象的创建和依赖注入由应用代码转移到了 Spring 容器中进行，即由 Spring 容器负责创建对象和管理它们之间的依赖关系。这样，应用代码只需要关注业务逻辑的实现，而不需要关注对象的创建和管理，降低了应用代码的复杂度，提高了代码的可重用性和可维护性。

**面向切面编程**是指将与业务逻辑无关的代码（如日志、安全、事务等）从业务逻辑中剥离出来，以便于统一管理和维护。通过 AOP，我们可以将这些与业务逻辑无关的横切关注点（Cross-cutting Concerns）定义为切面（Aspect），并将它们织入到业务逻辑中，从而实现了业务逻辑与横切关注点的解耦。

这两个概念是 Spring 框架的核心，它们使得 Spring 框架具有了高度的可扩展性、灵活性和模块化，极大地提高了应用程序的开发效率和代码的可维护性。

#### 3、死锁是什么？如何预防和避免死锁？

死锁是指两个或多个进程在执行过程中因争夺资源而造成的一种僵局，当进程处于死锁状态时，它们将无法继续执行，而只能相互等待，直到被外部的程序干预或自行放弃。

预防和避免死锁需要采取一些措施，包括：

- 避免资源独占：尽量避免一个进程在获得了某些资源后再次请求其他资源，而应该将所有需要的资源一次性申请到位。

- 避免资源持有和等待：当一个进程占用了一些资源并等待另一些资源时，其他进程就无法使用这些资源，容易引发死锁。因此，尽可能减少资源持有和等待时间。

- 避免资源互斥：有些资源在同一时间只能被一个进程占用，比如打印机、磁带机等，需要采用一些技术手段来避免资源互斥的问题。

- 引入资源剥夺策略：当一个进程请求的资源被其他进程占用时，可以采取剥夺资源的策略，即暂停占用该资源的进程，直到该资源被释放后再恢复该进程的执行。

- 引入进程抢占策略：当一个进程等待时间过长时，可以采取抢占其资源的策略，即中断正在执行的进程，强制释放其占用的资源。



### Day 6

#### 1、什么是反射机制？说说反射机制的优缺点、应用场景？

Java 反射机制是指在运行时动态地获取类的信息、创建对象以及调用对象的属性和方法的机制。Java 反射机制提供了运行时检查 Java 类型信息的能力，让 Java 程序可以通过程序获取其本身的信息。

Java 反射机制的优点：

- 可以动态地获取类的信息，不需要在编译时就知道类的信息。
- 可以动态地创建对象，不需要在编译时就知道对象的类型。
- 可以动态地调用对象的属性和方法，可以在运行时动态地改变对象的行为。

Java 反射机制的缺点：

- 由于反射是动态的，所以它的运行效率较低，不如直接调用方法或属性。
- 由于反射是动态的，所以它会破坏 Java 的封装性，可能会使代码变得复杂和不稳定。

Java 反射机制的应用场景：

- 动态代理。动态代理可以使用反射机制在运行时动态地创建代理对象，而不需要在编译时就知道接口的实现类。
- 单元测试。JUnit 等单元测试框架可以使用反射机制在运行时动态地获取类和方法的信息，实现自动化测试。
- 配置文件加载。许多框架（如 Spring）使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编程等功能。

#### 2、数据库索引是什么，有什么作用，什么场景适合使用索引？

数据库索引是一种数据结构，用于提高数据库表的查询效率。索引可以帮助数据库快速定位和检索存储在表中的数据，从而加快数据查询的速度。在数据量比较大时，使用索引可以极大地提高数据检索的效率。

索引的作用是通过构建一个额外的数据结构（B-tree、哈希表等）来加速数据的检索。它是在数据库表上创建的一种数据结构，它包含一些指向表中数据的指针，可以快速地定位到满足查询条件的数据行，从而提高查询效率。索引可以包含一个或多个列，可以使用单列索引、组合索引、全文索引等多种方式来创建。

适合使用索引的场景包括：

1. 频繁查询的列，如主键、外键等。
2. 经常作为查询条件的列，如WHERE、ORDER BY、GROUP BY 等语句中的列。
3. 经常需要连接的列，如多表联合查询时的列。
4. 数据量较大的表，通过索引可以加快数据检索速度。

索引的优点是可以提高数据库的查询速度，缩短数据检索的时间，提高系统的性能。但是索引也有一些缺点，包括：

1. 占用额外的存储空间，增加了存储成本。
2. 建立索引需要时间，增加了系统的开销。
3. 数据库的更新操作（增删改）会导致索引的重建，影响系统的性能。

因此，需要根据实际情况进行索引的创建和使用，避免过度索引导致系统性能下降。

#### 3、HTTP 有哪些常见的状态码？

HTTP（超文本传输协议）常见的状态码有以下几种：

- 1xx（信息类状态码）：指示已经接收到请求，正在继续处理。

- 2xx（成功状态码）：指示请求已经被接收、理解和接受。

- - 200 OK：请求已成功处理。
    - 201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。
    - 204 No Content：服务器已经成功处理了请求，但是没有返回任何实体内容。

- 3xx（重定向状态码）：需要进行附加操作以完成请求。

- - 301 Moved Permanently：请求的网页已永久移动到新位置。
    - 302 Found：请求的网页已经临时移动到新位置。
    - 304 Not Modified：客户端发送了一个带条件的请求，服务器端允许请求访问资源，但是请求未满足条件。

- 4xx（客户端错误状态码）：请求包含错误语法或不能被执行。

- - 400 Bad Request：请求报文存在语法错误。
    - 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的认证信息。
    - 403 Forbidden：表示对请求资源的访问被服务器拒绝。
    - 404 Not Found：请求的资源不存在。

- 5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误。

- - 500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。
    - 502 Bad Gateway：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。
    - 503 Service Unavailable：服务器暂时处于超负载或正在停机维护，无法处理请求。

状态码是服务器对客户端请求结果的反馈，根据状态码可以快速定位问题所在，进行相应的处理。



### Day 7

#### 1、Java 访问修饰符 public、private、protected，以及无修饰符（默认）的区别？

- | 修饰符          | 当前类 | 同包 | 子类 | 其他包 |
    | --------------- | ------ | ---- | ---- | ------ |
    | public          | √      | √    | √    | √      |
    | protected       | √      | √    | √    | ×      |
    | default（默认） | √      | √    | ×    | ×      |
    | private         | √      | ×    | ×    | ×      |

#### 2、线程间有哪些通信方式？

- 共享内存：线程之间通过访问同一块共享内存区域来实现数据交换。
- 消息队列：一个线程向消息队列中放入一条消息，另一个线程从消息队列中取出消息。
- 管道（Pipe）：管道是一种半双工的通信方式，一个进程可以向管道中写入数据，另一个进程可以从管道中读取数据。
- 信号（Signal）：信号是一种异步通信方式，进程收到信号后，会根据信号的类型做出相应的处理。
- 互斥锁（Mutex）：用于同步访问共享资源，防止多个线程同时访问共享资源，产生冲突。
- 条件变量（Condition Variable）：用于线程之间的协调和通信，一个线程可以通过条件变量等待某个条件的出现，另一个线程可以通过条件变量通知正在等待的线程。

#### 3、什么是分布式？为什么需要分布式？

- 分布式是指在多台计算机上协同工作的系统，这些计算机通过网络连接在一起，共同完成一个任务。
- 解决单台计算机**处理能力不足**、**系统容易宕机**、**数据存储容量有限**等问题
- 能够提高系统的**可靠性**、**可用性**和**性能**，适用于**数据量较大**、**并发量高**、**访问频繁**的场景
- 可以通过**横向扩展**的方式提高系统的性能和可靠性，同时降低单点故障的风险，提高了系统的可伸缩性，方便进行升级和维护
- 数据和计算任务被分布在多台计算机上，不同计算机之间需要进行通信和协调，因此需要解决分布式一致性、负载均衡、故障恢复、数据共享和安全等问题，同时需要考虑数据的一致性和可靠性



### Day 8

#### 1、你是怎么做 MySQL 数据备份的？比如怎么恢复半个月前的数据？

- MySQL 数据备份有多种方法，包括逻辑备份、物理备份、全备份和增量备份。你可以根据你的需求和环境选择合适的方式。如果你想要恢复半个月前的数据，你需要先确保你有半个月前的备份文件，然后使用相应的工具或命令进行还原。例如，如果你使用 mysqldump 命令进行了逻辑备份，那么你可以使用 source 指令或者 mysql 命令来导入备份文件。

- 逻辑备份

    - 逻辑备份是使用 SQL 语句来导出和导入数据库的数据的方法。它的优点是简单易用，可以跨平台和存储引擎，可以部分备份和恢复。它的缺点是速度慢，占用空间大，可能影响数据库性能。

    - MySQL 提供了一个原生的逻辑备份工具叫做 mysqldump。你可以使用它来备份整个数据库实例、单个数据库或单张表。例如，如果你想要备份一个叫 foo 的数据库，你可以在命令行窗口输入：

        ```shell
        mysqldump -u 用户名 -p 密码 --database foo > foo.sql
        ```

    - 这样就会生成一个包含 foo 数据库所有数据的 SQL 文件到当前目录下。如果你想要恢复这个文件到数据库中，你可以在命令行窗口输入：

        ```shell
        mysql -u 用户名 -p 密码 < foo.sql
        # 或者
        mysql -u 用户名 -p 密码 source foo.sql
        ```

    - 这样就会执行 SQL 文件中的语句，将数据还原到数据库中。

- 物理备份

    - 物理备份是直接拷贝数据库的数据文件、配置文件和日志文件。它的优点是速度快，占用空间小，不影响数据库性能。它的缺点是恢复复杂，需要关闭数据库服务，可能导致数据不一致。

    - MySQL 有一个开源的物理热备工具叫做 Percona XtraBackup。它可以在不锁表的情况下备份 InnoDB、XtraDB 和 MyISAM 存储引擎的表，并且支持增量备份。你可以使用它来备份整个数据库实例或单个数据库。

    - 例如，如果你想要全量备份一个叫 foo 的数据库，你可以在命令行窗口输入：

        ```shell
        innobackupex --user=用户名 --password=密码 --databases="foo" /backup
        ```

    - 这样就会在 /backup 目录下生成一个包含 foo 数据库所有数据文件的目录。

    - 如果你想要恢复这个目录到数据库中，你需要先准备好数据文件，然后拷贝到对应的数据目录中，并更改权限和所有者。具体步骤如下：

        ```shell
        innobackupex --apply-log /backup/2023-02-27_00-00-00 cp -r /backup/2023-02-27_00-00-00/* /var/lib/mysql chown -R mysql:mysql /var/lib/mysql
        ```

    - 在恢复之前，你需要停止 MySQL 服务，并确保数据目录为空。

- 全备份和增量备份

    - 全备份是指备份数据库中的所有数据，不管数据是否有变化。它的优点是恢复简单，不需要其他文件。它的缺点是占用空间大，耗时长，影响数据库性能。

    - 增量备份是指只备份上次全备份或增量备份后发生变化的数据，需要开启 binlog 日志功能。它的优点是占用空间小，耗时短，不影响数据库性能。 它的缺点是恢复复杂，需要依赖 binlog 日志文件和全备份文件

    - 例如，如果你想要每天进行一次全备份和每小时进行一次增量备份，你可以使用 mysqldump 工具和 binlog 工具来实现。

    - 首先，在 my.cnf 文件中开启 binlog 功能，并设置每天生成一个日志文件

        ```shell
        log-bin=/var/lib/mysql/mysql-bin expire-logs-days=7 max_binlog_size=100M
        ```

    - 然后，在 crontab 中设置定时任务，

        ```shell
        # 如每天凌晨 0 点进行一次全备份
        0 0 * * * mysqldump -u root -p password --all-databases > /backup/full_$(date +%Y%m%d).sql
        
        # 每小时进行一次增量备份
        0 * * * * mysqlbinlog --read-from-remote-server --host=localhost --user=root --password=password --stop-never-slave-server-id=10 mysql-bin.000001 > /backup/incremental_$(date +%Y%m%d%H).sql
        ```

    - 这样就可以在 /backup 目录下生成全备份和增量备份文件

    - 如果你想要恢复这些文件到数据库中，你需要先停止 MySQL 服务，并确保数据目录为空。然后按照以下步骤操作：

        ```shell
        # 恢复最近一次的全备份文件
        mysql -u root -p password < /backup/full_20230227.sql
        
        # 恢复之后产生的所有增量备份文件
        mysqlbinlog /backup/incremental_202302270*.sql | mysql -u root -p password
        ```

    - 在恢复之前，需要确认 binlog 文件名和路径，并按照时间顺序恢复。

#### 2、什么是消息队列？消息队列有哪些应用场景？

- 消息队列是一种用于异步通信的机制，用于在不同的应用程序之间传递消息。消息队列通常由消息生产者、消息队列和消息消费者三部分组成
- 消息生产者将消息发送到消息队列中，而消息消费者则从消息队列中接收消息。消息队列负责存储和管理消息，确保消息传递的可靠性和稳定性。在实现过程中，消息队列还会提供一些额外的功能，如消息过滤、消息路由、消息持久化等。
- 特点：
    - 异步通信：消息生产者和消息消费者之间采用异步通信模式，发送方无需等待接收方的响应即可继续执行。
    - 解耦：消息队列可以将消息生产者和消息消费者解耦合，使得它们之间的关系更加灵活。
    - 可靠性：消息队列通常会提供一些保证消息传递可靠性的机制，如消息持久化、重试机制等。
    - 缓冲：消息队列可以缓冲来自多个消息生产者的消息，使得消息消费者可以按照自己的节奏进行消费，从而有效地平衡生产者和消费者之间的处理速度。
- 应用：
    - 异步任务处理：通过将任务发送到消息队列中，异步处理任务，提高系统的并发性能和吞吐量。
    - 解耦合系统：将不同的业务逻辑拆分成不同的服务，通过消息队列实现服务之间的通信，提高系统的可维护性和可扩展性。
    - 流量削峰：将流量通过消息队列分散到不同的服务中，避免单个服务被高并发流量打垮。
    - 日志收集：通过将日志消息发送到消息队列中，将日志收集和分析与业务逻辑解耦合，提高系统的可靠性和可维护性。
    - 应用解耦：将不同的应用程序通过消息队列进行集成，实现应用之间的解耦合和数据交换。

#### 3、设计模式是什么？为什么要学习和使用设计模式？

- 设计模式是指在软件开发中经常遇到的一些重复性问题，通过对这些问题的总结、抽象、归纳和提炼，得到的一些解决问题的通用方案。学习和使用设计模式可以帮助开发人员提高代码的可重用性、可维护性、可扩展性和可读性，从而提高开发效率和代码质量。
- 常见的现实业务场景和对应的设计模式：
    - 工厂模式：当需要创建多种具有相同特征的对象时，使用工厂模式可以将对象的创建与业务逻辑分离，降低代码的耦合度。 例如，在电商平台上，不同种类的商品都需要进行库存管理和订单管理，可以使用工厂模式来创建对应的库存管理器和订单管理器。
    - 单例模式：当需要确保系统中某个类只有一个实例时，可以使用单例模式，保证全局唯一性，避免资源的浪费。 例如，在 Web 应用中，有时需要保证所有请求都使用同一个数据库连接，可以使用单例模式来实现数据库连接池。
    - 观察者模式：当一个对象的状态发生改变需要通知其他对象时，可以使用观察者模式，将对象的状态与业务逻辑分离，提高系统的灵活性和可扩展性。 例如，在多人在线游戏中，玩家的行为会影响其他玩家的状态，可以使用观察者模式来实现游戏中的事件处理和状态同步。
    - 策略模式：当需要在运行时根据不同的情况采用不同的算法时，可以使用策略模式，将算法与业务逻辑分离，提高代码的可维护性和扩展性。 例如，在电商平台上，可以使用策略模式来实现不同的促销策略，例如满减、打折等。



### Day 9

#### 1、一条 SQL 语句在 MySQL 中的执行过程是怎样的？

- **词法分析和语法分析**：MySQL 的 SQL 解析器会对输入的 SQL 语句进行词法分析和语法分析，以确定语句的结构和语法是否正确。

- **查询优化**：MySQL 会对 SQL 语句进行优化，以确定最优的执行计划。在这个过程中，MySQL 会考虑许多因素，例如索引、表连接、统计信息等，以找到执行查询的最有效方式。
- **查询执行**：在查询优化后，MySQL 开始执行查询，读取和处理数据。在执行过程中，MySQL 会根据查询中所涉及的表和列等信息，从磁盘中读取相应的数据，并进行计算和过滤操作。
- **结果返回**：最后，MySQL 会将查询结果返回给客户端，完成整个查询过程。
- 在并发环境下，多个查询可能会同时进行，需要使用**锁和事务**等机制来保证数据的一致性和正确性。

#### 2、什么是 IOC，简单讲一下 Spring IOC 的实现机制？

- 基本概念

    - IOC(Inverse Of Controll,控制反转)：就是原来代码里面需要自己手动创建的对象，依赖，反转给 Spring 来帮忙实现。我们需要创建一个容器，同时需要一种描述来让容器知道要创建的对象与对象之间的关系。

    - 在 Spring 中 BeanFactory 就是 IOC 容器，在 Spring 初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过 BeanDefinitionReader 加载到 BeanDefinition 中并保存在 BeanDefinitionMap 中，然后再由 IOC 容器创建 bean 对象.

- 两种 bean 的注册方式

    - 通过 @Bean + @Configuration 的方式直接定义要创建的对象与对象的关系
    - 通过 @Component 定义类，这种方式必须使用 @ComponetScan 定位 Bean 扫描路径

- IOC 的创建

    - 在 Spring 中 BeanFactory 就是 IOC 容器，在 Spring 初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过 BeanDefinitionReader 加载到 BeanDefinition 中并保存在 BeanDefinitionMap 中，在这个过程中会让 BeanDefinitionProcesser(Bean 的定义信息的后置处理器)进行增强，然后再由 IOC 容器创建 bean 对象.

#### 3、并发和并行有什么区别？同步和异步有什么区别？

- 并发（Concurrency）：指的是系统中同时存在多个正在执行的任务，并且这些任务之间可能会相互影响。并发通常用来处理多个任务共享资源的情况。在单核 CPU 上，多个任务会轮流使用 CPU 时间片，表现为看似同时执行的情况，但实际上只有一个任务正在执行。
- 并行（Parallelism）：指的是系统中同时存在多个并且相互独立的任务，并且这些任务可以在多个处理器上同时执行，真正意义上的同时处理多个任务。
- 同步（Synchronous）：指的是程序按照代码的顺序执行，一行一行地执行，直到当前行执行完成后才能继续执行下一行。同步通常会阻塞调用者，直到任务完成才能返回。
- 异步（Asynchronous）：指的是程序在执行某个任务时，不会一直等待任务完成，而是继续执行下一行代码，当任务完成后再进行相应的处理。异步通常不会阻塞调用者，可以提高系统的并发性能。



### Day 10

#### 1、String 和 StringBuffer、StringBuilder 的区别是什么？

- String 和 StringBuffer/StringBuilder 是 Java 中两种不同的字符串处理方式，主要的区别在于 String 是不可变的（immutable）对象，而 StringBuffer 和 StringBuilder 则是可变的（mutable）对象。
- String 对象一旦被创建，就不可修改，任何的字符串操作都会返回一个新的 String 对象，这可能导致频繁的对象创建和销毁，影响性能。而 StringBuffer 和 StringBuilder 允许进行修改操作，提供了一种更高效的字符串处理方式。
- StringBuffer 和 StringBuilder 的主要区别在于线程安全性和性能方面。StringBuffer 是线程安全的，所有方法都是同步的，因此可以被多个线程同时访问和修改。而 StringBuilder 不是线程安全的，适用于单线程环境下的字符串处理，但是相比于 StringBuffer，StringBuilder 具有更高的性能。
- 当字符串处理需要频繁修改时，建议使用 StringBuffer 或 StringBuilder；而当字符串处理不需要修改时，可以使用 String。

#### 2、MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？

- MySQL 中的索引是通过 B+ 树实现的。B+ 树是一种多叉树，它可以将数据按照一定的顺序组织起来，从而提高查询效率。
- B+ 树与 B 树的区别在于，B+ 树的所有数据都存储在叶子节点上，而非叶子节点只存储索引，这样可以提高数据查询效率。B+ 树的叶子节点之间使用指针相连，这样可以实现区间查找，也就是说，可以快速定位某个区间内的数据。
- MySQL 之所以采用 B+ 树作为索引的实现方式，主要是因为 B+ 树具有以下优点：
    - 能够支持高效的范围查找和排序。
    - 叶子节点之间使用指针相连，能够支持高效的区间查询。
    - B+ 树具有较高的数据密度，可以减少磁盘 I/O 次数，提高查询效率。
    - B+ 树对于插入和删除操作也比较高效。
- InnoDB 存储引擎中的索引主要有聚簇索引和二级索引两种类型，聚簇索引是根据主键创建的索引，而二级索引是根据非主键列创建的索引。对于二级索引，MySQL 中会同时创建一个对应的聚簇索引，这样可以提高查询效率。

#### 3、Spring 框架中都用到了哪些设计模式？

- **单例模式**：Spring 的 Bean 默认是单例模式，通过 Spring 容器管理 Bean 的生命周期，保证每个 Bean 只被创建一次，并在整个应用程序中重用。
- **工厂模式**：Spring 使用工厂模式通过 BeanFactory 和 ApplicationContext 创建并管理 Bean 对象。
- **代理模式**：Spring AOP 基于动态代理技术，使用代理模式实现切面编程，提供了对 AOP 编程的支持。
- 观察者模式：Spring 中的事件机制基于观察者模式，通过 ApplicationEventPublisher 发布事件，由 ApplicationListener 监听事件，实现了对象间的松耦合。
- 模板方法模式：Spring 中的 JdbcTemplate 使用了模板方法模式，将一些固定的流程封装在父类中，子类只需实现一些抽象方法即可。
- 策略模式：Spring 中的 HandlerInterceptor 和 HandlerExecutionChain 使用了策略模式，允许开发者自定义处理器拦截器，按照一定顺序执行。
- **责任链模式**：Spring 中的过滤器和拦截器使用了责任链模式，多个过滤器和拦截器按照一定顺序执行，每个过滤器和拦截器可以拦截请求或者响应并做出相应的处理。



### Day 11

#### 1、MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？

- | 隔离级别         | 特点                                           | 脏读 | 不可重复读 | 幻读 |
    | ---------------- | ---------------------------------------------- | ---- | ---------- | ---- |
    | 读未提交         | 允许读取未提交事务中更新的数据                 | √    | √          | √    |
    | 读已提交         | 只能读取已提交的数据                           | ×    | √          | √    |
    | 可重复读（默认） | 保证同一个事务中多次读取同一数据的结果是一致的 | ×    | ×          | √    |
    | 可串行读         | 完全串行化的执行，可能导致大量超时和锁竞争     | ×    | ×          | ×    |

- | 引发的问题 | 问题描述                                                     |
    | ---------- | ------------------------------------------------------------ |
    | 脏读       | 一个事务读取到另一个事务还没提交的数据                       |
    | 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同             |
    | 幻读       | 一个事务查询数据时，没有对应的数据行，但在插入该数据时，又发现该数据行已经存在 |

#### 2、Redis 的单线程模型，IO 多路复用是什么？

- Redis 实现的单线程并不是一个纯粹的单线程，所谓的单线程指的是 Redis 在解析客户端发送的命令，处理这样的请求使用的是单线程。有后台线程来处理文件关闭、AOF刷盘、异步释放 Redis 内存（lazyfree 线程）

- 那为什么 Redis 使用的是单线程但是性能还是这么高呢？
    - 避免了高并发竞争带来的消耗
    - 采用**多路复用**机制
- 多路复用机制是指 Redis 通过单线程实现对多个客户端同时进行 IO 操作的能力。这种机制主要基于 Linux 的 select、poll、epoll 等系统调用实现，它允许 Redis 单线程同时处理多个客户端的请求，提高 Redis 的并发性能。当 Redis 有多个客户端连接时，它会将这些连接的文件描述符放入一个文件描述符集合中，然后通过 select、poll、epoll 等系统调用监听这些文件描述符是否有事件发生，如读、写等事件，如果有，则根据事件类型进行相应的处理。

#### 3、什么是 BIO、NIO、AIO？

- BIO、NIO、AIO 是 Java 中常用的 I/O 模型，它们都是针对网络编程中 I/O 操作的不同实现方式。

- BIO，全称 Blocking I/O，也称为同步阻塞 I/O。BIO 是最早的 I/O 模型，它是一种阻塞式的 I/O 模型，即当应用程序调用 I/O 操作时，该操作会一直阻塞线程直到操作完成，这会导致 I/O 性能低下。应用于 I/O 带宽较低、单个连接数不高的场景。例如文件传输、小型 HTTP 服务器等。
- NIO，全称 Non-Blocking I/O，也称为同步非阻塞 I/O。NIO 是一种同步非阻塞的 I/O 模型，它的核心是 Selector 和 Channel，利用 Selector 监听多个 Channel 上的事件，当一个 Channel 上的事件到达时，它会被 Selector **转发**给注册在这个 Selector 上的其他 Channel，这样可以用一个线程来处理多个请求，提高了 I/O 的效率。NIO 适用于连接数多、连接时间短的场景，例如实时聊天室、在线游戏等。
- AIO，全称 Asynchronous I/O，也称为异步非阻塞 I/O。AIO 是 JDK1.7 引入的 I/O 模型，它的特点是异步处理 I/O 操作，**当操作完成时会通知应用程序**，相比于 NIO 的同步非阻塞 I/O，AIO 无需通过轮询操作完成状态，从而提高了 I/O 的效率。AIO 适用于连接数多、连接时间长的场景，例如 HTTP 长连接、文件操作等。
- BIO，核心思想是来了请求之后不解决完就阻塞：即打算约女神，给女神发短信后，没见到女神就一直等在宿舍楼下。
- NIO，核心思想是来了请求之后进行转发：就是打算约女神，你让宿管大妈去挨个看每一个下楼的妹子，女神下楼了大妈就通知你。
- AIO，核心思想是请求来了之后异步处理，处理完成之后再通知：就是打算约女神，你发完短信，你就去玩游戏了，女神下楼了，发短信给你，你才出现。



### Day 12

#### 1、意向锁是什么？有什么作用？它是表级锁还是行级锁？

- 是什么

    - 在使用 InnoDB 引擎的表里时对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」
    - 在使用 InnoDB 引擎的表里时对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」
    - 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

    - 意向共享锁和意向独占锁是表级锁，不会和**行级的**共享锁和独占锁发生冲突，而且**意向锁之间**也**不会发生冲突**，只会和**共享表锁**和**独占表锁**发生冲突。
    - 表锁和行锁是满足读读共享、读写互斥、写写互斥的

- 作用

    - 为了快速判断表里是否有记录被加锁
    - 如果**没有「意向锁」**，那么加「独占表锁」时，就需要**遍历表里所有记录**，查看**是否有记录存在独占锁**，这样**效率会很慢**。
    - 那么**有了「意向锁」**，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接**查该表是否有意向独占锁**，如果有就**意味着表里已经有记录被加了独占锁**，这样就**不用去遍历表里的记录**。

- 意向锁是**表级别锁**

#### 2、Spring、SpringMVC、SpringBoot 三者之间是什么关系？

- Spring、Spring MVC 和 Spring Boot 是 Spring Framework 的三个重要组成部分，它们之间的关系可以概括为：
    - Spring 是一个开源的轻量级 Java 开发框架，它提供了丰富的基础设施和简化的编程模型，可以使 Java 开发变得更加简单、高效、灵活和可维护。
    - Spring MVC 是 Spring 框架中的一个模块，它是基于 MVC 设计模式的 Web 开发框架，可以帮助开发人员快速构建灵活可扩展的 Web 应用程序。
    - Spring Boot 是 Spring Framework 的另一个重要模块，它是一种快速开发框架，旨在简化 Spring 应用程序的搭建和部署。Spring Boot 提供了一个开箱即用的应用程序开发环境，可以自动配置许多常用的组件和库，从而简化开发过程，减少了配置文件的编写，使得开发人员可以更专注于业务代码的编写。

#### 3、Redis 基础类型中的 String 底层实现是什么？

- Redis 中的 String 类型底层实现是一个简单动态字符串（SDS，Simple Dynamic String），也就是字符串动态增长实现的一种方式。SDS 是 Redis 自己实现的字符串库，相对于 C 语言原生的字符串，SDS 在空间使用上更加灵活，而且支持 O(1) 复杂度的长度计算，避免了 C 语言字符串计算长度时的 O(N) 时空复杂度问题。
- SDS 是一种动态字符串，它有如下特点：
    - 首先 SDS 对内存的分配和释放进行了封装，使得字符串的空间可以根据需要进行增长或缩减，避免了 C 语言字符串需要手动分配空间的问题。
    - SDS 除了记录字符串本身的长度外，还记录了分配给字符串的空间的长度，可以方便地计算出字符串是否需要扩容。
    - SDS 使用了惰性空间释放，不会在空间缩减时立即释放空间，而是等到需要扩容时再重新分配内存。
    - SDS 提供了字符串追加操作，可以在 O(1) 的时间内完成追加操作。



### Day 13

#### 1、有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？

- Spring 内置的 @Autowired 以及 JDK 内置的 @Resource 和 @Inject 都可以用于注入 Bean。
- 区别
    - @Autowired 是 Spring 提供的注解， @Resource 是 JDK 提供的注解。
    - Autowired 默认的注⼊⽅式为 byType （根据类型进⾏匹配）， @Resource 默认注⼊⽅式为byName （根据名称进⾏匹配）。
    - 当⼀个接⼝存在多个实现类的情况下， @Autowired 和 @Resource 都需要通过名称才能正确匹配到对应的 Bean。 Autowired 可以通过 @Qualifier 注解来显示指定名称， @Resource 可以通过 name 属性来显示指定名称。

#### 2、请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？

- JVM 内存模型分为以下几个区域：

    - 程序计数器（Program Counter Register）：每个线程都有自己的程序计数器，用于指示当前线程执行的字节码指令的行号，以便线程执行时能够回到正确的位置。

    - 虚拟机栈（JVM Stack）：也称为 Java 方法栈，用于存储方法执行时的局部变量表、操作数栈、动态链接、方法出口等信息。每个线程在执行一个方法时，都会为该方法分配一个栈帧，并将该栈帧压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈。

    - 本地方法栈（Native Method Stack）：与虚拟机栈类似，用于存储本地方法的执行信息。

    - 堆（Heap）：用于存储对象实例，是 JVM 中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的对象实例都有一个标记用于标记对象是否存活。垃圾回收器会周期性地回收那些没有被标记为存活的对象。

    - 方法区（Method Area）：用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也是被所有线程共享的。

    - 运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用，这些内容在类加载后进入常量池中。

- 程序计数器、虚拟机栈、本地方法栈是线程私有的，堆、方法区、运行时常量池是线程共享的。

#### 3、Linux 中的硬链接和软连接是什么，二者有什么区别？

- 在 Linux 文件系统中，硬链接（hard link）和软链接（symbolic link）都是一种文件链接的方式，可以用于将一个文件链接到另一个文件上。它们的主要区别在于创建方式、所占空间和使用限制等方面。
- 硬链接是通过在文件系统中创建一个新的目录项（directory entry）指向同一文件 inode 的位置来实现的。因为硬链接实际上是指向同一 inode，所以如果原文件被删除，硬链接依然能够访问到原文件的内容。硬链接的使用范围比较受限，因为硬链接只能指向同一个文件系统内的文件，不能跨文件系统创建。
- 软链接是通过在文件系统中创建一个新的文件来实现的，该文件中包含指向另一个文件的路径。软链接可以跨文件系统创建，并且可以指向任何类型的文件。但是，当原文件被删除时，软链接将会失效。



### Day 14

#### 1、如何使用 Redis 实现一个排行榜？

- 主要使用的是 ZSet 进行实现
    - 有序性：排行榜肯定需要实现一个排序的功能，在Redis中有序的数据结构有 List 和 ZSet
    - 支持分数操作：ZSet 可以对集合中的元素进行增删改查操作，十分贴合排行榜中用户分数动态变化的场景，而 List 并不能针对分数进行操作，只有其中的 value 进行操作
    - 支持范围查询：ZSet 可以按照分数进行范围查询，如排行榜中的 Top10 需求就可通过该特性进行实现
    - 支持去重：由于 ZSet 属于 Set 的特殊数据结构，因此同样拥有 Set 不可重复的特性，对于排行榜中不可出现重复项的需求也十分贴合，而 List 只能手动去重

#### 2、什么是网关，网关有哪些作用？

- 是在计算机网络中用于连接两个独立的网络的设备，它能够在两个不同协议的网络之间传递数据。在互联网中，网关是一个可以连接不同协议的网络的设备，比如说可以连接局域网和互联网，它可以把局域网的内部网络地址转换成互联网上的合法地址，从而使得局域网内的主机可以与外界通信。
- 网关可以用于实现负载均衡、安全过滤、协议转换等功能。具体来说，网关可以分为以下几种：
    - 应用网关：用于应用层协议的处理，如 HTTP、SMTP 等
    - 数据库网关：用于数据库访问的控制和管理。
    - 通信网关：用于不同通信协议之间的数据交换，如 TCP/IP、UDP/IP 等。
    - API 网关：用于管理和转发 API 请求，实现 API 的授权、限流、监控等功能

#### 3、线程的生命周期是什么，线程有几种状态，什么是上下文切换？

- Java中有六种状态：新建状态(New)、就绪状态(Runnable)、阻塞状态(Blocked)、等待状态(Waiting)、超时等待(Timed_Waiting)、终止状态(Terminated)
    - NEW：初始状态，线程被创建出来但没有被调用 start() 。
    - RUNNABLE：运⾏状态，线程被调用了 start() 等待运行的状态。
    - BLOCKED：阻塞状态，需要等待锁释放。
    - WAITING：等待状态，表示该线程需要等待其他线程做出⼀些特定动作（通知或中断）。
    - TIME_WAITING：超时等待状态，可以在指定的时间后⾃⾏返回⽽不是像 WAITING 那样⼀直等待。
    - TERMINATED：终⽌状态，表示该线程已经运⾏完毕。
- 上下文切换：
    - 指将当前线程的状态保存下来，并将CPU资源切换到另一个线程上运行的过程。上下文切换需要花费一定的时间和系统资源，因此，线程的上下文切换次数要尽量减少，以提高系统的性能。



### Day 15

#### 1、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？

- MVCC 是指多版本并发控制（Multiversion Concurrency Control），是一种并发控制机制，常用于数据库系统中，用于实现事务的并发控制。它允许在同一时间多个事务对同一个数据集合进行读取操作，同时防止数据不一致和其他并发问题。

- InnoDB 是 MySQL 中最常用的存储引擎之一，它的 MVCC 实现是通过在每行记录中添加两个隐藏的列，分别记录行的创建时间和过期时间，以此来判断事务对该行记录的可见性。当一个事务需要读取一行记录时，InnoDB 首先读取这行记录的创建时间和过期时间，并根据这些信息判断该行记录是否可见。如果创建时间早于当前事务的开始时间，且过期时间晚于当前事务的开始时间，那么该行记录对当前事务可见。
- 在 InnoDB 中，MVCC 主要是通过实现以下几个机制来实现的：
    - 事务版本号：每个事务都有一个唯一的版本号，用来标识该事务的创建时间。
    - 读取视图：每个事务在开始时都会创建一个读取视图，记录该事务开始时间和其他信息。在事务执行期间，所有读取操作都要检查该视图，以确定读取哪些版本的数据。
    - undo 日志：在事务执行期间，如果对数据进行修改，那么会先将原始数据复制一份到 undo 日志中。这样，在回滚操作时就可以使用 undo 日志中的数据来还原原始数据。
    - 快照读取：在某些情况下，事务需要读取一个数据的历史版本，而不是当前版本。这时可以使用快照读取来实现，即在读取时根据事务开始时间和 undo 日志来读取历史版本的数据。

#### 2、Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？

- RDB 持久化机制是指将 Redis 在内存中的数据以快照的形式写入磁盘中，可以手动或自动执行快照操作，将数据集的状态保存到一个 RDB 文件中
    - 优点：
        - RDB 机制适合在数据集比较大时进行备份操作，因为它可以生成一个非常紧凑、经过压缩的数据文件，对于备份、恢复、迁移数据都很方便。
        - RDB 机制在 Redis 重启时比 AOF 机制更快地将 Redis 恢复到内存中。
    - 缺点：
        - RDB 机制可能会出现数据丢失，因为数据是周期性地进行备份，一旦 Redis 出现问题并且上一次备份之后还没有进行过数据变更，那么这部分数据将会丢失。
        - RDB 机制会造成一定的 IO 压力，当数据集比较大时，进行备份操作可能会阻塞 Redis 服务器进程。
- AOF 持久化机制是指将 Redis 在内存中的操作命令以追加的形式写入到磁盘中的 AOF 文件，AOF 文件记录了 Redis 在内存中的操作过程，只要在 Redis 重启后重新执行 AOF 文件中的操作命令即可将数据恢复到内存中
    - 优点：
        - AOF 机制比 RDB 机制更加可靠，因为 AOF 文件记录了 Redis 执行的所有操作命令，可以确保数据不丢失。
        - AOF 机制在恢复大数据集时更加稳健，因为 AOF 文件记录了数据的操作过程，可以确保每一次操作都被正确地执行。
    - 缺点：
        - AOF 机制生成的 AOF 文件比 RDB 文件更大，当数据集比较大时，AOF 文件会比 RDB 文件占用更多的磁盘空间。
        - AOF 机制对于数据恢复的时间比 RDB 机制更加耗时，因为要重新执行 AOF 文件中的所有操作命令。
- 综上所述，RDB 适合用于数据集较大、备份、恢复数据和迁移数据等场景，AOF 适合用于数据可靠性要求高、数据恢复稳健等场景。

#### 3、Ngnix 是什么？它有哪些应用场景？

- Nginx 是一个高性能的开源Web服务器和反向代理服务器，可以处理大量的并发连接和请求。它使用事件驱动的异步架构和多线程设计，可以高效地处理并发请求，同时也支持反向代理、负载均衡、动态HTTP缓存、SSL/TLS终止、基于模块的扩展等功能。

    Nginx 的应用场景非常广泛，以下是其中的几个：

    1. Web 服务器：Nginx 可以作为 HTTP 服务器，处理并发的静态请求和动态请求，并且可以支持负载均衡和缓存，为网站提供高性能和高可用性。
    2. 反向代理服务器：Nginx 可以作为反向代理服务器，接收客户端请求并将其转发到后端服务器，同时也可以支持负载均衡和缓存。
    3. 邮件代理服务器：Nginx 可以作为邮件代理服务器，支持 POP3、IMAP 和 SMTP 协议，并且可以支持 SSL/TLS 加密和反垃圾邮件功能。
    4. 流媒体服务器：Nginx 可以作为流媒体服务器，支持 RTMP、HLS 和 DASH 协议，可以用于实现直播、点播和视频-on-demand（VoD）等场景。



### Day 16

#### 1、Dubbo 是什么？是否了解过它的架构设计？

- Dubbo 是一个高性能、轻量级的开源 Java RPC 框架，它提供了完整的 RPC 协议栈，包括服务发布、服务引用、负载均衡、容错、服务治和服务监控等功能，同时提供了可扩展的 RPC 协议、数据模型、序列化和网络传输等组件，支持多语言和多协议。
- Dubbo 的架构设计主要包括服务提供者、服务消费者、注册中心和监控中心四个角色。其中，服务提供者提供服务的实现，并通过注册中心将自己注册到服务治理中心；服务消费者则通过注册中心发现可用的服务，并通过负载均衡策略选择一个服务提供者进行调用；注册中心主要负责服务的注册、发现和路由；监控中心则负责服务的统计和监控。
- Dubbo 的架构设计采用了分层架构模式，将不同的功能模块进行分离，以达到模块化和可扩展的目的。同时，Dubbo 还提供了丰富的扩展点和插件机制，用户可以通过自定义扩展点和插件来满足不同的业务需求。

#### 2、synchronized 关键字是什么，有什么作用？

- `synchronized` 是 Java 中的一个关键字，用于实现线程同步。具体来说，`synchronized` 用于修饰方法或代码块，使得同一时刻只能有一个线程访问被修饰的代码，其他线程需要等待当前线程执行完毕后才能访问。
- `synchronized` 主要用于解决多线程并发访问共享资源时出现的线程安全问题。如果多个线程同时访问一个共享资源，就会出现多个线程同时修改这个资源的情况，从而导致数据不一致等问题。而使用 `synchronized` 可以保证同一时刻只有一个线程访问该资源，从而避免了线程安全问题。
- `synchronized` 的作用不仅限于线程同步，它还可以保证可见性和有序性，即保证在同一个锁上，一个线程修改了共享变量的值之后，另一个线程能够立即看到修改后的值，并且在多个线程执行顺序上保证了一致性。
- 使用 `synchronized` 会带来一定的性能损失，因为每次进入同步块时都需要获得锁，这会增加线程的等待时间和上下文切换的开销。同时，如果同步块的代码执行时间很短，也会增加不必要的性能开销。因此，需要根据具体情况来判断是否需要使用 `synchronized`。

#### 3、如何设计一个点赞系统？

- 设计一个点赞系统可以分为以下几个步骤：
    1. 确定需求：需要明确点赞的对象是什么，是否需要计数等信息，同时需要考虑点赞的业务场景，如用户点赞、文章点赞等。
    2. 数据库设计：需要设计点赞相关的数据表，可以包含点赞者 ID、被点赞对象 ID、点赞时间等字段。
    3. 接口设计：需要设计点赞相关的接口，包括点赞、取消点赞、查询点赞数等操作。
    4. 业务逻辑实现：在接口中实现点赞相关的业务逻辑，包括判断点赞状态、更新点赞数、更新点赞状态等操作。
    5. 安全性考虑：需要考虑并发访问的情况，可以使用分布式锁来保证数据一致性和安全性。
    6. 性能优化：如果点赞系统的访问量很高，可以使用缓存来提高性能，比如使用 Redis 来缓存点赞数等信息。
    7. 监控和日志：需要对点赞系统进行监控和日志记录，以便及时发现和排查问题。
- 总之，设计一个点赞系统需要综合考虑需求、数据库设计、接口设计、业务逻辑实现、安全性、性能优化等方面，同时需要不断优化和完善。



### Day 17

#### 1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？

- 内部类是指定义在某一个类中的类，主要分为成员内部类，静态内部类，局部内部类和匿名内部类四种。

- | 分类       | 定义                                               | 作用范围                                                     | 应用                                       |
    | ---------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
    | 成员内部类 | 与其外部类的其他成员变量和方法平级的内部类         | 可以访问外部类的所有成员变量和方法，也可以被外部类访问       | 为外部类提供服务的场景                     |
    | 静态内部类 | 用 static 修饰的内部类                             | 只能访问外部类的静态成员变量和方法，只能被外部类的静态方法访问 | 与外部无关或需要单例模式的场景             |
    | 局部内部类 | 定义在方法中的内部类，在方法中直接实例化           | 可以访问外部类或代码块中声明为 final 的变量，作用域仅限于方法内，不能使用访问控制符修饰 | 执行特定任务或逻辑操作场景                 |
    | 匿名内部类 | 没有名字的内部类，使用 new 接口或抽象类或 new 父类 | 没有名字、没有构造器、只能使用一次，必须继承一个父类型（接口或抽象类）或实现一个接口的局部内部类 | 创建回调函数、事件监听器、线程等临时性对象 |

#### 2、MySQL 覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。

- 覆盖索引是指一个包含了所有查询需要的列的索引，查询时可以直接从索引中取到需要的数据，而不需要再回到表中查找，从而可以提高查询效率。
- 联合索引是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描。
- 最左前缀匹配原则是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了 A、B、C 三列，那么查询时只能使用 A、AB 或 ABC 进行匹配，而不能只使用 B 或 C 进行匹配。这是因为如果查询时使用的列不是最左前缀列，那么 MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。

#### 3、Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？

- Spring 框架中处理线程并发问题的方式包括以下几种：
    - 同步关键字 synchronized：使用 synchronized 关键字可以对共享资源进行加锁，从而保证多线程访问时的同步性。但是，synchronized 对性能会产生一定的影响，并且容易导致死锁等问题。
    - Lock 接口：Lock 接口提供了比 synchronized 更加灵活的加锁方式，并且可以防止死锁问题的发生。但是，Lock 接口的使用相对较复杂，需要手动进行加锁和解锁操作。
    - ThreadLocal 类：ThreadLocal 类提供了线程本地变量的功能，可以让每个线程拥有自己的变量副本，从而避免了多个线程之间的共享问题。但是，ThreadLocal 类的使用需要注意内存泄漏问题。
- 关于 ThreadLocal，它是 Java 中一个非常重要的类，用于实现线程本地存储，即让每个线程都拥有自己的变量副本，从而避免多个线程之间的共享问题。在 Spring 框架中，ThreadLocal 类经常用于存储一些与当前线程相关的数据，例如请求上下文、用户信息等。通过将这些数据存储到 ThreadLocal 对象中，可以方便地在整个应用程序中进行访问和传递，同时避免了多个线程之间的共享问题。
- ThreadLocal 类的使用需要注意内存泄漏问题，因为线程本地变量只有在对应的线程被回收时才会被回收，如果没有及时清理，就可能导致内存泄漏问题。因此，在使用 ThreadLocal 类时，需要注意在不需要存储数据时及时调用 remove() 方法清理 ThreadLocal 对象中的数据。



### Day 18

#### 1、什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？

- MySQL 执行计划是 MySQL 查询优化器分析 SQL 查询时生成的一份详细计划，包括表如何连接、是否走索引、表扫描行数等。通过这份执行计划，我们可以分析这条 SQL 查询中存在的问题（如是否出现全表扫描），从而进行针对优化。MySQL 中可以在 SQL 语句的前面加上 `explain` 命令来获取执行计划

- 其中，各字段的含义如下：
    - id：SELECT 查询的序列号，表示执行 select 子句的顺序（id 相同，执行顺序从上到下；id 不同，值越大越先执行；如果是并集结果，则 id 值为 NULL）
    - select_type：查询类型，来区分简单查询、联合查询、子查询等。常见的类型有：
        - SIMPLE：简单查询，不包含表连接或子查询
        - PRIMARY：主查询，外层的查询
        - SUBQUERY：子查询中第一个 SELECT
        - UNION：UNION 后面的 SELECT 查询语句
        - UNION RESULT：UNION 合并的结果
    - table：查询用到的表名
    - partitions：匹配的分区，没有分区的表为 NULL
    - type :star:：连接的类型，常见的类型有（性能从好到差）：
        - system：存储引擎能够直接知道表的行数（如 MyISAM）并且只有一行数据
        - const：通过索引一次找到，通常在用主键或唯一索引时出现
        - eq_ref：用主键或唯一索引字段作为连接表条件
        - ref：用普通索引的字段作为连接表条件
        - range：对索引列进行范围查询
        - index：利用索引扫描全表
        - all：全表扫描
    - possible_keys：可能用到的索引
    - key :star:：实际使用的索引，没有使用为 NULL
    - key_len：索引字段的最大长度，在满足需求下越短越好
    - ref：当使用索引等值查询时，与索引作比较的列或常量
    - rows :star:：预计扫描的行数，值越大，查询性能越差
    - filtered：表示返回结果的行数占需读取行数的百分比
    - Extra :star:：有关查询执行的其他信息
        - using index：使用覆盖索引，不用回表查询
        - using where：使用 where 子句来过滤结果集
        - using temporary：使用到临时表来存储中间结果，可能会导致性能问题
        - using filesort：查询需要进行文件排序操作，可能会导致性能问题
        - using index condition：先根据能用索引的条件获取符合条件的数据行，然后在根据其他条件去过滤数据

#### 2、什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？

- 单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式的目的是确保类的一个唯一实例，因此其他类可以轻松地从一个可知的地方访问它。
- 单例模式有以下好处：
    - 节省系统资源：在系统中，如果有多个实例会造成资源浪费，而使用单例模式可以减少这种浪费。
    - 简化了对象访问：单例模式提供了一个全局的访问点，因此可以简化访问过程。
- 常用的单例模式实现方式有以下几种：
    - 饿汉式单例模式：在类加载时创建单例对象。缺点是不支持延迟加载。
    - 懒汉式单例模式：在第一次使用时才创建单例对象。缺点是需要考虑线程安全问题。
    - 双重检查锁单例模式：在第一次使用时创建单例对象，并使用双重检查锁定来确保线程安全。
    - 枚举单例模式：在枚举类型中创建单例对象，可以防止反射和序列化攻击。
- 应用场景：
    - 数据库连接池：通过单例模式，可以确保系统中只有一个数据库连接池。
    - 日志记录器：可以使用单例模式记录系统日志，这样可以确保系统中只有一个日志记录器。
    - 配置文件管理器：可以使用单例模式来管理应用程序的配置文件，这样可以避免重复读取配置文件的开销。
    - 线程池：可以使用单例模式来确保系统中只有一个线程池。
- 一个例子是 Spring 框架中的 ApplicationContext，它是一个全局访问点，提供了一个管理 Bean 的中央注册表。由于 Spring 中的 Bean 只需创建一次，因此 ApplicationContext 使用单例模式确保只有一个实例。

#### 3、什么是云原生？它有哪些优缺点？

- 云原生是一种开发和运行应用程序的方法，旨在利用云计算的弹性、可扩展性、可靠性和高可用性等优势。它通过将应用程序打包到容器中，使用容器编排工具进行管理，实现了应用程序在不同环境中的快速部署、弹性伸缩和高可用性。
- 云原生的优点包括：
    - 灵活性和可扩展性：容器可以快速部署和扩展，以满足不同的负载要求。
    - 高可用性：容器编排工具可以自动检测和恢复容器故障，提供高可用性。
    - 效率和成本优化：使用容器可以节省资源和成本，提高应用程序的运行效率。
    - 安全性：容器隔离应用程序的运行环境，减少了安全漏洞的风险。
- 云原生的缺点包括：
    - 学习曲线较陡峭：云原生技术较为复杂，需要学习一些新的技术和工具。
    - 可能存在依赖问题：应用程序可能依赖于某些特定的云原生技术或工具，这可能导致一些限制或局限性。
    - 管理和维护难度：容器编排工具可能需要额外的管理和维护，需要更多的操作和维护成本。
- 云原生的应用场景包括：
    - 微服务架构：云原生技术非常适合构建微服务架构，将应用程序拆分为小型、自治的服务。
    - 弹性伸缩：云原生技术可以根据应用程序的负载自动扩展或缩小容器的数量，以适应不同的负载要求。
    - 快速部署：使用云原生技术，可以快速地部署和更新应用程序，提高开发和部署效率。
    - 多云部署：云原生技术可以在多个云环境中运行，方便应用程序在不同云环境中的部署和迁移。
    - 数据处理和分析：云原生技术可以处理大规模的数据处理和分析任务，提高数据处理效率。



### Day 19

#### 1、TCP 和 UDP 协议有什么区别，分别适用于什么场景？

- TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们有以下的区别：

    1、**连接方面**

    TCP 是面向连接的协议，而 UDP 是无连接的协议。在 TCP 中，发送方和接收方必须先建立连接，然后才能传输数据。UDP 则不需要建立连接，直接发送数据即可。

    2、**可靠性**

    TCP 保证数据传输的可靠性，通过序列号、确认应答和重传机制等方式来保证数据的完整性和正确性。UDP 则不保证数据传输的可靠性，因为它不提供确认和重传机制。

    3、**传输速度**

    因为 TCP 要保证数据传输的可靠性，所以在传输速度方面相对较慢。而 UDP 则不需要进行复杂的传输控制，因此传输速度更快。

    4、**传输内容**

    TCP 是一种面向字节流的协议，将数据看作是一连串的字节流，没有明确的消息边界。UDP 则是面向报文的协议，将数据看作是一系列的报文，每个报文是一个独立的单元，具有明确的消息边界。

- 基于以上的特点，TCP 和 UDP 适用于不同的场景。TCP 适用于对传输可靠性要求比较高的场景，例如网页浏览、文件传输、邮件等。而 UDP 则适用于对传输可靠性要求较低、传输速度要求较高的场景，例如在线游戏、视频直播等。

#### 2、什么是分布式的 CAP 理论？

- CAP 理论是指一个分布式系统中，不可能同时满足以下三个条件：
    - **一致性（Consistency）**：所有节点在同一时间的看到的数据是一致的，即写数据操作时要同时更新相关副本，保证强一致性
    - **可用性（Availability）**：系统中能正常接收请求的节点都能在合理时间内返回结果，即系统在某些节点失效下仍能对外提供服务
    - **分区容错性（Partition Tolerance）**：什么是分区？分布式系统中存在很多节点，这些节点之间通过网络进行通信，当节点间的通信出了问题（如网络故障、机器故障等），就称系统出现了分区。而分区容错性就是出现分区问题时，系统还能继续对外提供服务
- 根据 CAP 理论，分布式系统只能满足其中的两个特性。然而实际上，**分区容错性是一定要满足的**，因为只要出现分区问题时整个系统就完全无法使用。因此，在分布式系统中，我们需要考虑的是**当出现分区问题时，选择的是一致性还是可用性，即 CP 还是 AP。**
    - CP 架构：当系统出现分区故障时，客户端发送的任意请求都会被卡死或超时，保证数据的强一致性。如 Zookeeper
    - AP 架构：当系统出现分区故障时，客户端依旧能获取数据，但有的是新数据，有的是旧数据。如 Eureka

#### 3、如何用 Redis 实现分布式 Session？

- 在分布式系统中，通常会将 Session 存储在 Redis 中来实现分布式 Session，这样就可以在多台服务器之间共享 Session 数据。实现分布式 Session 的方式有多种，其中一种常用的方式是使用 Redis 的数据结构 Hash。具体实现步骤如下：
    - 在用户登录成功后，将 Session 数据存储在 Redis 中。
    - 将 Redis 中的 Session 数据的 Key 设置为一个全局唯一的 ID，一般使用类似于“session:token”这样的格式，其中 token 是一个随机生成的字符串，用来标识这个 Session 数据。
    - 在客户端返回响应的同时，将 Session ID（即 token）以 Cookie 的形式返回给客户端。客户端在后续的请求中都会携带这个 Cookie。
    - 在后续的请求中，服务器会从客户端传递过来的 Cookie 中获取 Session ID，然后根据这个 ID 从 Redis 中获取对应的 Session 数据。如果 Redis 中没有找到对应的 Session 数据，那么就表示这个请求无法通过认证。
    - 在用户退出登录或 Session 失效时，需要将 Redis 中的对应 Session 数据删除。
- 可以使用 Redis 的 EXPIRE 命令来设置 Session 数据的过期时间，这样可以自动删除已经过期的 Session 数据。同时，还需要注意保护 Redis 中的 Session 数据不被恶意攻击者窃取，一般可以通过设置 Session 数据的前缀和使用随机的 Session ID 等方式来提高安全性。



### Day 20

#### 1、MySQL 支持哪些存储引擎？默认使用哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？

- MySQL 支持多种存储引擎，包括 InnoDB、MyISAM、MEMORY、CSV 等。默认情况下，MySQL 使用的存储引擎是 InnoDB。

    MyISAM 和 InnoDB 是 MySQL 中 **最常用** 的两种存储引擎，它们有以下区别：

    1. 锁定方式不同：MyISAM 使用表级锁定，而 InnoDB 使用行级锁定。在并发访问时，InnoDB 的锁定方式更加精细，可以避免锁定整个表，提高了并发性能。
    2. 数据完整性不同：MyISAM 不支持事务和外键约束，而 InnoDB 支持事务和外键约束，可以保证数据的完整性和一致性。
    3. 读写性能不同：MyISAM 的读写性能相对较高，适合于读密集型应用；而 InnoDB 的写性能相对较高，适合于写密集型应用。
    4. 空间利用率不同：MyISAM 不支持行级别的存储，存储空间利用率较低；而 InnoDB 支持行级别的存储，存储空间利用率更高。

    在选择 MyISAM 和 InnoDB 引擎时，需要考虑应用场景和需求：

    1. 如果应用主要是读操作，可以考虑选择 MyISAM 引擎，以提高读取性能。
    2. 如果应用主要是写操作或需要支持事务和外键约束，可以考虑选择 InnoDB 引擎，以保证数据的完整性和一致性。
    3. 如果需要高性能和高可用性，可以考虑选择使用 MySQL 集群或使用多个副本实例，并将数据分布在不同的节点上。

- 总结：MySQL 支持多种存储引擎，MyISAM 和 InnoDB 是其中最常用的两种，它们有不同的特点和优缺点，在选择时需要根据应用场景和需求进行考虑和权衡。

#### 2、Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？

- 在 Spring 中，BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，它们的区别和联系如下。
    - 区别：
        - BeanFactory 是 Spring 框架的基础设施，用于管理 Bean 的生命周期和依赖关系，提供了 IoC 和 DI 功能。ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能，例如国际化支持、AOP 支持等。
        - BeanFactory 是延迟加载的，即只有在获取 Bean 时才会进行实例化，可以减少系统资源的占用。而 ApplicationContext 在启动时会立即加载所有的 Bean，导致启动时间较长。
        - BeanFactory 是单例模式，即在整个应用中只有一个 BeanFactory 实例。而 ApplicationContext 可以有多个实例，并且可以通过父子容器的方式组织起来，方便模块化开发。
    - 联系：
        - BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，可以管理 Bean 的生命周期和依赖关系，提供了 IoC 和 DI 功能。
        - ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能，例如国际化支持、AOP 支持等，同时也支持 BeanFactory 的所有功能。
        - BeanFactory 和 ApplicationContext 都可以通过 XML 配置文件、Java 注解和 Java 代码等方式进行配置和管理。
        - BeanFactory 和 ApplicationContext 都可以管理单例 Bean 和原型 Bean，可以控制 Bean 的作用域和生命周期。
- 总结：BeanFactory 是 Spring 框架的基础设施，提供了 IoC 和 DI 功能，而 ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能和扩展性，可以通过多种方式进行配置和管理 Spring Bean。

#### 3、讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？

- Redis 是一种基于内存的键值数据库，由于内存有限，当 Redis 占用的内存达到上限时，就需要进行内存淘汰，以腾出一些内存空间。

- Redis 中同时使用了惰性过期和定期过期两种过期策略。 **Redis 的内存淘汰策略**，是指当内存使用达到 maxmemory 极限时，需要使用 LAU 淘汰算法来决定清理掉哪些数据，以保证新数据的存入。 Redis 默认情况下就是使用 LRU 策略算法。

- Redis 中的内存淘汰机制包括：

    - 定期删除：Redis 可以设置一个定时器，定期扫描键空间中的键，并删除已经过期的键。
    - 惰性删除：当一个键过期时，Redis 不会立即删除该键，而是等到该键被访问时再删除。
    - 内存淘汰策略：当 Redis 内存占用达到上限时，会根据内存淘汰策略来选择一些键进行删除，以腾出更多的内存空间。

- Redis 中的内存淘汰策略包括：

    - noeviction：禁止删除键，即不做任何操作。
    - allkeys-lru：从所有的键中选择最近最少使用的键进行删除。
    - allkeys-random：从所有的键中随机选择一些键进行删除。
    - volatile-lru：从已设置过期时间的键中选择最近最少使用的键进行删除。
    - volatile-random：从已设置过期时间的键中随机选择一些键进行删除。
    - volatile-ttl：从已设置过期时间的键中选择剩余时间最短的键进行删除。

    - 其中，noeviction 策略是最简单的策略，但可能会导致 Redis 内存占满，并导致 Redis 无法正常工作。其他策略则会根据不同的算法进行键的选择和删除，以尽可能地保留重要的键。

- 总之，Redis 中的内存淘汰机制是保证 Redis 正常运行的重要机制之一，内存淘汰策略则根据不同的场景选择合适的策略来删除不必要的键，以腾出更多的内存空间。



### Day 21

#### 1、Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使用多线程？

- redis 在 6.0 支持的多线程是指网络IO的多线程，而 redis 的指令执行还是单线程的
- redis 的性能取决于网络IO，内存和 CPU
- 在 redis6.0 之前的处理网络 IO 是单线程的，服务端对对客户端的请求，socket 的连接，指令数据的接收，解析都由一个线程来执行，效率较低
- redis6.0 之后支持网络 IO 的多线程，通过多线程并行的执行来提高网络 IO 的处理效率
- redis 的服务端对用户传过来的指令的执行还是单线程的
- redis 的网络 IO 多线程默认是关闭的，需要在 redis.conf 中进行配置
- redis 对指令的执行不改为多线程，是因为指令的执行是在内存中，没有性能的瓶颈，且 redis 对数据结构进行了很多的优化。若 redis 指令的执行支持多线程，则需要对数据的操作加锁的同步，这会导致性能的下降，代价较大。
- redis6.0 之前不使用多线程的原因：
- redis 的性能瓶颈为内存和网络，官方说明 redis 几乎不存在 CPU 的性能瓶颈问题
- redis 使用单线程，其可维护性提高
- redis 若使用多线程，会增加需要对数据加锁，这增加了系统的复杂度，且会造成性能下降

#### 2、HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？

- HTTP 协议中，GET 和 POST 都是 HTTP 请求方法，它们的主要区别如下：
    - 参数传递方式不同：GET 方法通过 URL 请求参数传递，而 POST 方法通过请求体传递参数。
    - 传输数据大小限制不同：GET 方法的请求参数和URL长度受限制，一般在 2KB 左右；而 POST 方法的请求体没有限制。
    - 数据安全性不同：GET 方法的参数和 URL 会被浏览器缓存，数据不太安全；而 POST 方法的请求参数不会被浏览器缓存，更加安全。
    - 请求语义不同：GET 方法用于获取资源，不应该对服务器端数据做出任何改变；而 POST 方法用于向服务器提交数据，可能对服务器端数据做出修改。
- 适用场景：
    - GET 方法适用于请求数据量较小，安全性要求不高，且不需要修改服务器端数据的场景，如查询页面；
    - POST 方法适用于请求数据量较大，安全性要求高，且需要修改服务器端数据的场景，如表单提交、文件上传等。

#### 3、什么是零拷贝？说一说你对零拷贝的理解？

- 零拷贝（Zero-Copy）是一种高效的数据传输技术，它可以将数据从内核空间直接传输到应用程序的内存空间中，避免了不必要的数据拷贝，从而提高了数据传输的效率和性能。
- 在传统的数据传输方式中，当应用程序需要从磁盘、网络等外部设备中读取数据时，操作系统需要先将数据从外部设备拷贝到内核空间的缓冲区，然后再将数据从内核空间拷贝到应用程序的内存空间中，这个过程中需要进行两次数据拷贝，浪费了大量的 CPU 时间和内存带宽。
- 而使用零拷贝技术，数据可以直接从外部设备复制到应用程序的内存空间中，避免了中间的内核空间缓冲区，减少了不必要的数据拷贝，提高了数据传输的效率和性能。
- 在网络编程中，零拷贝技术可以用于大文件的传输、网络文件系统的读写、数据库查询等场景中，提高数据传输的效率和响应速度。同时，零拷贝技术也可以减少系统内存的开销，提高系统的稳定性和可靠性。



### Day 22

#### 1、什么是 RPC？目前有哪些常见的 RPC 框架？实现 RPC 框架的核心原理是什么？

- RPC（Remote Procedure Call）是一种远程调用协议，允许一台计算机通过网络调用另一台计算机上的服务或方法。它可以让开发人员像调用本地方法一样调用远程方法，将网络通信细节封装起来，提高了分布式系统中各个模块之间的耦合性。
- 目前常见的 RPC 框架有：
    - Dubbo：阿里巴巴开源的分布式 RPC 框架，支持多种协议和负载均衡策略。
    - gRPC：Google 开源的高性能 RPC 框架，支持多种语言。
    - Thrift：Facebook 开源的跨语言 RPC 框架，支持多种传输协议和数据编解码方式。
    - Spring Cloud Netflix：Spring Cloud 的子项目之一，提供了基于 Netflix OSS 开源组件的微服务解决方案，包括服务发现、负载均衡、熔断器等功能。
- RPC 框架的核心原理是基于网络传输协议实现的远程方法调用。RPC 框架通常由服务提供者和服务消费者两部分组成，服务提供者将本地方法暴露成远程服务，服务消费者通过远程代理对象调用远程方法。
- 在实现远程方法调用时，需要进行序列化和反序列化操作。序列化将对象转换为二进制数据流，以便于在网络中传输；反序列化则将接收到的二进制数据流转换为对象。
- 为了提高性能，一些 RPC 框架使用了二进制协议，如 Dubbo 使用的 Hessian2 协议和 gRPC 使用的 Protocol Buffers 协议，与基于文本的协议（如 XML 和 JSON）相比，二进制协议具有更小的传输体积和更高的解析速度，能够减少网络传输的开销。

#### 2、设计模式可以分为哪几类？一共有多少种主流的设计模式？

- 设计模式主要分为三大类：
    1. 创建型模式：用于描述创建对象的方式；（单例、工厂）
    2. 结构型模式：用于描述如何组合对象，形成更大的结构；（代理）
    3. 行为型模式：用于描述对象之间的协作和职责分配。（观察者）
- 主流的设计模式以Spring框架中使用的为例：
    1. 单例模式：Spring 的 Bean 默认是单例模式，通过 Spring 容器管理 Bean 的生命周期，保证每个 Bean 只被创建一次，并在整个应用程序中重用。
    2. 工厂模式：Spring 使用工厂模式通过 BeanFactory 和 ApplicationContext 创建并管理 Bean 对象。
    3. 代理模式：Spring AOP 基于动态代理技术，使用代理模式实现切面编程，提供了对 AOP 编程的支持。
    4. 观察者模式：Spring 中的事件机制基于观察者模式，通过 ApplicationEventPublisher 发布事件，由 ApplicationListener 监听事件，实现了对象间的松耦合。
    5. 模板方法模式：Spring 中的 JdbcTemplate 使用了模板方法模式，将一些固定的流程封装在父类中，子类只需实现一些抽象方法即可。
    6. 策略模式：Spring 中的 HandlerInterceptor 和 HandlerExecutionChain 使用了策略模式，允许开发者自定义处理器拦截器，按照一定顺序执行。
    7. 责任链模式：Spring 中的过滤器和拦截器使用了责任链模式，多个过滤器和拦截器按照一定顺序执行，每个过滤器和拦截器可以拦截请求或者响应并做出相应的处理。

#### 3、如何在 10 亿个数据中找到最大的 1 万个？（提示：最小堆）

- 在 10 亿个数据中找到最大的 1 万个，可以使用最小堆（Min-Heap）算法来实现。
- 最小堆是一种特殊的二叉树结构，每个节点的值都小于或等于其左右子节点的值。在使用最小堆来查找最大的 1 万个数据时，可以先创建一个大小为 1 万的最小堆，然后将 10 亿个数据逐个加入堆中。当堆的大小超过了 1 万时，将堆顶元素（即最小值）弹出，再将当前元素加入堆中。当遍历完所有数据后，堆中剩余的 1 万个元素就是最大的 1 万个数据。
- 这种方法的时间复杂度为 O(n log k)，其中 n 是数据总数，k 是要查找的元素数量。因为要维护一个大小为 1 万的最小堆，所以空间复杂度也为 O(k)。



### Day 23

#### 1、讲一讲 Spring 框架中 Bean 的生命周期？

- 在 Spring 框架中，Bean 的生命周期包括以下几个阶段：
    - 实例化（Instantiation）：在这个阶段，Spring 将根据配置文件或注解等方式创建 Bean 实例，并将其存储在容器中。
    - 属性赋值（Populate Properties）：在这个阶段，Spring 将会自动将 Bean 的属性值从配置文件或注解等方式中注入到 Bean 实例中。
    - 初始化（Initialization）：在这个阶段，Spring 会调用 Bean 实例的 init-method 方法，完成一些初始化的操作，例如建立数据库连接等。
    - 使用（In Use）：在这个阶段，Bean 实例已经可以正常使用，供应用程序调用。
    - 销毁（Destruction）：在这个阶段，Spring 会调用 Bean 实例的 destroy-method 方法，完成一些资源的释放和清理操作，例如关闭数据库连接等。
- 具体的实现方式可以通过实现 BeanPostProcessor 和 BeanFactoryPostProcessor 接口来进行扩展。其中，BeanPostProcessor 接口定义了两个方法 postProcessBeforeInitialization 和 postProcessAfterInitialization，分别在 Bean 的初始化前后被调用，用于扩展 Bean 初始化的过程；BeanFactoryPostProcessor 接口则定义了一个方法 postProcessBeanFactory，用于在 Bean 工厂实例化 Bean 定义后对其进行修改。
- 总之，Spring 的 Bean 的生命周期通过上述阶段进行管理，开发者可以通过实现相关接口和方法来扩展和定制 Bean 的创建和销毁过程，以满足各种业务需求。

#### 2、Redis 有哪些数据类型？基础数据结构有几种？你还知道哪些 Redis 的高级数据结构？

- Redis 支持多种数据类型，不同的数据类型可以满足不同的需求。下面是 Redis 中常用的数据类型：
    - String（字符串）：Redis 中最基本的数据类型，可以存储任何形式的数据，例如整数、浮点数、二进制数据等。
    - Hash（哈希）：Redis 中的一种键值对类型，可以存储多个键值对，每个键值对又是一个键值对结构。
    - List（列表）：Redis 中的一个有序列表类型，可以存储多个元素，每个元素都有一个索引，支持多种列表操作，例如插入、删除、查找等。
    - Set（集合）：Redis 中的一种无序集合类型，可以存储多个元素，每个元素都是唯一的，支持多种集合操作，例如交集、并集、差集等。
    - Sorted Set（有序集合）：Redis 中的一种有序集合类型，可以存储多个元素，每个元素都有一个分值，支持根据分值进行排序和查询等操作。
- Redis 的基础数据结构有三种：字符串、列表和哈希，其他的数据类型都是基于这三种数据结构进行扩展和衍生的。例如，Redis 的 Set 数据类型就是基于字符串实现的。
- 除了基础数据结构之外，Redis 还提供了多种高级数据结构，例如：
    - HyperLogLog：一种基数估计算法，用于估计一个数据集合的基数。
    - GeoHash：一种地理位置编码算法，可以对地理位置信息进行编码和查询。
    - Pub/Sub：一种消息队列机制，可以实现消息的订阅和发布。
    - Bitmaps：一种位图数据结构，可以进行高效的位运算，用于统计用户在线时长、网站访问量等。
    - Lua 脚本：Redis 中可以使用 Lua 脚本进行扩展和定制，可以实现一些复杂的业务逻辑和算法。

#### 3、有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？

- RabbitMQ 
    - 优点：可靠性高、性能优秀、支持多种协议、有完善的管理界面。 
    - 缺点：部署和维护较为复杂。 适用场景：适用于高可靠性、高吞吐量、多协议、多语言的分布式系统场景。
- Kafka 
    - 优点：性能优秀、可扩展性好、可靠性高、支持多种数据处理模式。 
    - 缺点：管理界面不够完善、复杂度较高。 适用场景：适用于高吞吐量、高并发、数据处理流程复杂的场景，例如大数据处理、实时日志处理等。
- ActiveMQ 
    - 优点：功能齐全、易于使用、支持多种协议。 
    - 缺点：性能相对较低、可靠性不如 RabbitMQ。 适用场景：适用于需要使用多种协议、支持多种消息类型的场景，例如 Web 服务、企业应用集成等。
- RocketMQ 
    - 优点：性能优秀、可靠性高、支持海量数据存储和传输。 
    - 缺点：社区相对较小、功能不够完善。 适用场景：适用于海量数据存储和传输场景，例如电商、金融等领域。
- Redis 
    - 优点：速度极快、支持多种数据结构、支持事务操作、支持发布/订阅模式。 
    - 缺点：可靠性不如 RabbitMQ 和 Kafka。 适用场景：适用于对性能要求极高、需要使用多种数据结构和事务操作的场景，例如缓存、计数器、实时消息等。
