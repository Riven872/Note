### 一、JUC 基础

#### 1、start 方法

- Java 线程是通过 start 的方法启动执行的，主要内容在 native 方法 start0 中，调用的是底层 C 语言的函数
- 底层的函数中，是让 JVM 执行启动线程的操作
- 进程和线程都是操作系统层面的资源，因此会交由操作系统去创建并运行线程

#### 2、多线程相关概念

- 并发：是在**同一实体**上的多个事件，是在**一台处理器**上“同时”处理多个任务，同一时刻只有一个事件在发生
- 并行：是在**不同实体**上的多个事件，是在**多台处理器**上同时处理多个任务，同一时刻你做你的我做我的，大家互不干涉
- 守护线程：一种特殊的线程为其他线程提供服务，在后台完成一些系统性的服务。因为当没有服务对象时，就意味着程序需要完成的业务操作已经结束了，守护线程也就没有存在（服务）的意义，系统就可以退出了。所以当系统只剩下守护线程时，JVM 会自动退出



### 二、CompletableFuture

#### 1、Future 接口

- Future 接口（实现类是 FutureTask）**定义**了操作**异步任务**执行的一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等
- 比如：主线程让一个子线程去执行任务，子线程可能比较耗时，主线程将子线程启动完毕后，主线程就去忙自己的，过了一段时间才去获取子线程执行任务的结果或变成任务状态
- 即 Future 接口可以为主线程新开一个分支任务，专门为主线程处理耗时和费力的复杂业务，此时主线程不会被中断

#### 2、FutureTask 实现类

- 满足多线程 、有返回值、异步任务（能获取执行结果且能改变任务的状态）
- 优点：
    - Future + 线程池的异步多线程任务配合，能显著提高程序的执行效率
- 缺点：
    - get() 阻塞：一旦调用 get() 方法求结果，如果计算没有完成容器导致程序阻塞
    - isDone() 轮询：轮询的方式会耗费无谓的 CPU 资源
- 因此 Future 对于结果的获取不是很友好，只能通过阻塞或轮询的方法得到任务的结果

#### 3、CompletableFuture 对 Future 的改进

##### 3.1、概述

- CompletableFuture 提供了一种观察者模式类似的机制，可以让任务执行完成之后通知监听的一方
- CompletableFuture 实现了 CompletionStage 接口，CompletionStage 代表异步计算过程中的某一个阶段，一个阶段完成后可能触发另外一个阶段（就是说存在一个异步任务的执行可能依赖于上一个异步任务的结果）
- CompletableFuture 也实现了 Future 接口，因此 CompletableFuture 可能代表一个明确完成的 Future，也可能代表完成一个阶段 CompletionStage 

##### 3.2、使用

- 不推荐使用无参构造 new 一个实例，推荐使用四个静态构造方法创建

    - 无返回值
        - runAsync(Runnable runnable)
        - runAsync(Runnable runnable, Executor executor)
    - 有返回值
        - supplyAsync(Supplier\<U> supplier)
        - supplyAsync(Supplier\<U> supplier, Executor executor)
    - Executor executor 参数说明：如果没有指定的 Executor 方法，直接使用默认的 ForkJoinPool 作为它的线程池执行异步代码

- 注意：主线程结束时，会关闭 CompletableFuture 默认使用的线程池，而自定义的线程池需要手动关闭

- 优点：

    - 异步任务结束时，会自动回调某个对象的方法
    - 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行
    - 异步任务出错时，会自动回调某个对象的方法

    ```java
    /**
    	CompletableFuture 的使用
    	感觉类似 Js 的Promise 对象 .then() 和 .catch() 的处理
    */
    CompletableFuture.supplyAsync(() -> {
        // 执行异步逻辑，并设置返回值
        return xxx;
    }, threadPool).whenComplete((res, error) -> {
        // res 参数代表异步任务的返回值
        // error 参数代表执行异步任务的过程中触发的异常，无异常则为 null
        // 当异步任务执行完毕后，自动触发此回调，并异步任务处理之后的逻辑
        System.out.println(res);
    }).exceptionally(error -> {
        // 若触发异常，则可以进入此回调，并处理出现异常的逻辑
        System.out.println(error.getMessage());
    })
    ```

##### 3.3、常见方法

- 获得结果和触发计算：
    - 获得结果：
        - get()：没有计算完成时阻塞
        - get(long timeout, TimeUnit unit)：在超时时间内未完成时阻塞，超出时间后仍未完成，抛出超时异常
        - join()：与无参 get 作用相同，区别在于 join 不会抛出编译异常
        - getNow：传入一个 String，如果取值时计算完成则返回，未完成则返回传入的 String 值
    - 主动触发计算：
        - complete(T value)：是否打断 get 或 join 方法立即返回括号中的值，若打断了则该方法返回 true，get 或 join 方法返回括号内的值，若没有打断，则该方法返回 false，get 或 join 方法返回正常计算的值

- 对计算结果进行处理：
    - :star:thenApply：计算结果存在依赖关系，使这相关的线程**串行化**（类似于 .then() 之后再 .then()，但当其中一个 .then() 出了异常，那么会立即执行 .catch()，并不会走下一步）
    - handle：与上的区别是，当有异常时，可以带着异常的参数继续往下执行，而且 thenApply 只需要传一个返回值的参数，而 handle 需要传返回值和异常两个参数
    - 总结：exceptionnally 类似于 try / catch，whenComplete 和 handle 类似于 try / finally

- 对计算结果进行消费：

    - thenAccept：接收任务的处理结果，并消费处理，无返回结果

- 以上的总结：

    - thenRun：任务 A 执行完执行 B，并且 B 不需要 A 的结果
    - thenAccept：任务 A 执行完执行 B，B 需要 A 的结果，但是任务  B 无返回值
    - thenApply：任务 A 执行完执行 B，B 需要 A 的结果，且任务 B 有返回值

- thenRun 和 thenRunAysnc 的区别：

    - 没有传入自定义线程池时，两个方法都使用默认的线程池 ForkJoinPool

    - 当使用自定义线程池，即执行第一个任务的时候，传入了一个自定义线程池

        - 调用 thenRun 方法执行第二个任务时，则第二个任务和第一个任务共用同一个线程池
        - 调用 thenRunAsync 方法执行第二个任务时，则第一个任务使用传入的自定义线程池，第二个任务使用默认的 ForkJoinPool 线程池

    - 其他的如 thenAccept 和 thenAcceptAsync，thenApply 和 thenApplyAsync 等，区别也是同理

    - 底层源码

    - ```java
        // thenRun 方法
        public CompletableFuture<Void> thenRun(Runnable action){
            return uniRunStage(null, action);
        }
        // thenRunAysnc 方法
        // 其中，传入的 asyncPool 是一个 final 变量，其值为 ForkJoinPool.commonPool()，因此异步 Async 方法会调用默认的线程池
        public CompletableFuture<Void> thenRunAysnc(Runnable action){
            return uniRunStage(asyncPool, action);
        }
        ```

- 对计算速度进行选用：

    - applyToEither：两个 CompletableFuture 线程选择之中返回结果最快的一个

- 对计算结果进行合并：

    - thenCombine：两个 CompletionStage 任务都完成后，最终能把两个任务的结果一起交给 thenCombine 来处理，先完成的先等待其他分支任务的完成



### 三、线程锁

#### 1、悲观锁和乐观锁

##### 1.1、悲观锁

- 如 Synchronized 关键字和 Lock 实现类
- 认为自己在使用数据时，一定会有其他的线程来争抢临界资源，为了确保数据的一致性，会在获取数据时先加锁
- 适合**写操作多**的场景，先加锁可以保证写操作时的数据正确，显式的锁定之后再操作临界资源

##### 1.2、乐观锁

- 认为自己使用数据时，不会有别的线程来争抢临界资源，因此不会加锁
- 在 Java 中通过无锁编程去实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据，如果没有更新则当前线程将自己的数据写入，如果被其他线程更新则根据不同的实现方式执行不同的操作，如放弃修改、重试抢锁等
- 适合**读操作多**的场景，不加锁的特点能够使其读操作的性能大幅提升
- 判断规则
    - 版本号机制 Version
    - CAS 算法

#### 2、synchronized

##### 2.1、对象锁和类锁

- synchronized 锁普通方法时，锁的是当前调用的对象 this，被锁定之后，其他线程不允许进入到**当前对象**其他的 synchronized 方法，即**对象锁**
- synchronized 锁静态方法时，锁的是当前整个的 Class，被锁定之后，其他线程不允许进入到所有当前类实例化对象中的 synchronized 的静态方法，即**类锁**
- 但如果 synchronized 既有静态的，也有普通的，那么任何进程任何同类实例对象都无法访问静态方法， 但普通方法不限制实例对象（因为一个是类锁，一个是对象锁，性质不同），即静态同步方法和普通同步方法之间没有竞争条件
- 总结：
    - 作用于实例对象：当前实例加锁，进入同步代码前要获得**当前实例的锁**
    - 作用于代码块：对括号里配置的对象加锁
    - 作用于静态方法：当前类加锁，进去同步代码前要获得**当前类对象的锁**

##### 2.2、C++ 源码底层

- 通过 objectMonitor.hpp 可知，每个对象天生都带着一个监视器，每一个被锁住的对象都会和 Monitor 关联起来
- 比如在 objectMonitor 中，有 owner 字段指向持有 objectMonitor 对象的线程，还有比如记录锁的重入次数的字段、记录获取锁的次数的字段等

#### 3、公平锁和非公平锁

##### 3.1、公平锁

- 指多个线程按照申请锁的顺序来获取锁

##### 3.2、非公平锁（默认）

- 指多个线程获取锁的顺序不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转或线程饥饿的状态

##### 3.3、设计原理

- 线程的切换存在 CPU 时间片的浪费，因此非公平锁能更充分利用 CPU 的时间片，尽量减少 CPU 的空闲时间
- 采用非公平锁时，一个线程请求锁获取到同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变的非常大，所以减少了线程切换的开销
- 如果为了更高的吞吐量，可以使用非公平锁（因为节省了线程切换的开销），否则可以使用公平锁

#### 4、可重入锁（递归锁）

##### 4.1、概述

- 概念balabala：在一个 Synchronized 修饰的方法或代码块的内部调用**本类**的其他的 Synchronized 修饰的方法或代码块时，是永远可以得到锁的
- 可重入锁的优点是一定程度上避免死锁

##### 4.2、种类

- 隐式锁（Synchronized 关键字）：使用的锁是默认可重入的
- 显式锁（Lock 实现类）：获取到锁时要显式的加锁，进入内部方法获取到锁时，也要相应的加锁，内部方法完成时要显式的释放锁，最外部时也要进行释放。因此加锁释放是成对出现的，而且获取一次就要加一次锁，等“计数器”真正为 0 时，才是完全释放了锁

#### 5、死锁及排查

##### 5.1、概述

- 两个或以上的线程在执行过程中，因为争夺资源而造成互相等待的过程称为死锁，如果没有外力干涉将无法执行下去

##### 5.2、产生死锁的原因

- 系统资源不足
- 进程运行推进顺序不合理
- 资源分配不当

##### 5.3、验证是否发生了死锁

- 使用 bin 包中的 jps 来定位**进程**（类似 Linux 中的 ps -ef），命令为 jps -l
- 使用 jvm 自带的 jstach 用来追踪堆栈，命令为 jstack 进程号
- 如果有死锁发生，控制台中输出死锁发生的堆栈信息
- 或直接使用图形化界面 jconsole 检测死锁

### 四、LockSupport 与线程中断

#### 1、线程中断机制

##### 1.1、概述

- 一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止
- Java 中并没有办法立即停止一条线程，因此提供了一种用于停止线程的**协商**机制——中断，也就是中断标识协商机制
- 中断只是一种**协作协商**机制，Java 没有给中断增加任何语法，中断的过程完全需要程序员自己实现
- 如果要中断一个线程，需要手动调用该线程的 interrupt 方法，该方法也仅仅是将线程对象的中断标识设为 true，接着需要在自己的代码中不断地检测当前线程标识位，如果为 true，则表示别的线程请求这条线程中断
- interrupt 方法可以在别的线程中调用，也可以在别的线程中调用

##### 1.2、中断的相关 API 方法

- void interrupt()：设置线程的中断状态为 true，发起一个协商而不会立刻停止线程
    - 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true
    - 如果线程处于被阻塞状态（如 sleep、wait、join 等），在别的线程中调用当前线程对象的 interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException 异常，且**中断状态清除**返回 false 状态
    - 中断一个不活动的线程将不会产生任何影响，如某线程已经执行完毕，再给此线程使用 interrupt 方法时，该线程的中断状态依旧是 false，不会打上 true 标记，因此（中断一个不活动的线程将不会产生任何影响）
    - 调用的是 interrupt0() 方法，底层调用的方法是 native 类型的
- static boolean interrupted()：**首先**返回当前线程的中断状态，**然后**将当前线程的状态清零重新设为 false
    - 底层调用的是 native 类型的方法，且传入的参数为 true，意味着需要清除中断状态
- static boolean interrupted()：首先返回当前线程的中断状态，然后会将当前线程的中断状态清零并重新设为 false
- boolean isInterrupted()：判断当前线程是否被中断
    - 底层调用的是 native 类型的方法，且传入的参数为 false，意味着不需要清除中断状态

##### 1.3、如何停止中断运行中的线程

- 通过一个 volatile 变量实现

- 通过 atomBoolean实现

- 通过 Thread 类自带的中断 api 实现

    - 在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑 stop 线程

    - ```java
        while(Thread.currentThread().isInterrupted()){
            // 如果监听到中断状态为 true，则执行中断逻辑
            break;
        }
        // t2 线程向 t1 线程发出协商，将 t1 的中断标志位设为 true
        new Thread(() -> t1.interrupt();, "t2").start;
        // t1 也可以自己设置
        t1.interrupt();
        ```

#### 2、LockSupport

##### 2.1、概述

- 指 JUC.locks 包下的 LockSupport 类，用来创建锁和其他同步类的基本线程阻塞原语，是一个线程阻塞的工具类，所有方法都是静态的
- 调用的底层是 Unsafe 中的 native 代码
- 其中 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程

##### 2.2、线程的等待唤醒机制

- 让线程等待、唤醒的方法
    - 使用 Object 中的 wait() 方法让线程等待，使用 notify() 唤醒线程
        - 两个方法必须放在同步代码块或同步方法中，否则执行时会抛 IllegalMonitorStateException 非法管程异常
        - notify 放在 wait 前面时，无法唤醒
    - 使用 JUC 包中的 Condition 的 await() 方法让线程等待，使用 signal() 唤醒线程
        - 在 lock、unlock 方法里面才能正确使用以上两个方法，即先要取得锁，否则执行时会抛 IllegalMonitorStateException 非法管程异常
        - 同上，signal 放在 await 前面时，无法唤醒
    - LockSupport 类可以通过 park()、unpark(thread) 阻塞当前线程以及唤醒指定被阻塞的线程
        - 每个线程都有一个许可（permit），且**许可的累加上限是 1**
        - permit 许可默认为 0，因此一开始调用 park() 方法时当前线程会阻塞，直到有其他线程给当前线程发放 permit，才能被唤醒
        - 调用 unpark(thread) 方法后，就会将 thread 线程的许可证 permit 发放，自动唤醒 park 的线程，即之前阻塞中的 LockSupport.park() 方法会立即返回
        - 无锁块或上锁的要求
        - 可以先 unpark 发放 permit，再进行 park，不会因为先唤醒再等待造成错误
        - 当调用 park 方法时
            - 如果有 permit，则会直接消耗掉这个 permit 然后正常唤醒
            - 如果没有 permit，则在原地阻塞等待别的线程发放 permit
        - 当调用 unpark 方法时
            - 会增加一个 permit，但上限最多只有一个，不会进行累加
            - 如果没有线程进行 park，也可以先调用 unpark 提前发放 permit



### 五、Java 内存模型 JMM

#### 1、概述

- 是一种 Java 的内存模型，Java Memory Model，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的**内存访问效果**
- 是一种抽象的概念，是一组规范或约定
- JMM 的关键技术点都是围绕多线程的原子性、可见性和有序性展开的
- JMM 也是一种规范，理解 happens-before 规则，就可以编写并发安全的程序

#### 2、特性

- 可见性
    - 当一个线程修改了某一个共享变量的值，其他线程是否能够立即感知该变更，JMM 规定了所有的变量都存储在**主内存**中
    - 系统**主内存**共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”，因此每个线程都有自己的**工作内存**，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成

- 原子性
    - 一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰

- 有序性
    - 为了提升性能，编译器和处理器通常会对指定序列进行重新排序：即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，称为指令的重排序

#### 3、多线程对变量的读写过程

- 线程之间的共享变量存储在主内容中（硬件角度就是内存条）
- 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读 / 写共享变量的副本（硬件角度就是 CPU 的缓存，如寄存器、一缓、二缓、三缓）
- 线程对共享变量所有的操作都必须现在线程自己的工作内存中进行，然后回写主内存，**不能直接从主内存中读写**
- 不同线程之间无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行

#### 4、多线程先行发生原则之 happens-before

- 在 JMM 中，如果一个操作执行的结果需要对另一个操作可见或代码重排序，那么这两个操作之间必须存在 **happens-before 原则（即逻辑上的先后关系）**

- 总原则：
    - 如果一个操作**依赖（有 happens-before 关系）**于另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
    - 两个操作之间存在**依赖关系（有 happens-before 关系）**，并不意味着一定要按照 happens-before 原则制定的顺序来执行，如果重排序之后执行的结果与按照 happens-before 来执行的结果一致，那么这种重排序并不非法

#### 5、happens-before 常见规则

- 次序规则：**一个线程内**，按照代码顺序，写在前面的操作先行发生于写在后面的操作
- 锁定规则：一个 unlock 操作先行发生于后面（这个“后面”指时间上的后面）对**同一个锁**的 lock 操作
- volatile 规则：对一个 volatile 变量的写操作先行发生于后面（这个“后面”指时间上的后面）这个变量的读操作，前面的写对后面的读是可见的

- 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，那么操作 A 先行发生于操作 C
- 线程启动规则（Thread Start Rule）：Thread 对象的 start 方法先行发生于此线程的每一个动作
- 线程中断规则（Thread Interruption Rule）：先调用 interrupt() 设置中断标志位，才能检测中断是否发生
- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 isAlive() 等手段检测线程是否已经终止执行
- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始 



### 六、Volatile 与 JMM

#### 1、Volatile

- 被 Volatile 关键字修饰的变量的特点：可见性（写完后及时、直接刷新回主内存）、有序性（禁重排），但不具备原子性
- Volatile 的内存语义
    - 当写一个 Volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值立即刷新回主内存中
    - 当读一个 Volatile 变量时，会把该线程对应的本地内存设置为无效，需要重新回到主内存中读取最新共享变量
    - Volatile 的写内存语义是直接刷新到**主内存**中，读的内存语义是直接从**主内存**中读取
- **内存屏障** Memory Barrier 保证了被 Volatile 修饰变量的可见性和有序性

#### 2 、内存屏障

##### 2.1、概述

- 也叫内存栅栏、屏障指令，是一类同步屏障指令，是 CPU 或编辑器在对内存随机访问的操作中的一个同步点，使得此点之前所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序
- 通过内存屏障指令，Volatile 实现了 JMM 中的可见性和有序性（禁重排），但无法保证原子性
- 总结：对一个 Volatile 变量的写，先行发生于任意后续对这个 Volatile 变量的读，也叫写后读

##### 2.2、内存屏障分类

- 写屏障（Store Barrier）：告诉 CPU 在写屏障之前需要将所有存储在缓存中的数据同步到主内存（即：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中）
- 读屏障（Load Barrier）：保证后面读取的数据一定能够获取到最新的数据（即：在读指令之前插入读屏障，让工作内存或 CPU 高速缓存中的缓存数据失效，重新回到主内存中获取最新数据）
- 还有细分四种，不过是 native 层面的，过。

#### 3、Volatile 的非原子性

- Volatile 变量具备可见性，JVM 只保证从主内存加载到线程工作内存的值是最新的，**也仅仅是数据加载时是最新的**
- 在多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，主内存的 Volatile 变量发生修改之后，**线程工作内存中的数据将会作废**并去读主内存中的最新数据，操作会出现丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致
- Volatile 解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步
- Volatile 变量不适合参与到依赖当前值的计算，如i = 1 + 1、i++ 等，因此 Volatile 适用于保存某个状态的 boolean 类型或 int 类型的值



### 七、CAS

#### 1、概述

- compare and swap，比较并交换技术。包含三个操作数：内存位置、预期原值、更新值
- 执行 CAS 操作时，将内存位置的值与预期原值比较
    - 匹配，那么处理器会自动将该位置的值更新为新值
    - 不匹配，处理器不做任何操作，多个线程同时执行 CAS 操作时，只有一个会成功
- CAS 是 JDK 提供的**非阻塞**原子性的操作，**通过硬件来保证**了比较并更新的原子性，因为底层是一条 CPU 的原子指令（cmpxchg 指令），即 CAS 的原子性实际上是 CPU 实现独占的
- 底层调用的是 UnSafe 类的方法

#### 2、底层原理 

- UnSafe 类是 CAS 的核心类，Java 方法无法直接访问底层系统，需要通过 Native 方法来访问，UnSafe 相当于一个后门，基于该类可以**直接操作特定内存的数据**
- UnSafe 类中的所有方法都是 Native 修饰的，因此 UnSafe 类中的所有方法都直接调用操作系统底层资源执行相应的任务
- AtomicInteger 类主要利用 CAS、Volatile 和 Native 方法来保证原子操作，从而避免 Synchronized 的高开销，执行效率大为提升

#### 3、原子引用类型

- 使用 AtomicReference 可以自定义原子类型，类似于包装类，包装完之后就可以使用 Atom 类的方法

- ```java
    //将 User 类型包装到原子引用中
    AtomicReference<User> atomicReference = new AtomicReference<>();
    User foo = new User("name", 12);
    // 将实例化的 User 放入
    atomicReference.set(foo);
    // 可以使用 Atomic 的 API
    atomicReference.compareAndSet("参数1", "参数2");
    atomicReference.get();
    ```

#### 4、自旋锁

- 尝试获取锁的线程不会立即阻塞，而是采用循环的方式去**尝试**获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取
- 好处是减少线程上下文切换的消耗，没有 wait 那种的阻塞，缺点是循环会消耗 CPU

#### 5、CAS 的缺点

##### 5.1、开销问题

- 循环时间长，会给 CPU 带来很大的开销（忙等）

##### 5.2、ABA 问题

- 线程 1 从内存中取出 A，这时候线程 2 也从内存中取出 A，并且线程 2 进行一些操作将值变成了 B，用完值 B 之后，又将值变成了 A，此时线程 1 进行 CAS 操作时发现仍然是 A，预期是没有问题的，进行 CAS 操作成功。虽然线程 1 的 CAS 操作成功了，但是不代表这个过程是没有问题的

- 使用 AtomicStampedReference 类实现**版本号法解决** ABA 问题：该类需要传入期望的版本号，匹配时才会去修改，相应的也可以获取当前的版本号



### 八、原子操作类

#### 1、基本类型原子类

- 如：AtomicInteger、AtomicBoolean、AtomicLong
- 常用 API 如：获取当前值并设置新值、获取当前值并自增或自减、获取当前值并加上预期值、如果输入的数值等于预期值，则以原子方式将该值设置为输入值

#### 2、数组类型原子类

- 如：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
- 常用 API 跟上面差不多

#### 3、引用类型原子类:star:

- AtomicReference：包装自定义类，使其能试用 Atomic 类的方法
- AtomicStampedReference：带版本号，用来解决 ABA 问题，也可以解决**修改过几次**
- AtomicMarkableReference：原子更新标记位，用来解决**是否修改过**，将状态戳简化为 T / F

#### 4、对象的属性修改原子类

- AtomicIntegerFieldUpdater：原子更新对象中 int 类型字段的值

- AtomicLongFieldUpdater：原子更新对象中 Long 类型字段的值

- AtomicReferenceFieldUpdater：原子更新引用类型字段的值

    - ```java
        /**
        AtomicReferenceFieldUpdater 的初始化
        foo：类名
        String：需要修改的字段的类型
        foo.Class：需要修改的类
        "abcde"：需要修改的字段名
        */
        AtomicReferenceFieldUpdater<foo, String> referenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(foo.Class, "abcde");
        ```

- 目的：以一种线程安全的方式操作非线程安全对象内的**某些字段**

- 要求：

    - 更新的对象属性必须使用 public volatile 修饰符
    - 对象的属性修改类型原子类都是抽象类，所有每次使用都必须使用静态方法 newUpdater() 创建一个更新器，并且需要设置想要更新的类和属性

- 原理：需要传入操作的对象和修改的字段，即用到了反射技术

#### 5、原子操作增强类原理深度解析:star:

- 如：DoubleAccumulater、DoubleAdder、LongAccumulater（提供了自定义的函数操作）、LongAdder（只能用来计算加法，且从零开始）
- 常用 API ：返回当前值（在没有并发更新 value 时，会返回一个精确值，在高并发情况下，不保证返回精确值）
- LongAdder 对象在高并发场景下，比 AtomicLong 性能更好（减少了乐观锁的重试次数）

##### 5.1、原理（讲的有丶乱，用的时候再回来补）

- 高并发场景下，LongAdder 性能优于 AtomicLong，吞吐量会更高，但是空间消耗也更高。在正常情况下，两个类有相似的特征

##### 5.2、总结

- AtomicLong：（个人感觉是高一致性，舍弃了高并发）
    - 原理：CAS + 自旋、inCrementAndGet
    - 场景：低并发场景下的全局计算，且 AtomicLong 能保证并发情况下计数的准确性，内部通过 CAS 来解决并发安全问题
    - 缺陷：高并发后性能急剧下降，因为 AtomicLong 的自旋会成为瓶颈（N 个线程 CAS 操作修改线程的值，每次只有一个成功，其他的 N-1 失败，失败后的线程不停的自旋直到成功，这样大量失败自旋的情况下，会使 CPU 出现忙等）
- LongAdder：（个人感觉是高并发，但是舍弃了高一致性）
    - 原理：CAS + Base + Cell 数组分散、空间换时间并分散热点数据
    - 场景：高并发下的全局计算
    - 缺陷：sum 求和之后还有计算线程修改结果的话，最后结果不够准确



### 九、线程局部变量 ThreadLocal

#### 1、简介

- ThreadLocal 提供的线程局部变量与正常变量不同，因为每一个线程在访问 ThreadLocal 实例的时候，都有自己**独立**初始化的变量副本，以此将某些行为或状态与线程相关联
- 每一个线程都有自己专属的本地变量副本
- 必须回收自定义的 ThreadLocal 变量，尤其是在线程池的场景下，因为线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题

#### 2、源码分析

- Thread 类中包含 ThreadLocal 类，进一步体现了一个线程一个副本
- ThreadLocalMap 实际上就是一个以 ThreadLocal 实例为 key，任意对象为 value 的 Entry 对象（Entry 对象是一个 k-v 键值对）

#### 3、内存泄露问题:star:

##### 3.1、概述

- 不再会被使用的对象或者变量**占用的内存不能被回收**，就是内存泄露
- ThreadLocalMap 中的 Entry 对象继承了**弱引用**

##### 3.2、JVM 四种引用模式

- 强引用（默认模式）：对于强引用的对象而言，就算是出现了 OOM 或该对象以后永远不会被用到，JVM 也不会去回收
- 软引用：对于软引用的对象而言，当系统内存充足时，不会被回收，当系统内存不足时，才会被回收
- 弱引用：对于弱引用的对象而言，只要 GC 运行，不管 JVM 内存是否够用，都会回收该对象占用的内存
- 虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被 CG 回收，因此它不能单独使用也不能通过它访问对象，虚引用必须和**引用队列**联合使用

##### 3.3、为什么使用弱引用:star:

- ThreadLocalMap 是 Thread 类中的一个属性，通过 ThreadLocal 这个工具来实现对 ThreadLocalMap 的控制
- 当某一线程执行完毕后，Thread 也会被销毁，但此时 ThreadLocalMap 中的 Entry 的 key 还在指向该线程，因此如果这个 key 是强引用，指向的 Thread 即使销毁了也依然会存在不会被 GC，会造成内存泄露，因此使用弱引用，指向的线程结束后，在 GC 时就可以回收掉，大概率解决内存泄露的问题
- 即 Thread 没了，那么指向该 Thread 的 ThreadLocalMap 也需要被 GC 回收



### 十、Java 对象内存布局和对象头

#### 1、对象在堆内存中的布局

- 在 HotSpot 虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充

##### 1.1、对象头

- 对象标记（8 字节）
    - 哈希码
    - GC 标记
    - GC 次数
    - 同步锁标记
    - 偏向锁持有者
- 类元信息（也叫类型指针，8 字节）
    - 存储的是指向该对象类元数据的首地址
    - 即指向方法区的模板 Class 的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

##### 1.2、实例数据

- 存放类的属性（字段）数据信息，包括父类的属性信息
- 如果实例化一个对象时，该对象内没有属性，则在堆内存中只包含对象头

##### 1.3、对齐填充

- 虚拟机要求对象其实地址必须是 8 字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按 8 字节补充对齐



### 十一、Synchronized 与锁升级

#### 1、Synchronized 性能优化的背景

- synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock（系统互斥量）来实现的，挂起线程和恢复线程都需要**从用户态转换到内核态**完成

#### 2、Synchronized 升级流程

- Synchronized 用的锁是存在 Java 对象头中的 MarkWord（对象标记）中，锁升级功能主要依赖 MarkWord 中锁标志位和释放偏向锁标志位
- 偏向锁：MarkWord 存储的是偏向的线程 id
- 轻量锁：MarkWord 存储的是指向线程栈中 Lock Record 的指针
- 重量锁：MarkWord 存储的是指向堆中的 monitor 对象的指针

#### 3、Synchronized 锁种类

##### 3.1、无锁（001）

- 初始状态，一个对象被实例化后，如果还没有被任何线程竞争锁，那么它就为无锁状态

##### 3.2、偏锁（101）

- 锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程
- 单线程竞争，当某一线程第一次竞争到锁时，通过操作修改 MarkWord 中的偏向线程 id、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步
- 作用：当一段同步代码一直被同一个线程多次访问，由于只有一个线程，那么该线程在后续访问时就会自动获得锁，降低了线程切换时用户内核态的切换
- 高效的原因：偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步，也即偏向锁在资源没有竞争情况下消除了同步语句，懒得连 CAS 操作都不做了，直接提高性能
- 一句话：老熟人来饭店，店长问老样子？然后点头直接上菜，不需要再点单之类的复杂操作
- 原理：在锁第一次被拥有的时候，记录下偏向线程 id，下次再有线程尝试获取锁时，对比线程 id，如果线程 id 相同，则**不需要再次加锁释放锁**，只有在 id 不同时才会进行锁的操作
- 偏向锁的撤销：当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁，要升级为轻量锁。竞争线程尝试 CAS 更新对象头失败，会等到**全局安全点**撤销偏向锁

##### 3.3、轻锁（ 00）

- 多线程竞争，但是任意时刻最多只有一个线程竞争（即竞争对手只有一个），此时不存在竞争太过激烈的情况，也就没有线程阻塞。有线程来参与锁的竞争，但是获取锁的冲突时间极短，本质就是自旋锁 CAS
- 自旋达到一定的次数依然没有成功时，则会升级会重量级锁
- 自适应自旋锁：线程如果自旋成功，那么下次自旋的最大次数会增加，反之很少自旋成功，那么下次会减少自旋的次数

##### 3.4、重锁（10）

- 有大量的线程参与锁的竞争，冲突性很高



### 十二、AQS-AbstractQueuedSynchronizer

#### 1、概述

- 是用来实现锁或者其他同步器组件的公共基础部分的抽象实现，是重量级基础框架以及整个 JUC 体系的基石，主要用于解决锁分配给“谁”的问题
- 整体就是一个抽象的 FIFO 队列来完成资源获取线程的排队工作，并通过一个 int 类变量表示持有锁的状态
- AQS 统一规范并简化了锁的实现，将其抽象出来，是一切锁和同步组件实现的公共基础部分：同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等
- 每一个同步对象都会被封装到一个 node 节点中在同步器的双向链表中进行排队

#### 2、内部体系架构

##### 2.1、AQS 本身

- int 类型变量 state，用来标记状态位
- CLH 队列，双向队列，通过自旋的方式等待，并通过 state 变量判断是否阻塞。从头部出队，从尾部入队。用来存放等待获取锁的对象。
- 总结：有阻塞就需要排队，实现排队则需要队列，因此使用 state 变量 + CLH 双端队列

##### 2.2、内部类

- Node 类在 AQS 类的内部
- Node 类中有 int 类型变量 waitState，代表每个线程的等待状态



### 十三、ReentrantLock、ReentrantReadWriteLock、StampedLock

- 无锁 -> 独占锁 -> 读写锁 -> 邮戳锁

#### 1、ReentrantReadWriteLock 读写锁:star:

##### 1.1、概述

- 是一种**悲观锁策略**，并发效率较低
- 一个临界资源可以被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程
- ReentrantReadWriteLock 包括 readLock 和 writeLock 两种锁，在有线程获取到 writeLock 时，任何线程不能再获取 readLock 或 writeLock。但如果有线程获取到了 readLock，那么其他线程只能获取 readLock，而不能获取 writeLock，否则会出现读的过程中同时有写操作，造成脏读。
- 即**读写互斥**，读读共享，读没有完成时其他的线程写锁无法获得
- 读写锁只有在读多写少的情景之下，才具有较高的性能体现
- 缺点：写饥饿

##### 1.2、ReentrantReadWriteLock 的锁降级

- 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁，目的是保持数据的可见性，本质还是重入
- 写锁的降级，成了读锁
    - 如果**同一个线程**持有了写锁，在没有释放写锁的情况下，它还可以继续获取读锁，这就是写锁的降级，降级称为读锁
    - 按照次序，先获取写锁，然后获取读锁，再释放写锁
    - 如果释放了写锁，那么就完全转换为读锁
    - 获得写锁 -> 获得读锁 -> 释放写锁 -> 释放读锁
- 但不可锁升级，在读没有完成时无法获得写锁，必须要等读锁释放才有机会去获取写锁

#### 2、StampedLock 邮戳锁

##### 2.1、概述

- 是一种**乐观锁策略**，并发效率较高
- long 类型的 stamp 参数：代表了锁的状态，当 stamp 返回 0 时，表示线程获取锁失败，并且当释放锁或者转换锁时，都要传入最初获取的 stamp 值

##### 2.2、StampedLock 的特点

- 所有获取锁的方法，都返回一个 stamp 邮戳，stamp 为 0 表示获取失败，其余表示成功
- 所有释放锁的方法，都需要一个 stamp 邮戳，这个 stamp 必须是和成功获取锁时得到的 stamp 一致
- stampedLock 是**不可重入**的，如果一个线程已经持有了写锁，再去获取写锁的话会造成死锁
- 三种访问模式
    - Reading 读模式悲观：功能与 ReentrantReadWriteLock 的读锁类似
    - Writing 写模式：功能和 ReentrantReadWriteLock 的写锁类似
    - Optimistic reading 乐观读模式：无锁机制，支持读写并发，乐观的认为读取时没人修改，假如被修改再实现升级为悲观读模式
- 缺点：
    - 不支持重入
    - 悲观读锁和写锁都不支持条件变量 condition
    - 使用 StampedLock 一定不要调用中断操作（即 不要调用 interrupt 方法），可能会发生意外
