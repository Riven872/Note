### 一、JUC 基础

#### 1、start 方法

- Java 线程是通过 start 的方法启动执行的，主要内容在 native 方法 start0 中，调用的是底层 C 语言的函数
- 底层的函数中，是让 JVM 执行启动线程的操作
- 进程和线程都是操作系统层面的资源，因此会交由操作系统去创建并运行线程

#### 2、多线程相关概念

- 并发：是在**同一实体**上的多个事件，是在**一台处理器**上“同时”处理多个任务，同一时刻只有一个事件在发生
- 并行：是在**不同实体**上的多个事件，是在**多台处理器**上同时处理多个任务，同一时刻你做你的我做我的，大家互不干涉
- 守护线程：一种特殊的线程为其他线程提供服务，在后台完成一些系统性的服务。因为当没有服务对象时，就意味着程序需要完成的业务操作已经结束了，守护线程也就没有存在（服务）的意义，系统就可以退出了。所以当系统只剩下守护线程时，JVM 会自动退出



### 二、CompletableFuture

#### 1、Future 接口

- Future 接口（实现类是 FutureTask）**定义**了操作**异步任务**执行的一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等
- 比如：主线程让一个子线程去执行任务，子线程可能比较耗时，主线程将子线程启动完毕后，主线程就去忙自己的，过了一段时间才去获取子线程执行任务的结果或变成任务状态
- 即 Future 接口可以为主线程新开一个分支任务，专门为主线程处理耗时和费力的复杂业务，此时主线程不会被中断

#### 2、FutureTask 实现类

- 满足多线程 、有返回值、异步任务（能获取执行结果且能改变任务的状态）
- 优点：
    - Future + 线程池的异步多线程任务配合，能显著提高程序的执行效率
- 缺点：
    - get() 阻塞：一旦调用 get() 方法求结果，如果计算没有完成容器导致程序阻塞
    - isDone() 轮询：轮询的方式会耗费无谓的 CPU 资源
- 因此 Future 对于结果的获取不是很友好，只能通过阻塞或轮询的方法得到任务的结果

#### 3、CompletableFuture 对 Future 的改进

##### 3.1、概述

- CompletableFuture 提供了一种观察者模式类似的机制，可以让任务执行完成之后通知监听的一方
- CompletableFuture 实现了 CompletionStage 接口，CompletionStage 代表异步计算过程中的某一个阶段，一个阶段完成后可能触发另外一个阶段（就是说存在一个异步任务的执行可能依赖于上一个异步任务的结果）
- CompletableFuture 也实现了 Future 接口，因此 CompletableFuture 可能代表一个明确完成的 Future，也可能代表完成一个阶段 CompletionStage 

##### 3.2、使用

- 不推荐使用无参构造 new 一个实例，推荐使用四个静态构造方法创建

    - 无返回值
        - runAsync(Runnable runnable)
        - runAsync(Runnable runnable, Executor executor)
    - 有返回值
        - supplyAsync(Supplier\<U> supplier)
        - supplyAsync(Supplier\<U> supplier, Executor executor)
    - Executor executor 参数说明：如果没有指定的 Executor 方法，直接使用默认的 ForkJoinPool 作为它的线程池执行异步代码

- 注意：主线程结束时，会关闭 CompletableFuture 默认使用的线程池，而自定义的线程池需要手动关闭

- 优点：

    - 异步任务结束时，会自动回调某个对象的方法
    - 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行
    - 异步任务出错时，会自动回调某个对象的方法

    ```java
    /**
    	CompletableFuture 的使用
    	感觉类似 Js 的Promise 对象 .then() 和 .catch() 的处理
    */
    CompletableFuture.supplyAsync(() -> {
        // 执行异步逻辑，并设置返回值
        return xxx;
    }, threadPool).whenComplete((res, error) -> {
        // res 参数代表异步任务的返回值
        // error 参数代表执行异步任务的过程中触发的异常，无异常则为 null
        // 当异步任务执行完毕后，自动触发此回调，并异步任务处理之后的逻辑
        System.out.println(res);
    }).exceptionally(error -> {
        // 若触发异常，则可以进入此回调，并处理出现异常的逻辑
        System.out.println(error.getMessage());
    })
    ```

##### 3.3、常见方法

- 获得结果和触发计算：
    - 获得结果：
        - get()：没有计算完成时阻塞
        - get(long timeout, TimeUnit unit)：在超时时间内未完成时阻塞，超出时间后仍未完成，抛出超时异常
        - join()：与无参 get 作用相同，区别在于 join 不会抛出编译异常
        - getNow：传入一个 String，如果取值时计算完成则返回，未完成则返回传入的 String 值
    - 主动触发计算：
        - complete(T value)：是否打断 get 或 join 方法立即返回括号中的值，若打断了则该方法返回 true，get 或 join 方法返回括号内的值，若没有打断，则该方法返回 false，get 或 join 方法返回正常计算的值

- 对计算结果进行处理：
    - :star:thenApply：计算结果存在依赖关系，使这相关的线程**串行化**（类似于 .then() 之后再 .then()，但当其中一个 .then() 出了异常，那么会立即执行 .catch()，并不会走下一步）
    - handle：与上的区别是，当有异常时，可以带着异常的参数继续往下执行，而且 thenApply 只需要传一个返回值的参数，而 handle 需要传返回值和异常两个参数
    - 总结：exceptionnally 类似于 try / catch，whenComplete 和 handle 类似于 try / finally

- 对计算结果进行消费：

    - thenAccept：接收任务的处理结果，并消费处理，无返回结果

- 以上的总结：

    - thenRun：任务 A 执行完执行 B，并且 B 不需要 A 的结果
    - thenAccept：任务 A 执行完执行 B，B 需要 A 的结果，但是任务  B 无返回值
    - thenApply：任务 A 执行完执行 B，B 需要 A 的结果，且任务 B 有返回值

- thenRun 和 thenRunAysnc 的区别：

    - 没有传入自定义线程池时，两个方法都使用默认的线程池 ForkJoinPool

    - 当使用自定义线程池，即执行第一个任务的时候，传入了一个自定义线程池

        - 调用 thenRun 方法执行第二个任务时，则第二个任务和第一个任务共用同一个线程池
        - 调用 thenRunAsync 方法执行第二个任务时，则第一个任务使用传入的自定义线程池，第二个任务使用默认的 ForkJoinPool 线程池

    - 其他的如 thenAccept 和 thenAcceptAsync，thenApply 和 thenApplyAsync 等，区别也是同理

    - 底层源码

    - ```java
        // thenRun 方法
        public CompletableFuture<Void> thenRun(Runnable action){
            return uniRunStage(null, action);
        }
        // thenRunAysnc 方法
        // 其中，传入的 asyncPool 是一个 final 变量，其值为 ForkJoinPool.commonPool()，因此异步 Async 方法会调用默认的线程池
        public CompletableFuture<Void> thenRunAysnc(Runnable action){
            return uniRunStage(asyncPool, action);
        }
        ```

- 对计算速度进行选用：

    - applyToEither：两个 CompletableFuture 线程选择之中返回结果最快的一个

- 对计算结果进行合并：

    - thenCombine：两个 CompletionStage 任务都完成后，最终能把两个任务的结果一起交给 thenCombine 来处理，先完成的先等待其他分支任务的完成



### 三、线程锁

#### 1、悲观锁和乐观锁

##### 1.1、悲观锁

- 如 Synchronized 关键字和 Lock 实现类
- 认为自己在使用数据时，一定会有其他的线程来争抢临界资源，为了确保数据的一致性，会在获取数据时先加锁
- 适合**写操作多**的场景，先加锁可以保证写操作时的数据正确，显式的锁定之后再操作临界资源

##### 1.2、乐观锁

- 认为自己使用数据时，不会有别的线程来争抢临界资源，因此不会加锁
- 在 Java 中通过无锁编程去实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据，如果没有更新则当前线程将自己的数据写入，如果被其他线程更新则根据不同的实现方式执行不同的操作，如放弃修改、重试抢锁等
- 适合**读操作多**的场景，不加锁的特点能够使其读操作的性能大幅提升
- 判断规则
    - 版本号机制 Version
    - CAS 算法

#### 2、synchronized

##### 2.1、对象锁和类锁

- synchronized 锁普通方法时，锁的是当前调用的对象 this，被锁定之后，其他线程不允许进入到**当前对象**其他的 synchronized 方法，即**对象锁**
- synchronized 锁静态方法时，锁的是当前整个的 Class，被锁定之后，其他线程不允许进入到所有当前类实例化对象中的 synchronized 的静态方法，即**类锁**
- 但如果 synchronized 既有静态的，也有普通的，那么任何进程任何同类实例对象都无法访问静态方法， 但普通方法不限制实例对象（因为一个是类锁，一个是对象锁，性质不同），即静态同步方法和普通同步方法之间没有竞争条件
- 总结：
    - 作用于实例对象：当前实例加锁，进入同步代码前要获得**当前实例的锁**
    - 作用于代码块：对括号里配置的对象加锁
    - 作用于静态方法：当前类加锁，进去同步代码前要获得**当前类对象的锁**

##### 2.2、C++ 源码底层

- 通过 objectMonitor.hpp 可知，每个对象天生都带着一个监视器，每一个被锁住的对象都会和 Monitor 关联起来
- 比如在 objectMonitor 中，有 owner 字段指向持有 objectMonitor 对象的线程，还有比如记录锁的重入次数的字段、记录获取锁的次数的字段等

#### 3、公平锁和非公平锁

##### 3.1、公平锁

- 指多个线程按照申请锁的顺序来获取锁

##### 3.2、非公平锁（默认）

- 指多个线程获取锁的顺序不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转或线程饥饿的状态

##### 3.3、设计原理

- 线程的切换存在 CPU 时间片的浪费，因此非公平锁能更充分利用 CPU 的时间片，尽量减少 CPU 的空闲时间
- 采用非公平锁时，一个线程请求锁获取到同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变的非常大，所以减少了线程切换的开销
- 如果为了更高的吞吐量，可以使用非公平锁（因为节省了线程切换的开销），否则可以使用公平锁

#### 4、可重入锁（递归锁）

##### 4.1、概述

- 概念balabala：在一个 Synchronized 修饰的方法或代码块的内部调用**本类**的其他的 Synchronized 修饰的方法或代码块时，是永远可以得到锁的
- 可重入锁的优点是一定程度上避免死锁

##### 4.2、种类

- 隐式锁（Synchronized 关键字）：使用的锁是默认可重入的
- 显式锁（Lock 实现类）：获取到锁时要显式的加锁，进入内部方法获取到锁时，也要相应的加锁，内部方法完成时要显式的释放锁，最外部时也要进行释放。因此加锁释放是成对出现的，而且获取一次就要加一次锁，等“计数器”真正为 0 时，才是完全释放了锁

#### 5、死锁及排查

##### 5.1、概述

- 两个或以上的线程在执行过程中，因为争夺资源而造成互相等待的过程称为死锁，如果没有外力干涉将无法执行下去

##### 5.2、产生死锁的原因

- 系统资源不足
- 进程运行推进顺序不合理
- 资源分配不当

##### 5.3、验证是否发生了死锁

- 使用 bin 包中的 jps 来定位**进程**（类似 Linux 中的 ps -ef），命令为 jps -l
- 使用 jvm 自带的 jstach 用来追踪堆栈，命令为 jstack 进程号
- 如果有死锁发生，控制台中输出死锁发生的堆栈信息
- 或直接使用图形化界面 jconsole 检测死锁

### 四、LockSupport 与线程中断

#### 1、线程中断机制

##### 1.1、概述

- 一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止
- Java 中并没有办法立即停止一条线程，因此提供了一种用于停止线程的**协商**机制——中断，也就是中断标识协商机制
- 中断只是一种**协作协商**机制，Java 没有给中断增加任何语法，中断的过程完全需要程序员自己实现
- 如果要中断一个线程，需要手动调用该线程的 interrupt 方法，该方法也仅仅是将线程对象的中断标识设为 true，接着需要在自己的代码中不断地检测当前线程标识位，如果为 true，则表示别的线程请求这条线程中断
- interrupt 方法可以在别的线程中调用，也可以在别的线程中调用

##### 1.2、中断的相关 API 方法

- void interrupt()：设置线程的中断状态为 true，发起一个协商而不会立刻停止线程
    - 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true
    - 如果线程处于被阻塞状态（如 sleep、wait、join 等），在别的线程中调用当前线程对象的 interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException 异常，且**中断状态清除**返回 false 状态
    - 中断一个不活动的线程将不会产生任何影响，如某线程已经执行完毕，再给此线程使用 interrupt 方法时，该线程的中断状态依旧是 false，不会打上 true 标记，因此（中断一个不活动的线程将不会产生任何影响）
    - 调用的是 interrupt0() 方法，底层调用的方法是 native 类型的
- static boolean interrupted()：**首先**返回当前线程的中断状态，**然后**将当前线程的状态清零重新设为 false
    - 底层调用的是 native 类型的方法，且传入的参数为 true，意味着需要清除中断状态
- static boolean interrupted()：首先返回当前线程的中断状态，然后会将当前线程的中断状态清零并重新设为 false
- boolean isInterrupted()：判断当前线程是否被中断
    - 底层调用的是 native 类型的方法，且传入的参数为 false，意味着不需要清除中断状态

##### 1.3、如何停止中断运行中的线程

- 通过一个 volatile 变量实现

- 通过 atomBoolean实现

- 通过 Thread 类自带的中断 api 实现

    - 在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑 stop 线程

    - ```java
        while(Thread.currentThread().isInterrupted()){
            // 如果监听到中断状态为 true，则执行中断逻辑
            break;
        }
        // t2 线程向 t1 线程发出协商，将 t1 的中断标志位设为 true
        new Thread(() -> t1.interrupt();, "t2").start;
        // t1 也可以自己设置
        t1.interrupt();
        ```

#### 2、LockSupport

##### 2.1、概述

- 指 JUC.locks 包下的 LockSupport 类，用来创建锁和其他同步类的基本线程阻塞原语，是一个线程阻塞的工具类，所有方法都是静态的
- 调用的底层是 Unsafe 中的 native 代码
- 其中 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程

##### 2.2、线程的等待唤醒机制

- 让线程等待、唤醒的方法
    - 使用 Object 中的 wait() 方法让线程等待，使用 notify() 唤醒线程
        - 两个方法必须放在同步代码块或同步方法中，否则执行时会抛 IllegalMonitorStateException 非法管程异常
        - notify 放在 wait 前面时，无法唤醒
    - 使用 JUC 包中的 Condition 的 await() 方法让线程等待，使用 signal() 唤醒线程
        - 在 lock、unlock 方法里面才能正确使用以上两个方法，即先要取得锁，否则执行时会抛 IllegalMonitorStateException 非法管程异常
        - 同上，signal 放在 await 前面时，无法唤醒
    - LockSupport 类可以通过 park()、unpark(thread) 阻塞当前线程以及唤醒指定被阻塞的线程
        - 每个线程都有一个许可（permit），且**许可的累加上限是 1**
        - permit 许可默认为 0，因此一开始调用 park() 方法时当前线程会阻塞，直到有其他线程给当前线程发放 permit，才能被唤醒
        - 调用 unpark(thread) 方法后，就会将 thread 线程的许可证 permit 发放，自动唤醒 park 的线程，即之前阻塞中的 LockSupport.park() 方法会立即返回
        - 无锁块或上锁的要求
        - 可以先 unpark 发放 permit，再进行 park，不会因为先唤醒再等待造成错误
        - 当调用 park 方法时
            - 如果有 permit，则会直接消耗掉这个 permit 然后正常唤醒
            - 如果没有 permit，则在原地阻塞等待别的线程发放 permit
        - 当调用 unpark 方法时
            - 会增加一个 permit，但上限最多只有一个，不会进行累加
            - 如果没有线程进行 park，也可以先调用 unpark 提前发放 permit



### 五、Java 内存模型 JMM

#### 1、概述

- 是一种 Java 的内存模型，Java Memory Model，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的**内存访问效果**
- 是一种抽象的概念，是一组规范或约定
- JMM 的关键技术点都是围绕多线程的原子性、可见性和有序性展开的
- JMM 也是一种规范，理解 happens-before 规则，就可以编写并发安全的程序

#### 2、特性

- 可见性
    - 当一个线程修改了某一个共享变量的值，其他线程是否能够立即感知该变更，JMM 规定了所有的变量都存储在**主内存**中
    - 系统**主内存**共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”，因此每个线程都有自己的**工作内存**，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成

- 原子性
    - 一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰

- 有序性
    - 为了提升性能，编译器和处理器通常会对指定序列进行重新排序：即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，称为指令的重排序

#### 3、多线程对变量的读写过程

- 线程之间的共享变量存储在主内容中（硬件角度就是内存条）
- 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读 / 写共享变量的副本（硬件角度就是 CPU 的缓存，如寄存器、一缓、二缓、三缓）
- 线程对共享变量所有的操作都必须现在线程自己的工作内存中进行，然后回写主内存，**不能直接从主内存中读写**
- 不同线程之间无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行

#### 4、多线程先行发生原则之 happens-before

- 在 JMM 中，如果一个操作执行的结果需要对另一个操作可见或代码重排序，那么这两个操作之间必须存在 **happens-before 原则（即逻辑上的先后关系）**

- 总原则：
    - 如果一个操作**依赖（有 happens-before 关系）**于另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
    - 两个操作之间存在**依赖关系（有 happens-before 关系）**，并不意味着一定要按照 happens-before 原则制定的顺序来执行，如果重排序之后执行的结果与按照 happens-before 来执行的结果一致，那么这种重排序并不非法

#### 5、happens-before 常见规则

- 次序规则：**一个线程内**，按照代码顺序，写在前面的操作先行发生于写在后面的操作
- 锁定规则：一个 unlock 操作先行发生于后面（这个“后面”指时间上的后面）对**同一个锁**的 lock 操作
- volatile 规则：对一个 volatile 变量的写操作先行发生于后面（这个“后面”指时间上的后面）这个变量的读操作，前面的写对后面的读是可见的

- 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，那么操作 A 先行发生于操作 C
- 线程启动规则（Thread Start Rule）：Thread 对象的 start 方法先行发生于此线程的每一个动作
- 线程中断规则（Thread Interruption Rule）：先调用 interrupt() 设置中断标志位，才能检测中断是否发生
- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 isAlive() 等手段检测线程是否已经终止执行
- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始 



### 六、Volatile 与 JMM

#### 1、Volatile

- 被 Volatile 关键字修饰的变量的特点：可见性（写完后及时、直接刷新回主内存）、有序性（禁重排），但不具备原子性
- Volatile 的内存语义
    - 当写一个 Volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值立即刷新回主内存中
    - 当读一个 Volatile 变量时，会把该线程对应的本地内存设置为无效，需要重新回到主内存中读取最新共享变量
    - Volatile 的写内存语义是直接刷新到**主内存**中，读的内存语义是直接从**主内存**中读取
- **内存屏障** Memory Barrier 保证了被 Volatile 修饰变量的可见性和有序性

#### 2 、内存屏障

##### 2.1、概述

- 也叫内存栅栏、屏障指令，是一类同步屏障指令，是 CPU 或编辑器在对内存随机访问的操作中的一个同步点，使得此点之前所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序
- 通过内存屏障指令，Volatile 实现了 JMM 中的可见性和有序性（禁重排），但无法保证原子性
- 总结：对一个 Volatile 变量的写，先行发生于任意后续对这个 Volatile 变量的读，也叫写后读

##### 2.2、内存屏障分类

- 写屏障（Store Barrier）：告诉 CPU 在写屏障之前需要将所有存储在缓存中的数据同步到主内存（即：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中）
- 读屏障（Load Barrier）：保证后面读取的数据一定能够获取到最新的数据（即：在读指令之前插入读屏障，让工作内存或 CPU 高速缓存中的缓存数据失效，重新回到主内存中获取最新数据）
- 还有细分四种，不过是 native 层面的，过。

#### 3、Volatile 的非原子性

- Volatile 变量具备可见性，JVM 只保证从主内存加载到线程工作内存的值是最新的，**也仅仅是数据加载时是最新的**
- 在多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，主内存的 Volatile 变量发生修改之后，**线程工作内存中的数据将会作废**并去读主内存中的最新数据，操作会出现丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致
- Volatile 解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步
- Volatile 变量不适合参与到依赖当前值的计算，如i = 1 + 1、i++ 等，因此 Volatile 适用于保存某个状态的 boolean 类型或 int 类型的值



### 七、CAS

#### 1、概述

- compare and swap，比较并交换技术。包含三个操作数：内存位置、预期原值、更新值
- 执行 CAS 操作时，将内存位置的值与预期原值比较
    - 匹配，那么处理器会自动将该位置的值更新为新值
    - 不匹配，处理器不做任何操作，多个线程同时执行 CAS 操作时，只有一个会成功
- CAS 是 JDK 提供的**非阻塞**原子性的操作，**通过硬件来保证**了比较并更新的原子性，因为底层是一条 CPU 的原子指令（cmpxchg 指令），即 CAS 的原子性实际上是 CPU 实现独占的
- 底层调用的是 UnSafe 类的方法

#### 2、底层原理 

- UnSafe 类是 CAS 的核心类，Java 方法无法直接访问底层系统，需要通过 Native 方法来访问，UnSafe 相当于一个后门，基于该类可以**直接操作特定内存的数据**
- UnSafe 类中的所有方法都是 Native 修饰的，因此 UnSafe 类中的所有方法都直接调用操作系统底层资源执行相应的任务
- AtomicInteger 类主要利用 CAS、Volatile 和 Native 方法来保证原子操作，从而避免 Synchronized 的高开销，执行效率大为提升

#### 3、原子引用类型

- 使用 AtomicReference 可以自定义原子类型，类似于包装类，包装完之后就可以使用 Atom 类的方法

- ```java
    //将 User 类型包装到原子引用中
    AtomicReference<User> atomicReference = new AtomicReference<>();
    User foo = new User("name", 12);
    // 将实例化的 User 放入
    atomicReference.set(foo);
    // 可以使用 Atomic 的API
    atomicReference.compareAndSet("参数1", "参数2");
    atomicReference.get();
    ```

#### 4、自旋锁

- 尝试获取锁的线程不会立即阻塞，而是采用循环的方式去**尝试**获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取
- 好处是减少线程上下文切换的消耗，没有 wait 那种的阻塞，缺点是循环会消耗 CPU

#### 5、CAS 的缺点

##### 5.1、开销问题

- 循环时间长，会给 CPU 带来很大的开销（忙等）

##### 5.2、ABA 问题

- 线程 1 从内存中取出 A，这时候线程 2 也从内存中取出 A，并且线程 2 进行一些操作将值变成了 B，用完值 B 之后，又将值变成了 A，此时线程 1 进行 CAS 操作时发现仍然是 A，预期是没有问题的，进行 CAS 操作成功。虽然线程 1 的 CAS 操作成功了，但是不代表这个过程是没有问题的

- 使用 AtomicStampedReference 类实现**版本号法解决** ABA 问题：该类需要传入期望的版本号，匹配时才会去修改，相应的也可以获取当前的版本号
