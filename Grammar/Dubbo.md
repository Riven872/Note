#### Dubbo-RPC框架

##### 一、基础知识

###### 1、RPC

- Remote Procedure Call，远程过程调用，允许程序远程调用另一个地址空间的过程和函数  

###### 2、PRC的核心模块：通讯、序列化

- 调用者与被调用者之间建立通信的效率
- 调用者与被调用者之间进行通信时，序列化与反序列化的效率

###### 3、Dubbo架构

- 其中，推荐用zookeeper作为注册中心

![image-20221117120352031](D:\GitHub\Note\Grammar\img_md\image-20221117120352031.png)

##### 二、Dubbo配置

##### 三、高可用

###### 1、zookeeper宕机、Dubbo直连

- zookeeper注册中心宕机，还可以消费dubbo暴露的服务
- 监控中心宕掉不影响使用，只是丢失部分采样的数据
- 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但是不能注册为新服务
- 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
- 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
- 服务提供者无状态，任意一台宕掉后，不影响使用
- 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

###### 2、集群下dubbo负载均衡配置

- 负载均衡策略
    - 随机：基于权重的随机负载均衡机制
    - 轮询：基于权重的轮询负载均衡机制
    - 最少活跃调用数
    - 一致性Hash：参数经过Hash后，哈希值相同的请求发送到同一服务器

###### 3、服务降级

- 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作
- 可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略
- dubbo服务降级方案
    - `mock=force:return+null`：表示消费方对该服务的方法调用都直接返回null值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响（直接不进行调用）
    - `mock=fail:return+null`：表示消费方对该服务的方法调用在失败后，再返回null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响（进行调用，但是失败后返回空且不抛异常）

###### 4、集群容错模式

- 失败时自动切换 （默认）
    - 重试其他的服务器。重试会带来更长的延迟，也可以自定义重试次数
- 快速失败
    - 只发起一次调用，失败立即报错（适用于非幂等性的操作）
- 失败安全
    - 出现异常时，直接忽略，会记入日志
- 失败自动恢复
    - 后台记录失败请求，定时重发（适用于消息通知等操作一定要成功的操作）
- 并行调用多个服务器
    - 只要一个成功即返回，但会浪费更多的服务资源，可以自定义最大并行数（适用于实时性要求较高的读操作）
- 广播调用所有提供者
    - 逐个调用服务器，任意一台报错则报错，可以达成同步的效果（适用于通知所有提供者更新缓存或日志等本地资源信息）

##### 四、Dubbo原理

###### 1、PRC原理

- 一次完整的RPC调用流程（同步）
    - 1、服务消费方（client）调用以本地调用方式调用服务
    - 2、服务消费方代理（client stub）接受到调用后负责将方法、参数等组装成能够进行网络传输的消息体
    - 3、服务消费方代理（client stub）找到服务地址，并将消息发送到服务端
    - 4、服务提供方代理（server stub）收到消息后进行解码
    - 5、服务提供方代理（server stub）根据解码结果调用本地的服务
    - 6、本地服务执行并将结果返回给服务提供方代理（server stub）
    - 7、服务提供方代理（server stub）将返回结果打包成消息并发送至消费方
    - 8、服务消费方代理（client stub）接收到消息，并进行解码
    - 9、服务消费方得到最终结果（client）
- RPC框架的目的是将2-8步骤封装起来，这些细节对用户来说是透明不可见的

###### 2、netty通信原理

- 异步事件驱动的网络应用程序框架
- 选择器selector，多路复用

###### 3、dubbo整体的框架设计

- 业务逻辑层
    - service（服务层）：面向接口编程，提供接口和接口的实现类，要远程调用时只需要调用接口中的方法
- RPC层（远程调用层）
    - Config（配置层）：解析配置文件中的配置信息，如ReferenceConfig、ServiceConfig
    - Proxy（服务代理层）：利用代理的方式，生成服务提供方和消费方的代理对象
    - Registry（注册中心层）：服务要注册到注册中心，消费者要订阅需要的服务，完成如服务的发现、服务的注册
    - Cluster（路由层）：可以负载均衡的功能
    - Monitor（监控层）：每一次调用信息等都会发给监控层，然后以界面的方式展示出来
    - Protocol（远程调用层）：完成远程调用
- Remoting（远程通信层）
    - Exchage（信息交换层）：创建一个客户端和服务端，双方架起管道，进行数据的互联互通
    - Transport（传输层）：用Netty框架来传输数据
    - Serialize（序列化层）：进行序列化和反序列化的工作

###### 4、dubbo启动解析、加载配置信息

- spring解析配置文件中，有一个总接口`BeanDefinitionParser`，即Bean解析器，其中有`DubboBeanDefinitionParser`实现了总接口来解析标签（Spring的IOC容器一启动，就会来解析标签）
- IOC容器启动：解析配置文件->`DubboNameSpaceHandler`：创建Dubbo标签解析器->`DubboBeanDefinitionParser`：解析Dubbo标签
- 每个标签都有对应的config，如RegistryConfig、ServiceBean等

###### 5、dubbo服务暴露流程

- ServiceBean解析完毕，等IOC容器创建完成时，会触发`ContextRefreshEvent`进行回调，然后进行服务的暴露
- `doExportURLs`执行服务暴露
    - 加载注册中心的信息
    - 遍历要暴露的协议和端口（即Protocol标签可能有很多个）
    - 代理工厂ProxyFactory将调用接口的实现对象和URL地址包装成了执行器invoker
    - 封装成暴露器
    - dubbo的暴露器会开启服务器，注册中心的暴露器会将服务注册到注册中心

###### 6、dubbo服务引用流程

###### 7、dubbo服务调用流程