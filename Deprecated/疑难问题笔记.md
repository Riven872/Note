### 1、withCredentials 问题

1. 是一个 `XMLHttpRequest（XHR）` 属性，也就是一个发送 HTTP 请求的其中一个属性
2. 作用是允许该请求在跨域时，会携带身份凭据（比如 Cookie 和授权的 header）。
3. 只设置 `withCredentials = true` 不够，还需要在服务端（后端）处理允许跨域时，同时允许跨域请求中发送 Cookie 等凭据信息，即 `Access-Control-Allow-Credentials = true`，这样才能让浏览器在允许跨域时接受跨域请求中的 Cookie



### 2、使用 Cookie 和 Session 保存用户登录态

1. Cookie 保存在客户端，Session 保存在服务端。
2. Session 用于保存用户的登录状态和其他信息，而 Cookie 用于在客户端保存 Session ID。通过这种方式，客户端和服务端可以共同维护用户的登录状态，并实现登录状态的跨页面、跨请求等特性。
3. 用户登录成功：
    1. 服务端创建一个新的 Session 对象，并保存用户的信息（后端开发可以自行设置）
    2. **服务端进行响应时，发送一个 Set-Cookie 的响应头，设置 Cookie 中的值（一般是设置为 Session ID），并通过其中的值找到对应的 Session，如果可以找到对应的 Session 就意味着认证登录成功**
    3. 在后续的请求中，客户端会将该 Cookie 一起发送到服务器端，以便服务器端能够识别用户的 Session，保持该用户的登录态
    4. 需要注意的是，Set-Cookie 响应头并不是必须的，只有在需要设置 Cookie 时才需要在响应头中添加该头部信息。
4. 用户登录失败：
    1. 登录验证失败，服务端就不会创建新的 Session 对象
    2. 响应头中也不会包含任何 Cookie，因为没有新的 Session 被创建
5. 总的来说，就是认证时成功时，服务端返回一些信息，让 Cookie 去保存，目的在于通过 Cookie 中的值找到对应的 Session，表示该用户认证成功，否则服务端不会返回信息，也不会设置 Cookie。
6. **`HttpServletRequest.getSession()` 会自动添加 Set-Cookie 响应头**
    1. 如果当前的请求没有 session，而且 `getSession()` 方法是在请求处理期间第一次调用的，则会自动创建一个新的 session，并将其与当前请求相关联，同时将 session ID 写入 Set-Cookie 响应头中发送给客户端。
    2. 如果当前的请求已经与一个 session 相关联，并且在请求处理期间调用了 `getSession(true)`，则会将当前 session 的 ID 写入 Set-Cookie 响应头中发送给客户端，即使在调用 `getSession(true)` 之前没有向该 session 添加任何属性。
    3. 因此在使用 `getSession().setAttribute()` 时，实质上已经自动发送了 Set-Cookie 响应头，并建立了服务端和客户端的会话。



### 3、利用堆排序取 TOP k

1. 核心思想：利用小顶堆，每次把最小的筛选出去，留下的就是 top（同理，可以利用大顶堆找海量数据中最小的几个）
2. 大顶堆的节点总是大于所有子节点的值，小顶堆相反
3. 初始时，将前 k 个数字构建成小顶堆
4. 遍历剩余的数字，如果遍历到的数字比小顶堆中最小的数字还要大（即与根结点进行比较，目的是将小的筛出去），就将根结点移出，放入新的数字
5. 进行重建堆，重建之后新的最小的数字又会成为根结点
6. 循环操作 3，会将所有的比较小的数字挨个筛选出去
7. 最终堆成型时，堆内只会留下最大的 k 个数字



### 4、MySQL 中 Limit 关键字存在的问题

1. `LIMIT` 子句在处理大量数据时可能会导致一些问题，特别是当偏移量非常大的时候，比如 `LIMIT 1000000, 10`， `LIMIT` 子句会强制 MySQL 执行全表扫描，然后返回相应的行数。这意味着，如果结果集有100万行，需要返回第100万行之后的10行，MySQL 仍然需要扫描整个结果集，并将前100万行丢弃掉，然后返回接下来的10行。这个过程需要占用大量的 CPU 和内存资源，导致性能问题。
2. 采用索引优化，如覆盖索引，以减少扫描行的数量，提高查询速度。
3. 采用分页思想，具体的优化思路是，通过记录上一次查询的结果，来避免对整个结果集进行扫描和排序。一般来说，可以通过记录上一次查询的最后一条记录的 ID 或者主键值，来实现分页查询。
    1. 总的来说，就是将上次的查询记录当做偏移量，而不是使用 Limit 中的 Offset 自己指定
    2. 每次查询只需要扫描上一次查询后的记录，可以大大降低查询的时间复杂度。
