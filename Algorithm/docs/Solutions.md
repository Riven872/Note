​	

[TOC]

# 数组 Arrays（15）



## 二分查找（5）

> **适用条件：查找元素，且该数组中元素有序、无重复元素，注意区间的开闭**
>
> **时间复杂度 O(n)**
>
> **空间复杂度 O(1)**
>
> **二刷笔记：结束位置一定是 low > high，但要清楚是因为 low 指针右移跳出循环还是因为 high 指针左移跳出了循环**



### E704. 二分查找

1. 适用条件：元素有序、无重复元素、且注意区间的开闭
2. 如果是左闭右闭区间，如 [a, b] 的情况，那么循环条件是 `while(low <= high)`，如果区间换为 [a, b)，相应的循环条件需要更换为 `while(low < high)`，因为在右闭的情况下，low 永远不等于 high，而且如果 `nums[mid] > target` 时，`high = mid`，而非 `high = mid + 1`。
3. 计算中间索引下标时，防止溢出问题。如果 low 与 high 相加大于 MAX_INT 时，会发生溢出。因此可以使用 `mid = low + ((high - low) / 2)` 去解决，几何上的意义就是先计算 low 与 high 距离之间的中间值，然后再加上 0 到 low 的距离即可。



### E35. 搜索插入位置

1. 采用二分法如果没有找到元素时，low 指针指向的就是该元素应该要插入位置的下标。
1. 因为 / 2 采用的是向下取整，因此最后一次循环前，low 与 high 指向同一个元素，且该元素一定比目标值要小（或者相等），最后一轮循环后 low = mid + 1，且 low > high 跳出循环，因此 low 最后停留的位置就是目标值应该在的位置。



### M34. 在排序数组中查找元素的第一个和最后一个位置

1. 二分查找的目的在于找到有序数组中指定元素的下标，那么也可以找到指定元素的前一位或者后一位
2. 因此找左右边界就是找最左侧 target 的前一位下标位置和最右侧 target 的后一位下标位置，在返回时左侧边界 + 1，右侧边界 - 1 即为 target 的第一个出现位置和最后一个出现位置
3. 因此在找左边界时，只要 `target <= nums[mid]` 时，`high = mid - 1`，记录此时 high 的值，如果 `high == target` 则会进入下一轮循环，否则就是 target 第一次出现位置的左边的元素。找右边界时同理。
4. 注意一种特殊情况，就是 target 不在数组中时，此时得出的右边界值 - 左边界值是负数。
5. 二刷笔记：找左边界时，只要 mid 大于或等于 target，就要重新划定边界，直到找不到 mid 与 target 相等的值，就是找到了左边界。（二分查找的思路是只要 mid 大于 target 时，才会重新划定边界）
6. 以左边界为例，最后一次循环时，low 与 high 与 mid 同时指向 target 前一位，循环结束后，high 指针会停留在前一位，而 low 指针会移到后一位去（对应上题，low 指针会指向该元素应该插入的位置）
7. 找左边界时，因为 high 指针左移跳出循环。找右边界时，因为 right 指针右移跳出循环。
8. 三刷笔记：正常二分算法中，如果 target == mid，会直接返回，在找开始索引时，遇到相等的情况会根据找左右边界而移动 low 或 high，区别仅此而已，不难。当循环结束时一定是 low > high，再根据找左右边界的不同进行结果的 + 1、- 1 即可。



### E69. x 的平方根

1. 求某个数的平方根，其解的范围一定是在 `[1, target]` 之中的。因此符合二分查找的元素有序且不重复
2. 当不满足循环条件时，low 和 high 已经互换了位置，因此向下取整的话返回的是 high 的值。
3. 注意第一种特殊情况，如果 target 值接近 MAX_INT，判断时就不能用 mid * mid 与 target 比较，会溢出 int 值，因此需要 mid 与 target / mid 做比较。
4. 注意第二种特殊情况，如果 target 是 0，需要单独处理，以免发生被 0 除的异常
5. 二刷笔记：关键就在于循环结束时，一定（因为是向下取整）是 high 指针左移结束了循环，且左指针位置就是解
6. 三刷笔记：同二刷笔记，向下取整则向前取值，向上取整则向后取值，理解结束循环时的指针位置。



### E367. 有效的完全平方数

1. 思路同上题
2. 因为 int 型的除法是向下取整的，当满足 `mid == num / mid` 时，需要进行 break，将 mid 值进行平方验证（如 mid 为 2，num 为 5 时，`mid == num / mid` 是成立的，但 5 并不是完全平方数，因此需要进行验证）
3. 注意 0 时的特殊情况
4. 三刷笔记：与上题类似，多了一步验证，两题别混淆了。



## 双指针法（5）

> **适用条件：移动或移除数组的元素**
>
> **两个指针从相同的位置出发，可以通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### E27. 移除元素

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，并找到与 target 值相等的元素，慢指针指向的位置用来接收前移的元素，目的是将 target 值覆盖掉。
3. 当快指针指向的元素与 target 相等时，只有快指针后移。当快指针指向的元素与 target 不相等时，慢指针接收快指针的元素，然后慢指针后移。
4. 注意：发生交换后慢指针后后移一位，因此直接返回慢指针就是新数组的长度，不需要再额外 + 1 补足。
5. 二刷笔记：一开始快慢指针是指向头元素的，如果快指针不等于 target 时，快慢指针元素会互换，只不过指向元素是同一个互换没什么区别，只有快指针等于 target 时，快指针才会自己后移。
6. 三刷笔记：快指针的目的在于找出不等于 target 的值并复制到慢指针所指向的位置，慢指针指向的位置是正确的接收位置。



### E26. 删除有序数组中的重复项

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到与慢指针指向元素值不同的元素，因为需要保留唯一的元素，因此慢指针的下一位用来接收前移的元素。
3. 当快指针的元素与慢指针元素相同时，只有快指针后移。当快指针元素与慢指针元素相同时，慢指针后移一位，然后再接收快指针元素。
4. 注意：慢指针是先后移再接收元素，因此返回值需要 + 1 才是新数组的长度
5. 三刷笔记：跟上题类似，比较的是慢指针的值，如果不同，需要慢指针后移一位再复制快指针的元素。



### E283. 移动零

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到不等于 0 的元素。慢指针用来接收非 0 元素。
3. 当快指针指向的元素为 0 时，只有快指针后移。当快指针元素不为 0 时，慢指针接收元素，然后再后移。
4. 思想与 E27 移除元素一毛一样，只不过 target 定死为了 0。
5. 二刷笔记：因为条件是移动而不是移除，因此不能直接移动索引覆盖，而是定义 temp 进行元素的交换。
6. 三刷笔记：因为要求不改变元素顺序，感觉有种冒泡的思想，把 0 不断交换到后面去。同样快指针是遍历元素，慢指针指向位置是接收元素的位置，因此接收完之后需要后移一位。



### E844. 比较含退格的字符串

1. 空间复杂度 1，时间复杂度 n。
2. 使用双指针法分别处理两个字符串，然后再用 `equals()` 去对比
3. 快指针用来遍历整个数组，找到不等于 \# 的元素。慢指针用来接收非 \# 元素。
4. 当快指针为 \# 时，快指针后移一位，慢指针前移一位，相当于退格操作。当快指针不为 \# 时，慢指针接收快指针元素，然后再后移一位。
5. 注意：当慢指针的值为 0 时，就不需要再前移了，否则会发生负越界的情况。
6. 二刷笔记：注意 if 与 else-if 的配合。用 else 时，一定一定一定要看好反转的条件。
7. 三刷笔记：char 数组长度是 final 不可变的，因此需要重新 substring 字符串比较。



### E977. 有序数组的平方

1. 空间复杂度 n，时间复杂度 n。
2. 实际两个指针的作用相同，不算严格意义上的双指针题目。
3. 需要建立新的数组，并逆向添加数据。
4. 条件是递增数组，且数组内有负数和正数，因此头指针可以指向头元素，尾指针指向尾元素。然后头尾元素进行绝对值比较，值比较大的放入新数组的尾部。
5. 也可以处理原始数组，将数组内的所有元素进行平方，但是性能较低，建议还是比较绝对值。
6. 三刷笔记：两个指针一个从头开始一个从尾开始，二者绝对值比较之后相当于降序遍历，因此建立一个数组从尾开始添加数据。而且新数组与旧数组容量一致，完全可以建立数组不用 List 集合去处理。



## 滑动窗口（3）

> **本质上也是一种双指针法，慢指针代表滑动窗口的起始位置，快指针代表滑动窗口的结束位置，不断调节子序列的起始终止位置，达到想要的条件**
>
> **利用了双指针法最核心的思想：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### M209. 长度最小的子数组

1. 空间复杂度 1，时间复杂度 n。
2. 先理解题目：要求的是大于等于 target 即可，不是要最接近。而且要求只返回距离值，不用返回确切的下标。因此只需要每次迭代最短距离，最后返回即可。所以类似一个滑动的窗口将符合要求的值框起来。
3. 快指针代表滑动窗口的终止位置，每次移动时计算滑动窗口内值的总和，当总和大于等于 target 时，迭代滑动窗口的长度，慢指针代表滑动窗口的起始位置，此时向后移一位，并且总和需要减去慢指针原先指向元素的值。
4. 注意：最后需要判断如果最短距离没有赋值，那么直接返回 0 即可。
5. 二刷笔记：当总和 sum >= target 时，需要循环的去移动慢指针，目的是不断的迭代最小长度，直至不满足循环条件，此时快指针会自动后移（即迭代完毕后，快指针会后移而非停止不动，会在 for 循环中自动后移，因此不用单独考虑）。
6. 三刷笔记：当总和 sum >= target 时，需要循环的滑出元素。只要在遍历就可以滑进元素，也可以在 sum >= target 只滑出元素不滑进元素，两种思想都可以，二者只有细小的差别，但是建议使用只要在遍历就可以滑进元素。



### M904. 水果成篮

1. 空间复杂度 n，时间复杂度 n。
2. 慢指针代表第一种水果的起始位置，快指针代表第二种水果的结束位置，因此快指针 - 慢指针 + 1 就是滑动窗口的长度，也就是两种水果所占的长度。（即求最长子序列）。
3. 可以用 `HashMap` 结构存储 `<水果种类, 该水果种类连续的个数>`。快指针进行遍历整个数组，当水果种类不大于 2 时，根据快指针元素进行填装 `HashMap`，当水果种类大于 2（即 `HashMap` 的 size > 2 时），慢指针根据 `HashMap` 中该水果种类的连续个数进行**连续后移**，连续后移完毕后，该水果种类连续的个数的值会变为 0，这时删除 `HashMap` 中该水果的种类。
4. 每当一种水果种类移除之后（也即慢指针连续后移至新种类水果的索引位置），进行滑动窗口长度的迭代。
5. 二刷笔记：当水果种类不大于 2 时，就要进行长度的迭代（也顺手解决了水果只有一种的情况），此时慢指针还未移动，而快指针正好指向第二个水果的结束位置。一旦快指针指向了第三种水果，也就意味着开始往 `HashMap` 里添加水果种类了。也表明了最长子序列的长度是慢慢增加至峰值，而不是一次性计算就得出来的。
6. 三刷笔记：同样的，因为 `HashMap` 容量大于 2 时需要循环后移慢指针，因此只要在遍历就往 `HashMap` 中添加元素。当某个 value 小于 1 时，及时从 `HashMap` 中 remove 掉该 key。



### H76. 最小覆盖子串

1. 空间复杂度 `t.length` ，时间复杂度 `t.length + s.length`。
2. 首先遍历子串，用 `HashMap` 结构存储 `<子串中的字符, 该字符目前的需求量>`。
3. 快指针代表滑动窗口的结束位置，慢指针代表滑动窗口的起始位置，滑动窗口内的子串就是最佳匹配的子串。
4. 快指针遍历字符串，当遇到子串内某个元素时，该元素的需求量就减一（只有当该元素需求量大于 0 减一时，总需求量才减一，否则只是表明需求缺口过多，总需求量已经减过一了）。直到窗口完全包含子串时（即总需求量为 0 时），进行最佳子串的迭代，迭代完成后判断慢指针是否为子串内的某个元素，如果是则该元素的需求量就加一（只有当该元素需求量大于等于 0 加一时，总需求量才加一，否则表明需求盈余过多，总需求量已经加过一了），然后慢指针右移一位。
5. 快指针还代表滑动窗口的右端新增一个字符，这时候需要判断该字符是否是所需要的，如果是需要的继续判断是否需求量 > 0，进而决定总需求量是否发生变化。
6. 同理，慢指针也代表滑动窗口左端滑出一个字符，这时候需要判断该字符是否是所需要的，如果是所需要的继续判断是否需求量 >= 0，进而决定总需求量是否发生变化。
7. 二刷笔记：记住 `HashMap` 中正数代表缺，负数代表不缺，因此需要判断在对正数操作时，才会对 need 总需求操作。而且一定要先判断是否要操作总需求量，然后再进行字符目前需求的加减，顺序反了会影响判断（千万别反了！！！）。迭代新子序列时，判断要么为空串要么比上个串的长度小即可，迭代完之后开始移动慢指针。总结就一句话：滑动窗口新增移除（滑进滑出）元素时，先看自身需求量从而决定是否操作总需求量，然后再新增移除（滑进滑出）。
8. 三刷笔记：滑进滑出元素时的操作几乎一样，但当滑出元素时，此元素的需求量为 0 也需要考虑在内。先判断该元素的存量，再决定总需求量是否变化。



## 螺旋矩阵（2）

> **模拟螺旋矩阵的顺时针的生成过程，不涉及算法。**
>
> **关键在于边界值的寻找。**



### M59. 螺旋矩阵 II

1. 空间复杂度 1，时间复杂度 n²。
2. 采用主流思想，左闭右开区间，即假如生成 5 阶矩阵，以第一圈为例，最上侧从左到右连续生成 4 个元素 [0, 5)，接下来的右侧从上到下连续生成也是 4 个元素。到了第二圈时，变成连续生成 2 个元素。
3. 循环的圈数一定是 n / 2，因为一圈过后，左右、上下同时少了两个元素，因此行或列的一半即可完成循环。
4. 因为是二维矩阵，因此从左到右和从右到左生成元素时，行不变，列进行变化。反之。
5. 可以把二维数组想成两条数轴（一条水平，一条垂直），start 的目的是第 1 圈时，起始位置为 0。一圈过后，只从水平或垂直的角度来看，只是 start 后移了一位而已（因为生成元素时，必定有一维是固定的，因此观感上可以这么看）。
6. 注意特殊情况，如果是奇数矩阵，那么中间的元素需要额外手动填充（循环结束后可以直接拿到行和列的索引以及需要填充的值，直接代入即可）。
7. 二刷笔记：也可以通过 offset 变量来控制，每次循环完一圈后，下次生成元素要减少的偏移量
8. 三刷笔记：start 作用在于每次循环开始时，给定的一个标准，然后 i j 根据每一圈的标准开始生成矩阵。



### M54. 螺旋矩阵

1. 空间复杂度 1，时间复杂度 m * n。
2. 比上题要难，思路相同。新增了一些变量用来理解题目，也可以优化成上题（为了便于理解还是保留了）。因为 loop 是减法迭代，所以新增 offset 表示圈数也正好表示偏移量。mid 用来记录循环次数且不会迭代，用来处理特殊情况。start 仍然表示该次循环从哪个索引下标开始，同时 offset 用来指示循环边界值。
3. 循环的圈数为行或列中最小值的一半。
4. 特殊情况一：单行单列时，loop 为 0，直接打印单行或单列的元素即可。（单行单列也满足行或列最小值为奇数）
5. 特殊情况二：行或列最小值有奇数时，根据 mid（也就是没经过迭代的 loop）去打印上述循环中没有打印的值。保证了即使经过了上面的循环，也因为 mid 值的存在不会打印重复的值。
6. 二刷笔记：主要还是处理特殊情况部分，利用好 start 与 mid 值。start 只需要一个原因是，该 start 点只是用来标记左上角开始的位置，只要确定了开始的位置，每次迭代都是采用左闭右开的区间，因此不必再考虑其他的定位点。循环完一圈后，start 会成为新一轮的定位点，因此只要左上角开始的定位点即可。
7. 三刷笔记：单行或单列跟特殊情况是一致的，都是只剩下某一行或某一列没有打印，区别就是最小奇数行列需要一个标志位来避免打印已经循环的位置，就是 mid（循环次数），减去循环次数即可。



# 链表 Linkedlists（7）

> **处理结点之间的关系，如新增、删除等，常与双指针法结合考察**



## 标准题型（7）

> **无分类题型**



### E203.移除链表元素

1. 空间复杂度 1，时间复杂度 n。
2. 通常建立一个哨兵节点，放置在首节点之前方便遍历。然后再建立一个 pre 节点，用来保留前驱地址。
3. 思想类似于双指针法，遍历指针进行遍历时，若不移除遍历指针节点，那么 pre 节点后移指向遍历节点，然后遍历节点才后移，指向下一个节点。如果移除遍历指针节点，遍历节点后移一位，pre 节点指向新的遍历节点即可。
4. 只有当遍历节点为 null 时，才会停止遍历，而不是遍历节点的 next 为 null 时停止。
5. 二刷笔记：如果发生了移除结点的操作，那么 preNode 结点不会后移。



### M707.设计链表

1. 只实现了单链表结构（了解思想之后一定要实操一下，无难度）
2. 单链表中有两个属性：链表长度，哨兵节点（指向下一个节点），通过构造函数初始化链表
3. 链表方法：
    1. 获取指定索引节点的值。
    2. 在链表头部添加节点。
    3. 在链表尾部添加节点。
    4. 在指定的索引位置添加节点。
    5. 删除指定索引的节点。
4. 二刷笔记：还是要注意边界值，哨兵结点索引算 -1，头结点的索引才算是 0。
5. 三刷笔记：因为哨兵结点是手动加的，因此不算真正的计数结点，索引算 -1。记住一个原则，每次循环结束后，currentNode 指向的就是 index 所在的结点，这样不管是新增还是删除都会更明确。



### E206. 反转链表

1. 使用头插法的话，需要考虑哨兵节点以及最后的返回值，因此直接采用双指针法，真正的**原地**反转。
2. 初始状态：current 指针指向 head 节点，pre 指针指向 current 的前驱节点，那么相应的开始时，**pre 指向 null**（因为最后反转完成后，原先的头指针的 next 指向的是 null）。
3. 终止状态：current 指向 null 不满足循环条件，此时 pre 节点指向新的头结点（无哨兵节点）。
4. 每次反转前，先用 temp 保存 current 的下一节点地址，然后进行正常的节点置换即可。
5. 核心思想就是先保存第三个节点的地址，将前两个节点与后面的节点“剥离”开，然后进行置换、指针的后移等。
6. 三刷笔记：
    1. 因为结束条件是 current 指向 null，因此最后正确的头指针应该是 pre 结点。
    2. 原地反转时会影响三个结点，因此需要三个指针标记。




### M24.两两交换链表中的节点

1. 需要建立哨兵节点，以方便交换时有前驱节点的地址。
2. firstNode：交换的第一个节点，secondNode：交换的第二个节点，temp：交换的两个节点后的一个节点，currentNode：遍历节点，初始时指向哨兵节点。
3. 定义好存放临时节点的变量后，进行节点的置换即可。
4. **置换完毕后，currentNode 遍历节点会指向 firstNode 节点的位置。（因为已经完成了置换，因此 firstNode 节点在位置上是第二个节点，作为下一次交换的前驱节点）。**
5. 注意：返回值应该是哨兵节点的后继节点，而不是给定的 head 节点，因为 head 节点初始就与第二个节点交换了，这也是使用哨兵节点的目的之一，保留初始地址。
6. 二刷笔记：不同于上题，该题需要保存四个结点的地址，上题因为是单个结点反转，不是两个结点置换，因此不需要保存额外的结点地址。
7. 三刷笔记：
    1. 错误点还是在于 head 结点已经更换了位置，因此需要提前用哨兵结点保留开头的地址。
    2. 因为会影响四个结点，所以需要四个指针标记。




### M19. 删除链表的倒数第 N 个结点

1. 也可以采用删除正向为第 size - n + 1 个节点的思想，但是下面的解法也结合了这个思想，而且更巧妙。而且双指针法正是解决了两个循环需要做的事。
2. 使用双指针法。快指针首先移动 n 个节点（也是从哨兵节点开始），然后慢指针从 0 开始（因此需要建立哨兵指针），两个指针同时后移，当快指针到达尾部时（最后一个节点，而不是 null 处），慢指针正好停留在指定的倒数第 n -1 的位置上。
3. 原理：可以继续利用距离来理解，慢指针相当于走了 size - n 的距离，符合正向的思想。快指针首先走了 n 个之后，慢指针才同步移动，而且快指针在 size 时结束，即 size - n。
4. **还是要注意边界值！！！！**
5. 注意：
    1. 循环结束的条件为快指针的 next 不为 null，这样正好解决了特殊情况。
    2. 最后删除节点时，只有慢指针操作，快指针只用来遍历。`slowIndex.next = slowIndex.next.next;`
6. 二刷笔记：不用计算该链表的长度，快结点剩余走的路程 size - n，就是慢结点要走的路程，已经用快结点提前铺好路了。
7. 三刷笔记：快结点需要先走一段距离，然后两个结点同步走即可。



### E160. 相交链表

1. 如果两条链表长度相同，那么依次比较即可。因此核心思想是处理两条链表遍历的长度相同。而且相交的部分是在后面，因此长链表的前部分节点是冗余的，先行遍历掉。
2. 首先遍历出两条链表的长度，得到两条链表的 gap，长链表先遍历 gap 的部分，进行两条链表的对齐。
3. 对齐之后两条链表的节点一一比对即可。
4. 注意：比对的是节点本身，而不是节点存储的数据。
5. 关于 A 与 B 链表的长度对比之后遍历冗余节点有优化方法。（可以看看解析）
6. 二刷笔记：根据两条链表的长度可以灵活更改头指针，可以只写一次遍历即可，思想没变化。
7. 三刷笔记：加不加哨兵结点没有影响。



### M142. 环形链表 II

1. **链表典型题：判定链表内是否有环且找到环的入口**
2. 采用双指针法，慢指针每次移动 1 个节点，快指针每次移动 2 个节点，如果链表有环，那么两个指针一定会在环中相遇。
3. 假定从头结点到环形入口结点之间的结点数为 x，从环形入口结点到相遇结点之间的结点数为 y，从相遇结点到环形入口结点之间的结点数为 z，在环内走了 n 圈两个指针才相遇。
4. 得出 x + y = x + y + (z + y) * n。左边为慢指针走的结点数，右边为快指针走的结点数。因为快指针的速度是大于慢指针的，因此是 x + y 之后才开始在圈内循环。整理之后为：x = (n - 1) (y + z) + z。（求 x 就是环形入口的索引）
5. 从公式可以看出，当 n 为 1 时，x = z，根据假设的定义，相当于**从头结点到环形入口结点之间的结点数 = 从相遇点到环形入口之间的结点数**，因此 n 为 1 时，仅仅是快指针在环内走了一圈，n 大于 1 时多走了几圈而已。
6. 最终，定义一个指针从头结点出发一步步走，定义一个指针从相遇点出发一步步走，二者再次相遇时，就是环形的入口。
7. 思路：
    1. 首先确定是否有环。
    2. 有环时，找到相遇的点。
    3. 从相遇的点出发，每次都只移动一个结点，相遇时就是环形入口。
8. 二刷笔记：该题不能建立哨兵结点，会超时，没懂为啥TnT。
9. 三刷笔记：
    1. 不能以 `slowNode == fastNode` 作为循环条件，会超时。
    2. 应该在循环内判断只要两个指针重合就进行找入口的操作。


# 哈希表 HashTables（11）

> **哈希法使用空间换时间，适用于快速判断一个元素是否出现在集合中，搜索量级为 O(1)**
>
> **主要方法会手写哈希数据结构，进行数据与索引的映射**



## 字母异位词（4）

> **该题型隐性的规则就是，字母及其个数相同的词，不管词中字母顺序如何，哈希值是相同的。**
>
> **题目中说明了只有小写字母，因此可以采用简单数组作为哈希容器，大小为 26，数组中的值为字母出现的次数，适用于低时间复杂度。**
>
> **也可以采用标准的 HashMap，因为每个异位词排序后的词是相同的，因此可以将串转换为 char 数组排序后作为 key，value 作为相同哈希值共同的桶，适用于低空间复杂度。**
>
> **注意：如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费！**



### E242. 有效的字母异位词

1. 使用数组当做简单的哈希表。数组下标为元素映射的索引，数组内存的数据为该元素的映射次数。
2. 因为是小写字母比较，因此建立长度为 26 的数组，映射关系为 "元素 char 值取模 26"。不必使元素 a 一定处于下标 0 的位置，只需要一个相对的位置即可，查询时会通过映射关系找到对应的下标，再通过下标找到数组内的数值，即可表示出当前元素出现的次数。
3. 将第一个字符串放入数组后，另一个字符串通过相同的映射关系，每有一个元素映射，数组值就减一。当所有元素映射完毕后，再遍历哈希数组，如果数组内的所有值都为 0，说明二者包含的元素个数和种类是相同的。
4. 此类型的题目给出了条件：字符串只有小写英文字母，因此建立的哈希表大小为 26。



### E383. 赎金信

1. 思路与上题完全一致，但是可以优化一下步骤（可以不用所有元素映射完之后再去遍历，可以映射一个就判断一下是否为负数）。



### M49. 字母异位词分组

1. 思路相同，但是容器采用标准库的 HashMap。
2. 题目要求含字母相同的词作为统一映射，因此得出映射关系，只要含有相同的词且个数相同即可，顺序忽略，故可以将候选词汇转换成 char 数组之后排序，这样有相同字母的词就会有相同的哈希值。
3. 关键还是找映射关系（即找相同点，有相同点的词放入一个 “桶” 中，也即哈希值相同），哈希容器采用标准库。
4. 也可以采用数组建立简单的哈希容器，建立容器思想也相通。
5. 三刷笔记：字符串排序之后就是 HashMap 中的 key 。



### M438. 找到字符串中所有字母异位词

1. 滑动窗口 + 哈希表，依然是对比两串的哈希值是否相同。
2. 首先将标准串中的字母及其个数放入一个自定义的 26 大小的哈希数组中。
3. 然后建立一个子串数组用来对比标准数据。快指针每次遍历，都会滑进元素，因此需要增加新元素的个数，每次新增完毕后，对比两个哈希数组是否相同，如果相同则记录慢指针的位置就是子串的起始索引。
4. 标准串是给定的，因此滑动窗口的大小也是固定的，当窗口大小不符合要求时，才会移动慢指针，此时会滑出元素，因此需要减少滑出元素的个数。
5. 注意：不建议使用上题的通过排序来找到相同哈希值的方法，因为库函数的排序在大数据量下会超时，而手动建立简单哈希数组会牺牲空间换时间。
6. 二刷笔记：快指针遍历时用的是 for 循环，因此可以先判断是否滑动窗口过长移动慢指针然后再比较两个数组，也可以先假定快指针移动后是否大于滑动窗口大小。注意滑动窗口大小的计算。也会用到对比两个数组的库函数  `Arrays.equals()`
7. 三刷笔记：遗忘点还是在于要使用 `Arrays.equals()`，如果采用字符串排序的话选哈希槽的话，会超时。



## 两个数组的交集（2）

> **HashSet 有其元素唯一的性质，因此可以采用标准的 HashSet 来完成找出交集元素且返回值唯一的操作。**
>
> **简单哈希数组效率依然高于 HashSet，但是仅限于哈希值比较少的情况。**



### E349. 两个数组的交集

1. 本题使用标准的 `HashSet` 解决，因为题目修正限制 1000 个元素（哈希值较少），所以也可以建立大小为 1000 的哈希数组，采用数组解决。
2. 使用 `HashSet` 存放 A 数组的值，然后遍历 B 数组，只要 `HashSet` 中也包含 B 数组中的元素，就往返回值 `HashSet` 中添加该元素即可。
3. 因为 `HashSet` 本身的性质，因此返回值 `HashSet` 中的值也是唯一的。
4. 二刷笔记：第一次用 `HashSet` 用来筛选出标准数组中唯一的元素，第二次用 `HashSet` 的 contains 时，使对比数组中相同的元素，加入返回 `HashSet` 中。不能用 `!add()` 去判断。



### E350. 两个数组的交集 II

1. 可以使用 `HashMap` 或者简单数组作为哈希容器，本次解决使用 `HashMap`。
2. 首先使用 `HashMap` 存储数组 A 内的数字及其出现的频次。然后遍历数组 B，若数组  B 的元素也为 key 且频次大于 0，就将该元素放入返回值列表中，并将频次减一。
3. **频次减一是为了返回出现次数较少的频次**
4. 也可以将两个数组排序，然后使用双指针法。
5. 二刷笔记：`HashMap` 中首次放入标准数组频次，当遍历对比数组时，如果有相同的 key 则会消耗频次，如果对比数组频次消耗至 0 则说明标准数组的频次是最低的，如果还未消耗至 0 则会因为标准数组的频次先消耗完毕无法添加返回值。
6. 三刷笔记：
    1. 遇到相同的元素，放一次减一次即可，大于 0 的数量就是在二者出现中较少的一次。
    2. 核心是找一个元素是否在另一个数组中也出现过，而且要求统计出现次数，因此还是 `HashMap` 的问题，与 HashSet 关系不大。




## 标准题型（5）



### E202. 快乐数

1. 根据规律，**一个数如果不是快乐数，那么在有限次的循环后，会变成原先的值**，因此适用哈希法的特性，快速判断一个元素是否在集合中出现过。
2. **另一个难点是求每一位的平方值**。需要单独写一个方法，用来计算每一位平方值的和，然后加入到 `HashSet` 中。
3. 当某一次循环后的和为 1 或在 `HashSet` 中出现过时，跳出循环，进而判断 n 是否为 1，从而确定是否为快乐数。
4. 二刷笔记：不需要考虑 n 为 1 的情况，不是特殊情况。



### E1. 两数之和

1. 假设 A  = target - B，因此相当于快速判断 A 元素在集合中出现的位置，适用于哈希表去解决。
2. `HashMap` 的 key 用来存放元素值，value 用来存放该值的索引。元素值可能会相同，但相同时意味着一定二者相加为 target，此时已经返回了结果，而不会向 `HashMap` 中继续添加元素，因此不用担心**重复添加 key 相同的情况**。
3. 遍历数组时往 `HashMap` 中添加数据，同时判断另一个整数是否在 `HashMap` 中，如果在则可以直接返回二者的索引，否则就将该元素添加到 `HashMap` 中。
4. `HashMap` 初始时元素较少不太会匹配到另一个整数，当数据多起来时，自然会找到前面放入 `HashMap` 的元素进行匹配。



### M454. 四数相加 II

1. 时间复杂度: O(n^2)，空间复杂度: O(n^2)。
2. 数组 A、B 看作一个大数组，数组 C、D 看作一个大数组，进而简化成类似两数之和的思想（A + B + C + D = 0，也就是 sum ）。
3. 首先用双循环将 A、B 数组内的值相加并放入 `HashMap` 中，key 为两数之和 sum，value 为该和出现的次数。
4. 然后再用双循环遍历 C、D 数组，取 - sum 为 key，取 `HashMap` 中的 value，value 的次数，就是符合要求的四元组的个数。
5. 注意：不需要为 A、B 两个大数组和 C、D 两个大数组都建立 `HashMap`，只需要用一个 `HashMap` 存放 A、B 大数组的记录即可，C、D 大数组中的值可以一边遍历一边比对。
6. 二刷笔记：vlaue 的值就是匹配的数量，累加即可，不需要再减次数。
7. 三刷笔记：因为比较的是四个数组而且是无序的，因此无法用剪枝捡掉多余的循环。



### M15. 三数之和

1. 时间复杂度: O(n^2)，空间复杂度: 1（如果使用哈希法会增加空间复杂度用于去重）。
2. 不同于上题中，是四个独立的数组中去找四元组，该题只有一个数组，使用双循环哈希判断元组存在并不难，但是无法进行去重处理，因此使用双循环双指针解决该题。
3. 相应的，用双指针法时，先要将数组排序，而且题目要求的是返回数组内的数值而非索引值，这也是可以用双指针法的一个原因。
4. 分为三个指针，外循环遍历指针 i，从 0 开始，慢指针从 0 开始，快指针从数组尾部开始，相当于固定 i 然后找合适的快慢指针的元素。
5. 重要的操作是去重（去重时不用三个元素都取出来之后去重，而是自己与自己比较）：
    1. 去重 i，对比 i 是否与左边的一个元素相同，如果相同则直接开始下一轮循环。
    2. 去重慢指针，慢指针与右边的元素相同时，右移慢指针。
    3. 去重快指针，快指针与左边的元素相同时，左移快指针。
6. 内循环条件是慢指针与指针没有相遇，也达成了三个指针索引不同的条件。当三者之和不为 0 时，视情况移动快慢指针即可。
7. 注：该题也是体现了双指针的优势，将暴力的立方级复杂度降低为平方级。
8. 二刷笔记：注意什么时候需要同时移动快慢指针和各自移动指针。
9. 三刷笔记：
    1. 慢指针从遍历指针的后一位、快指针从尾开始移动可以提高循环效率。
    2. 总和大于 0 时，移动快指针。总和小于 0 时移动慢指针。
    3. 总和为 0 时符合条件，记录坐标，然后在去重双指针的之后移动双指针。




### M18. 四数之和 :star:

1. 时间复杂度: O(n^3)，空间复杂度: 1
2. 思路与上题一样，因为是四个数求和，因此需要在外面再套一层循环。
3. 一级剪枝部分：当首位大于 0 且尾部元素大于 target 时，进行剪枝。二级剪枝部分：两个循环固定的元素相加时大于 target，则没必要再继续进行。
4. 注意：二次循环的初始循环指针，从一层循环的循环指针 +1 开始。并在去重时，避免与一层循环的循环指针重复，从而造成不必要的去重。
5. 利用双指针的优势，将四次方级复杂度降低为了立方级。
6. 二刷笔记：二级去重时，注意不要把一级的也给去了，注意去重的边界值，比一级多一位即可。同样在二级剪枝时，需要同时满足 `nums[i] + nums[j] > target && nums[i] + nums[j] > 0` 时要 break，而非直接 return（原因是还有快慢指针没有进行计算，且快指针是可以在循环变量的左边，而慢指针只能在循环指针的右边，因此该结果并不能直接否定全盘，只是本次不符合条件，因此要用 break，而上题中剪枝是全盘肯定的，因此可以直接 return）。
7. 三刷笔记：
    1. 只要不是最外层循环，去重时要进行 break 而非直接 return。
    2. 因为 target 是不定的，因此剪枝时需要判断是否已经大于 0，然后才大于 target。否则前负后正相加仍然可能等于 target。




# 字符串 Strings（7）



## 标准题型（5）



### E344. 反转字符串

1. 双指针原地反转，无难度。



### E541. 反转字符串 II

1. 首先利用上题作为内置的 API，使字符串在指定位置范围内进行互换。
2. 主要思想：每次循环时，步进不再是 `i++`，而是 `i += 2 * k`，这样**每次循环后，都会划定大小为 2k 的空间**，然后在此空间内进行字符串操作即可。
3. 根据特殊情况总结出，只要满足 k 个字符时，就反转，不管是否剩余总量是否小于 2k 个。因此反转时，先判断 i + k 是否超出了数组长度，如果超出时，那么反转 i 到 length 的元素即可，否则正常反转。
4. 注意：判断内的操作完成之后需要 break（因为 i + k >= length 时，i 仍然小于 length 而在循环中继续操作），否则会重复反转。
5. 注意：边界值要写对，因为索引下标是从 0 开始的。
6. 二刷笔记：
    1. 单循环遍历指针就够了，不需要双指针。
    2. 进入循环后，先判断是否为特殊情况（i + k - 1 > length - 1），如果是特殊情况直接 break 在循环外特殊处理即可（也可以循环内处理并 break，一样的）。否则正常情况正常反转。




### O05. 替换空格

1. 要求原地替换不用额外空间，那么需要对原字符串扩容。将该字符串转换为 StringBuilder 后，遍历该字符串，遇到空格时，就 append 两个空格，作为扩容的方法。
2. 设置双指针，旧指针指向扩容前的尾部索引，新指针指向扩容后的尾部索引。
3. 旧指针开始遍历，并将旧指针指向的元素移动到新指针指向的位置，旧指针遇到空格时，新指针添加新元素并单独左移。
4. 双指针都指向结尾元素是因为数组地址是连续地址，从前往后的话会移动大片的元素。
5. 二刷笔记：
    1. 没有原地替换，采用两个数组的方式进行数据的添加。
    2. 如果要原地（但也不算非常非常严格意义上的扩容，还是需要 new 空间，但没那么多），需要将原数组变成 StringBuilder 之后扩容才行。




### M151. 反转字符串中的单词

1. 因为使用 `StringBuilder` 申请了额外的空间，不算原地反转。
2. 比较综合的题，不用内部的库函数，自己写三个 API 调用即可。
3. 首先去除原字符串中前导尾随的空格，即可以找到字符串新的起始索引和结束索引。然后利用新的索引进行 `StringBuilder` 的拼接。遍历字符串时，**字符串没有遇到空格或 `StringBuilder` 的结尾不为空格时，即可将遍历到的字符拼接进去**，这样就解决了多个空格转化成一个空格的问题。（因为当字符串为空格，且 `StringBuilder` 的结尾也不为空格时，意味着此时需要拼接一个空格，此时字符串正好遍历到空格，就可以将空格拼接进去。当字符串不为空格而 `StringBuilder` 的结尾为空格时，意味着已经有一个空格了，无须再拼接多个空格，此时就可以跳过原字符串的空格不用拼接进去）。
4. 然后反转整一个已经去除空格的 `StringBuilder`。
5. 最后反转 `StringBuilder` 中的每一个单词即可。（因为空格已经处理完毕，因此以空格为分界线分辨是否为一整个单词）。
6. 注意：因为是先拼接的字符串（原字符串不可变，且数组扩容性能较低，因此采用 `StringBuilder` 拼接来代替扩容），因此其他的私有方法接收的参数都是 `StringBuilder` 类型，而且操作是同一个 `StringBuilder`，因此也不需要返回值。
7. 主要思想：先全部反转，再局部反转。因为字符串是顺序表存储，移动元素会牵扯到后面地址内的元素，性能低，因此采用局部移动降低性能消耗。
8. 二刷笔记：
    1. 首先去掉了前导尾随空格以及多余的空格（使用了 StringBuilder 进行拼接字母和空格）。
    2. 其次反转一整个字符串（无难度）。
    3. 需要单独处理当遍历指针到最后一个字母的情况。因为最后一个字母不是空格，按要求时遇到空格才会反转单词（以空格为分界线）。




### O58.左旋转字符串 II

1. 没有原地反转，申请空间之后无难度，简单拼接字符串即可。
1. 二刷笔记：该次解决使用了原地反转。其实核心思想就是先反转整个字符串，然后反转前半部分，最后反转后半部分。也就是先反转整体，再反转局部，跟上题类似。



## KMP 算法（2）

> **主要是为了解决：在一个串中是否出现过另外一个串，也就是在文本串中查找是否出现过模式串的串匹配问题。**
>
> 1、构造 Next 数组：（例子：文本串 aabaabaaf，模式串 aabaa）
>
> 1. next 数组的目的是文本串和模式串的某个字符匹配失败时，模式串应回退的**索引下标**位置。
> 2. 在表示回退索引下标的同时，next 数组中的值也表示到该索引所在的元素时，最长相等前后缀的长度。
> 3. 最长相等前后缀的目的在于，当能匹配到 f，就说明 f 之前的 aa 是已经匹配成功的，因此找最长相等前后缀，即找 aa（上一个已经匹配成功的前后缀）的下一个元素进行匹配，如果匹配成功则可以**复用**前后缀，否则继续回退。
> 4. 因为 next 数组要统计所有元素下的最长相等前后缀，因此给 next 赋值时不会因为两字符的相等或不相等跳过赋值。
> 5. 总的来说，目的是为了更好的复用以前已经匹配过的字符，减少匹配次数，因此采用相等前后缀来解决。
>
> 2、文本串与模式串匹配：
>
> 1. 构造 next 数组时，相当于模式串自己与自己匹配，建立数组。
> 2. 文本串与模式串匹配时，不会建立数组。
> 3. 当模式串的指针遍历结束时，**数值正好等于模式串的长度**，此时匹配成功，否则匹配失败。
>
> 3、注意：构造 next 数组时，可能有减一法等，不管任何方法，都注意对比时文本串与模式串开始的位置。一定要注意对比的位置！！！



### M28. 找出字符串中第一个匹配项的下标 :star:

1. 不能用滑动窗口+哈希，因为要求的是第一个匹配项的下标，排序后索引会混乱。可以单独用滑动窗口+库函数，此题使用 KMP。
2. KMP 时间复杂度为 O(m + n)，滑动窗口为 O(m * n*)。
3. 构造 next 数组时，j 指针是从 1 开始，而 i 指针是从 0 开始的。但在匹配时，两个指针指向不同的字符串，因此都是从 0 开始。
4. 在两串匹配不相同时，回退的是指向模式串指针前一个元素为索引的 next 数组中的元素位置。且回退是连续回退，而不是只回退一次。
5. 当出现不匹配时，尝试寻找回退位置是否匹配，如果回退位置匹配，则意味着回退之前的元素也匹配，不必从头开始匹配。
6. 与前缀减一的方法区别是：
    1. i 初始为 -1，j 初始为 0，从 0 开始遍历文本串。
    2. 回退时，直接返回指向模式串为索引的 next 数组中的元素位置，而非前一个。
7. 二刷笔记：
    1. 不管是构造 next 数组还是在串匹配时，一定一定一定要先写判断字符串不同的情况，然后才判断字符串相同的情况。因为在字符串相同时，i 会 + 1，此时再判断字符串不同时，i 坐标已经变化了。因此**判断顺序不能颠倒**！！！！！！！！
    2. 构造 next 数组时，文本串即是模式串本身。而串匹配时，需要两个指针去对比文本串和模式串的每一个元素。而且循环的是 “文本串”，且索引从 1 开始。
    3. 而且 KMP 是匹配第一个符合模式串的下标，因此只要模式串的指针到达尾部，就代表匹配完成。





### E459. 重复的子字符串

1. 使用 KMP 算法思想解决。
2. 如果一个串中有重复的子串，那么该串的 next 数组一定是：设重复子串的长度为 x，总长度为 y，索引从 0 到 x 存放的元素都是 0，也就是最长相等前后缀是0，之后索引从 x + 1 到 y 存放的元素数值开始递增。
3. 因此可以得出串的总长度对重复子串取模为 0 时，那么该串是由重复子串组成的。
4. 因为最长相等前后缀是不包括串本身的，因此**重复子串的长度 = 串总长度 - 最长相等前后缀的长度**。其中最长相等前后缀的长度保存在 next 数组的尾部。
5. 注意特殊情况：当 next 数组尾部元素为 0 时，需要直接返回 false。
6. 二刷：当某个串有重复子串时，注意该串 next 数组的特殊性。



# 栈与队列 Stacks And Queues（7）



> **栈：**
>
> **1、Stack 类的底层实现基于动态数组，继承自 Vector 类，因此也有线程安全的特性。**
>
> **2、 `Stack` 类使用一个数组来存储元素，并使用一个指针（称为栈顶指针）来指示栈顶元素的位置。当新元素被入栈时，栈顶指针向上移动；当元素被出栈时，栈顶指针向下移动。**
>
> **3、底层数组的大小是动态调整的，当元素数量超过数组大小时，会自动进行扩容。扩容时，`Stack` 类会创建一个更大的数组，并将原数组中的元素复制到新数组中。**
>
> **队列：**
>
> **1、与栈不同，`Queue` 是一个接口，继承自 `Collection`，常用的实现类有 `LinkedList`、`ConcurrentLinkedQueue`、`LinkedBlockingQueue` 、`PriorityQueue`。**
>
> **2、因此实际中，根据性能、线程安全、元素顺序等使用合适的实现类，接口只提供基本的队列操作。**



## 标准题型（5）



### E232. 用栈实现队列

1. **模拟入队时，正常入栈即可**，主要是在模拟出队也就是出栈的时候做文章。
2. 需要实例化两个栈对象，一个作为输入栈，一个作为输出栈。入队时将值压入输入栈中，出队时，将所有输入栈内的值先弹出，然后压入输出栈内，最后输出栈弹栈即可。
3. 新建私有方法，当输出栈为空时，将输入栈内的所有元素压入输出栈内，其中当输出栈内还有元素时，无法将新元素压栈。
4. 其中 pop 弹栈会将栈顶元素返回并删除栈内的元素，而 peek 只是返回栈顶元素并不影响栈内的元素。
5. Stack 自带的基本操作：
    1. `push(E element)`: 将元素压入栈顶。将指定元素添加到栈顶。
    2. `pop()`: 弹出栈顶元素。移除并返回栈顶的元素。
    3. `peek()`: 查看栈顶元素。返回栈顶的元素，但不移除它。
    4. `empty()`: 判断栈是否为空。如果栈为空，返回 true；否则，返回 false。
    5. `search(Object o)`: 查找元素位置。从栈顶开始，返回指定元素相对于栈顶的位置索引。如果元素不在栈中，返回 -1。
    6. Stack 类还继承了 Vector 类的其他方法，比如 `size()`、`isEmpty()`、`contains(Object o)` 等。
6. 二刷笔记：出队是连贯的操作，必须先将输出栈内的值清空之后才能再添加数据。因此出队时如果输出栈为空，则添加数据，如果不为空，弹出值即可。



### E225. 用队列实现栈

1. **模拟入栈时，正常入队即可**，主要是在模拟出栈也就是出队的时候做文章。
2. 实现类使用 LinkedList
3. 新建私有方法，栈出队时，除了最后一个元素之外，全部重新入队，然后再出队一个元素，就完成了一次模拟出栈的操作。
4. Queue 自带的基本操作：
    1. `boolean add(E e)`: 向队列尾部插入一个元素，如果队列已满则抛出异常。类似于 push。
    2. `boolean offer(E e)`: 向队列尾部插入一个元素，如果队列已满则返回 `false`。
    3. `E remove()`: 移除头部元素并返回，如果队列为空则抛出异常。类似于 pop。
    4. `E poll()`: 移除头部元素并返回，如果队列为空则返回 `null`。
    5. `E element()`: 返回队列头部的元素但不移除，如果队列为空则抛出异常。类似于 peek。
    6. `E peek()`: 返回队列头部的元素但不移除，如果队列为空则返回 `null`。
    7. `boolean isEmpty()`: 判断队列是否为空。
    8. `int size()`: 返回队列中元素的个数。
    9. `boolean contains(Object o)`: 判断队列是否包含指定元素。
    10. `boolean remove(Object o)`: 从队列中移除指定元素。
    11. `void clear()`: 清空队列中的所有元素。
5. 二刷笔记：pop 或 top 时，都要修改元素的位置才会达成栈的效果。因此该操作前需要先把尾部的元素转移到最前方，进行元素的出队再入队。



### E20. 有效的括号

1. 需要明白的是：(){} 是合法的，但 ({)} 是不合法的。
2. 遍历整个字符串，是左括号是则入栈，如果遇到右括号，则直接弹栈进行比较，如果不匹配则直接返回 false。
3. 注意特殊情况：
    1. 还没有遍历完成时，栈空，则说明右括号是多余的，此时匹配失败。
    2. 已经遍历完成，栈不空，则说明左括号是多余的，此时也匹配失败。
4. 二刷注意考虑特殊情况。



### E1047. 删除字符串中的所有相邻重复项

1. 思路类似上题，可以采用栈去解决，但栈是反向输出，如果需要正向输出且需要栈的比对方法的话，采用双端队列 Deque 解决。
2. 遍历字符串，将字符从尾部放入队列中。当队列不空时，比较遍历元素与队列尾部元素，如果相同，则该元素出队且 continue 循环，如果不相同则将该元素从尾部放入队列中。
3. 最后使用 StringBuilder 将双端队列中的元素按顺序拼接即可。
4. 注意：不能用双端队列重写的 `toString()` 方法，格式不符合题意。



### M150. 逆波兰表达式求值

1. **栈适用情况：成对的元素需要去匹配时，逆波兰式也是数字与运算符成对的去运算，因此用栈处理。**
2. 思路类似上题，用栈去解决，遇见数字时压栈，遇见运算符时弹栈并运算。
3. 平常使用的表达式是中缀表达式，题目中给的格式为逆波兰表达式。其优点一个是去掉括号后无歧义，一个是适用于栈操作，利于计算机进行运算。
4. 注意：减法与除法运算时，注意两个数字的顺序。



## 单调队列（1）

> **1、优先级队列是将队列中的值进行升序或降序排序，而单调队列是从每个元素入队开始，就要手动维护队列的单调性，使队列的值为单调增或单调减，并使队首元素恒为规定范围内的最大值或最小值。**
>
> **2、与优先级队列的区别是：单调队列在维护单调性时，每次出列的不一定是队列里的最大值或者最小值，而优先级队列因为是堆的缘故，每次出列时只能是队列中的最大值或者最小值**



### H239. 滑动窗口最大值

1. **单调队列需要手动的去维护队列内的顺序**，因此需要根据不同的题目手动写出 push 与 pop 时维护队列的过程。而**优先级队列是堆，会自动排序队列内的元素**
2. 求最大值，因此需要维护一个单调减的单调队列，又因为是滑动的窗口，因此需要考虑元素滑进滑出的情况。该题使用双端队列数据结构解决。
3. 滑进元素时，首先将该元素与队尾元素进行比较，如果该元素较小则直接从尾部入队，如果该元素较大，需要先将队尾元素出队，直至对内元素大于该元素时，才将该元素从尾部加入队列中。
4. 当到达滑动窗口固定值时，首先将队首元素加入最大值数组中，因为此时达成固定滑动窗口值且队首元素经过处理已经是滑动窗口内的最大值。
5. 记录最大值之后，开始滑出元素，如果滑出的该元素恰好是队首元素，那么相应的需要从队列中移除队首元素。
6. **先滑进元素 -> 达成滑动窗口固定值并进行处理 -> 之后滑出元素 -> 最后双索引后移一位，开始下一个窗口**。总是在滑进一个元素后达成指定窗口宽度的条件，而非滑出元素之后。
7. 注意：因为是单调队列，因此滑进元素时，如果该元素等于队首元素，并不会达成该元素大于队首元素的条件，因此不会“清理队列”，直接加入即可。
8. 该题不能用优先级队列的一个原因是，窗口是滑动的，每次滑出的元素是不固定的，而优先级队列每次弹出的元素一定是队列内最大的元素或者是最小的元素。
9. 二刷笔记：总是要先滑进元素，然后再进行接下来的判断和操作。



## 优先级队列（1）

> **1、其实就是堆，因为优先级队列对外就是队首出元素，队尾进元素，看起来跟队列相同，但实质还是堆，利用堆本身的重建让队列有序。但实际使用时，还是 poll、offer 等队列的操作**
>
> **2、无论是大顶堆还是小顶堆，都遵守左大右小的规则，且大顶堆的根结点是大于所有子节点，相应的小顶堆的根结点小于所有的子节点，也就是每个堆的堆头，都是堆内最大的或者是最小的结点。**
>
> **3、具体实现可以使用 PriorityQueue，逻辑上是小顶堆（树形结构），按照自然排序，也可以通过 Comparator 接口进行自定义排序，物理存储是用数组来实现的。**



### M347. 前 K 个高频元素

1. 要取前 K 个元素时，考虑使用大小顶堆（优先级队列）去处理。
2. 首先建立 `HashMap`，将频次与元素一一对应起来。
3. 然后建立优先级队列 `PriorityQueue<int[]>`，并重写 `Comparator` 接口以指定优先级队列按从小到大排序（也就是建立的是小顶堆）。其中优先级队列中每个结点的元素是 int 数组，作用见下。
4. 之后遍历 `HashMap` 中的键值对，并将 K-V 放入临时数组，然后将该数组依次入堆（开始建立小顶堆）。
5. 因为**优先级队列是无界的**，因此容量到 k 时，就开始从队头出队（小顶堆开始弹出最小的元素）。
6. 最后优先级队列内剩下的，就是前 K 大的元素，然后依次遍历，装满 k 个即可。
7. 注意：堆中结点存放的元素根据实际情况来定，本题放入 EntrySet 也行，但是 API 比较复杂，因此转换成 int[2] 数组可以简化操作。所以一定要清楚，堆中的结点要存放什么。
8. 二刷笔记：使用了大顶堆，取前 k 个元素时，从堆中直接取，而不是先弹出。



# 二叉树 Binary Trees（40）

> **解题过程中，主要形式是完全二叉树和满二叉树。存储结构为链式。**

 

## 二叉树的深度优先遍历（3）

> **1、深度优先遍历：先序、中序、后续（结合栈理解），递归法、迭代法。**
>
> **2、递归遍历三要素：确定递归函数需要的参数和返回值、确定终止条件、确定单层递归的逻辑（因为递归是做同样的操作，只需要单层逻辑就是全部的逻辑）。**



### [E144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

1. 前序遍历的顺序：根、左、右。
2. 递归法：根据递归去实现，每层的逻辑就是，先将该结点放入结果集中，然后去找该结点的左孩子，找到后，先将左孩子放入结果集中，再找左孩子的左孩子，当遇到空结点时，就退出递归，进而去找右孩子。
3. 迭代法：利用栈去实现，栈可以保留 “上一级” 的结点。但因为栈是 FIFO，因此需要先将右孩子压入栈，然后才是左孩子，这样出栈的顺序就是根左右的前序遍历（最先的肯定是根，然后才是根的左右孩子）。



### [E145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

1. 后序遍历的顺序：左、右、根。
2. 递归法：先访问左右孩子，放入结果集中，最后访问剩下根结点。
3. 迭代法：先序遍历的顺序是根左右，调整一下左右孩子入栈顺序则变为根右左，最后将结果集反转一下，就是左右根，也就是后序遍历的顺序。（因此实质上还是先序遍历，只是更改了一点点的顺序）



### [E94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

1. 中序遍历的顺序：左、根、右。
2. 递归法：先访问左孩子，之后会退化成根结点放入结果集中。递归左子树结束后，将根结点放入结果集中，最后再递归右子树。
3. 迭代法：
    1. 与前两种遍历不同，前两种是先访问根结点，进而处理根结点，访问和处理顺序是一致的。而中序遍历会深度遍历，找到最左的结点，然后处理该结点，访问顺序和处理顺序不同。
    2. 栈中存放的元素相当于在找左孩子（深度遍历）的路径中访问的结点，依次压入栈中。当访问到最深处时，才开始处理结点。



## 二叉树的广度优先遍历（8）

> **1、广度优先遍历：层序（结合队列理解），迭代法。**
>
> **2、层序遍历：核心是使用队列控制，然后根据队列的每次不同的 size 控制访问每层结点的个数。进而延伸出对其中某一层的全部结点进行处理。**
>
> **3、在层序遍历中，每次队列循环都可以得到该层的结点，然后对该层结点进行逻辑处理（如求平均、求和等）。**



### [M102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

1. 使用队列来实现一层一层的遍历。
2. 迭代法：从根结点开始进入队列，并记录队列的长度（每一层的 size 不同），用来决定每次出队多少个元素。当有元素出队时，将其左右孩子加入到队列中，因为有 size 记录，因此出队不会弹出多余的元素。



### [M107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

1. 思路与上题一模一样，只是最后时使用 Collections 进行数组的反转即可。
2. 也可以在收集结果时逆序收集，但是核心思路还是正常的层序遍历。



### [M199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

1. 每次入队时，右子树优先入队。然后在每层的遍历过程中，先将队首元素 peek 加入到结果集中（因为右子树先入队，队首元素一定是树最右的元素，且只有队首这一个），最后多余的元素自行 Poll 掉即可。
2. 注意：只放右子树的思路是行不通的，因为如果没有右子树的话，右视图会看到左子树的结点。
3. 二刷笔记：关键在于调整层序遍历左右结点入队的顺序，要右子树先入队。



### [E637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

1. 标准的层序遍历题型。
2. 因为 size 是用来遍历的，会一点点的减少，因此需要额外的变量来记录当前层结点的个数来计算平均值。



### [M429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

1. 因为不是标准的二叉树，没有左右孩子之分，但是该数据结构中，一个结点会保存其所有的孩子，因此在队列中加入孩子时，加入整个孩子集合即可。



### [M515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

1. 与 E637 相同，都是取得某一层的全部数据之后，进行数据的处理。



### [M116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

1. 因为队列中存放着该层的结点，因此某结点出队后，next 连接的应该是该队列队首的结点，也就是 peek 的结点。
2. 由于队列中也会出现存放下层结点的情况，因此在某一层最后一个元素出队后，手动置 next 为 null。
3. 因为有 size 的控制，所以出队的结点会严格控制住，只有该层的元素才会在循环中出队。
4. 二刷笔记：也可以设置一个 preNode，用来记录前一个结点，使前一个结点的 next 指向出队的结点。（因为 next 初始就是 null，因此最后一个结点不需处理，默认指向的就是 null）



### [M117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

1. 跟上题一毛一样。
1. 二刷笔记：上题说的是完整二叉树，该题是二叉树。但上题解决方法的解决范围是所有二叉树，因此无差别。



## 求二叉树的属性（13）

> **1、比较两棵树是否相同、镜像相同、是否包含另一棵树。**
>
> **2、求二叉树的深度，其中深度是指该树从根结点到该结点经过的结点数（指从根节点到该节点的最长简单路径边的条数），深度是正序向下，根深度为 1 或 0。可以用前序遍历求深度。**
>
> **3、根据求结点的高度来确定该树是否平衡，其中高度是指该结点到叶子结点经过的结点数（指从该节点到叶子节点的最长简单路径边的条数），高度是逆序向下，根的高度是最高的，因为离叶子结点最远。可以用后序遍历求高度。**
>
> **4、求结点个数，其实就是递归后序遍历加一点逻辑，将每个遍历的结点累加即可。或者用迭代层序遍历。但如果是满二叉树可以直接利用其性质公式求解。**
>
> **5、求路径以及对路径进行处理，通过回溯记录遍历的路径，实质还是前序遍历，加一点逻辑处理。需要注意的是记录路径时避免遍历到 null 结点。**
>
> **6、求左下角结点的值、求所有左叶子之和。核心仍然是遍历，但拿到结点时需要根据题目判断该结点是否符合题意，然后再处理该结点的逻辑。**



### [E101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/):star:

1. 通过迭代法，将左右子树需要比较的结点放入容器中，成对比较。因此将结点放入栈中，每次取出两个元素进行匹配即可。
2. 初始时，将根结点直接连接的左右孩子放入栈中，而不是将根结点单独放入栈内。
3. 注意：比较时，是左外侧与右外侧、左内侧与右内侧比较，因此每次放入结点时，要放入 4 个结点。
4. 二刷笔记：镜像比较，需要解决的问题根结点的两个子树是否镜像，进而判断整棵树是不是镜像的，因此传入的参数代表的是子树，而不是子结点。而且比较的前提是，根结点的左右孩子相等才可以继续向下层比较。
5. 因此并不是左右子树同时遍历并比较，而是 “穷尽” 一颗子树，比较其左右结点是否相同，然后返回结果给上层，进而判断出该树是否镜像（所以实质还是比较两个结点）。
    1. 确定入参和返回值：传入左右结点，返回比较的结果。
    2. 确定终止条件：
        1. 左右结点都为空。
        2. 左空右不空。
        3. 左不空右空。
        4. 左右都不空，比较两个结点的值是否相同。
    3. 确定单层递归的逻辑：比较的是子树，因此传入二叉树的内侧两结点（左子树的左结点、右子树的右结点），传入二叉树的外侧两结点（左子树的右结点、右子树的左结点）。拿下层返回上来的结果进行 `&&` 比较。
6. 使用迭代法时，null 也会被放入栈中，因此对比时需要考虑情况（与递归的终止条件一致）。

 

### [E100. 相同的树](https://leetcode.cn/problems/same-tree/)

1. 迭代法：与上题类似，只是比较对象从镜像变成正常比较。
2. 递归法比较简单，二刷的时候可以尝试写一下。
3. 二刷笔记：与上题相比，题目直接给出了两个树的根结点，相当于直接给出了 root.left 和 root.right。因此迭代法修改一下入栈顺序即可。
4. 递归法与上题也类似。
5. 注意：两个题的解决方法绝不是两棵树同时遍历，而是对比结点的左右子树，将结果一步步的返回，进而判断总树是否相同或镜像。



### [E572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

1. 递归法：与上题的递归法类似。
2. 主要思想：subRoot 是 root 的子树，要么两棵树完全相同，要么是 root 的左子树，要么是 root 的右子树。其中，判断两棵树是否相同的逻辑就是上题。
3. 判断两棵树是否相同：递归的调用方法并不断传入两个参数：subRoot 的左子树和 root 的左子树进行对比，然后对比 subRoot 的右子树和 root 的右子树。
4. 判断是否为其子树：递归传入两个参数：subRoot 和 root 的左子树，subRoot 和 root 的右子树，经过 “冗余” 递归之后，最终会使用 “判断两棵树是否相同” 的方法来判断。
5. 是否为左右子树可以理解为找链表的公共部分时，长的链表先遍历掉一部分，此处也是如此。root 先遍历掉一些结点，然后再判断二者是否为相同的树。
6. 二刷笔记：当 root 遍历掉冗余部分，与 subRoot 相比时，就退化成了比较相同的树的过程，也就是上题。因此可以利用任意一个深度优先遍历的方法，将 root 的冗余部分遍历掉，然后对比两树是否相同即可。
7. 因此会有两个递归函数：一个是递归遍历掉冗余部分，一个是递归遍历二树是否相同。
8. 所以只要 subRoot 的根结点与 root 的根结点或左孩子或右孩子值相同时，就判断冗余结束，开始对比是否相同。
9. 也相当于前序遍历，加了 “一点点” 的处理逻辑，如 `isSameTree(root, subRoot)` 相当于先拿了根结点开始处理根结点的逻辑，而 `isSubtree(root.left, subRoot)` 相当于去遍历左结点。



### [E104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

1. 层序遍历是按层来的，因此使用层序遍历最合适。
2. 每层序遍历完一层，树的深度加一即可，层序遍历完成后，就是最大深度。
3. 二刷笔记：递归法前序遍历，遍历到根结点时深度加一，然后再取左右孩子遍历时深度的最大值。



### [E559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

1. 迭代法与 M429 相同的思路。
2. 二刷笔记：也是利用递归前序遍历，但是 N 叉树没有左右子树的逻辑限制，因此在递归孩子时，使用循环依次访问集合中的孩子。当整个孩子遍历完成之后，取得某个孩子的深度后，+ 1 就是最大深度（要加根结点本身）。



### [E111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

1. 当出现叶子结点时，就是该树的最小深度。
2. 在结点入队的过程中，如果某一结点没有左右子树时，那么该结点的层数就是最小深度，直接返回当前记录的深度值 +1 即可。
3. 二刷笔记：只有到达叶子结点时，才是树的最小深度。如果左子树不为空，右子树为空，那么就要继续遍历其左子树，如果都为空时，返回二者子树深度的最小值。



### [M222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/):star:

1. 根据题目给定的条件，一定是完全二叉树。对于一颗完全二叉树一定有两种情况：
    1. 本身是满二叉树，然后根据公式：（2 ^ 树深度） - 1 计算结点该树的结点数（其中定义根结点深度为 1）。
    2. 递归左右孩子，递归到某一深度时，一定有左孩子或右孩子为满二叉树，然后根据满二叉树的公式计算子树的结点数。
2. 在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。
3. 递归三要素：
    1. 参数及返回值：传入结点，返回该结点的深度。
    2. 终止条件（该题只有一个递归出口）：最终剩下一个结点时，总归算是满二叉树，此时左右子树的深度一定相等，计算结点并返回。
    3. 单层逻辑：左子树结点 + 右子树的结点 + 1 = 当前传入参数结点的结点数。 
4. 二刷笔记：核心思想还是利用二叉树的普遍解法：左子树的结点数 + 右子树的结点数 + 根结点本身。
5. 但完全二叉树可能是满二叉树，可以利用这个性质优化计算，因此先利用深度判断是否为满二叉。求左右子树二叉树的深度：
    1. 如果深度相同，则该树为满二叉树，直接利用满二叉树结点公式得出结点数。
    2. 如果深度不同，则利用标准二叉树结点算法，将左右子树的结点数相加并加根结点。
    3. 注意：完全二叉树的一定有满二叉树子树，因为一个叶子结点也算满二叉树。而且从先计算左子树的深度、再计算右子树的深度、最后进行结点数的相加时，可以看出是后序遍历。
    4. 注意：找左右子树的深度时，左右子树应该各一个遍历指针，不能共用一个 root。



### [E110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

1. 递归法：
    1. 确定递归函数的参数和返回值：传入当前结点，返回当前结点的高度。
    2. 确定单层递归逻辑：获取当前结点左孩子的深度、右孩子的深度。
    3. 确定递归出口：
        1. 左右孩子不满足平衡树高度差时，直接返回 -1。
        2. 左子树深度为 -1 时，直接返回 -1。
        3. 右子树深度为 -1 时，直接返回 -1。
        4. 当前结点深度满足平衡条件时，返回当前结点的深度（取左右孩子最大的值）。
2. 二刷笔记：当左孩子或右孩子已经不平衡时，应直接返回 - 1。而且与求深度不同的是，深度是累加的过程，而判断平衡并不是累加，而是实时对比左右孩子。



### [E257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

1. 当遇到叶子结点时，就需要记录该次遍历的路径，而非遍历结点为 null 时。
2. 遍历模式使用前序遍历，因为会先记录根的位置。
3. 因为在二叉树中，有父子关系的限制，因此回溯时不必记录访问过哪些结点，会必定从子回到父。
4. 递归法：
    1. 确定递归函数的参数和返回值：传入当前结点、传入当次的路径、传入返回结果集，无返回值（因为记录在了结果集中）。
    2. 确定单层递归逻辑：记录当前结点，并判断左右孩子不为空时，进行递归遍历并记录路径。当左（右）孩子遍历完成时，需要进行回溯，路径长度减一，则会回溯到父结点的位置。
    3. 确定递归出口：遇到叶子结点时，就需要拼接当前的遍历路径，并返回。
5. 注意：回溯和递归是一一对应的，有一个递归，就要有一个回溯。
6. 二刷笔记：一定注意！！！！当遇到叶子结点时，就需要记录该次遍历的路径！！！如果遍历到 null 结点会将 null 结点记录到路径中。因此虽然使用的是前序遍历，但是在遍历左右结点前需要确保该结点不是 null 结点。
7. 父问题依然是遇到结点就将结点放入路径集合中，但是不遍历 null 结点，这是与普通前序遍历的区别。额外的逻辑处理就是遇到叶子结点时，就需要记录一次路径。而普通前序遍历是将所有遇到的结点都放在一个集合中，没有额外处理。



### [E404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

1. 要判断当前结点是否为左叶子，首先要确定当前结点是父结点的左孩子，其次才判断该结点是否为叶子结点。
2. 因此主要思想是通过结点的父结点判断该结点的属性。
3. 递归法：
    1. 确定递归函数的参数和返回值：传入当前结点，返回该结点的值（如果不符合条件就返回 0）。
    2. 确定递归出口：遍历到空结点、遍历到叶子结点（因为是靠父结点来判定的，因此这也算是一个出口）。
    3. 确定单层递归逻辑：当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和右子树左叶子之和，相加便是整个树的左叶子之和。
4. 二刷笔记：递归法依旧可以用前中后序进行遍历结点。父问题的实质还是遍历结点，但是拿到的结点要进行判断处理，判断只有该结点是父结点的左孩子才相加。然后每次向上返回左右子树的结果。最后将子树的返回值进行合并即可。
5. 同样的，如果使用迭代法，只是在出栈时判断该结点左孩子的状态，并根据状态决定是否相加。
6. 注意：难点在于用父结点判断子节点的状态，实质没有变化。



### [M513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

1. 使用层序遍历，找每次队列中队首的值即可，无难度。
2. 二刷笔记（使用递归法）：首先是最左，因此用前序或者中序这种左优先的遍历（因为根结点没有额外处理逻辑）。其次是最下，因此根据深度判断遍历到的结点是否为最下层的结点。最后左下角的值一定是叶子结点，因此先判断是否为叶子结点，其次判断是否深度最深。
3. 本质还是遍历，在遍历到结点时，判断该结点是否符合要求。
4. 注意：需要用全局变量临时保存最大深度和返回值。



### [E112. 路径总和](https://leetcode.cn/problems/path-sum/)

1. 类似 E257，也需要用前序遍历的思想去考虑，每经过一个结点时目标值减去该结点的值，在寻找路径的过程中如果目标值减为了 0，则存在路径总和为目标值的路径。
2. 递归与回溯是一体的，当递归的一层结束后，会紧接着回溯到上一层。
    1. 确定递归函数的参数和返回值：传入当前结点，因为不需要搜索整棵树，有合适的结果返回即可，因此需要返回值为 boolean。
    2. 确定递归出口：空结点时返回、叶子结点时进行逻辑处理。
    3. 确定单层递归逻辑：根结点时直接目标值相减、递归传入左右孩子和目标值。
3. 递归与回溯的时机：如果到路径终点，发现目标值不匹配，则返回 false，也就是返回到其父结点的位置，且目标值会回退没有减该结点的状态。如果到路径终点，发现目标值匹配，直接返回 true，并逐层返回 true，不需要再继续找路径。
4. 防止未到叶子结点就返回结果，需要判断如果该结点的左右孩子不为空时，就继续递归逻辑。
5. 二刷笔记：还是在叶子结点的时候进行汇总该路径。因为二刷时，根结点没有处理逻辑，转而在左右子树时做了减法处理，而且在入参时已经将最开始的根结点减去，因此在最后时判断 targetSum 是否等于 0 进而判断是否有路径。
6. 注意：不单独处理各节点是因为在遍历前后单独处理了回溯，如果省略回溯的话就需要单独处理根结点。



### [M113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

1. 本解决方法中，单独处理了作为根结点时的逻辑，因此左孩子右孩子在递归调用时，正常传入 targetNum 即可，不需要再单独减。
2. 递归法：
    1. 确定递归函数的参数和返回值：传入当前结点、传入目标值、传入记录当前路径的集合、传入结果集，因为需要搜索整棵树，因此不用返回值，而是在传入参数中获取结果集。
    2. 确定递归出口：空结点时返回、叶子结点时进行逻辑处理。
    3. 确定单层递归逻辑：递归左右孩子，并回溯路径。
3. 注意：
    1. paths 不是一次性的，是一直公用迭代的，因此在加入返回结果集中时，需要新 new 一个，并将当前 paths 路径的值复制进去。
    2. 本题回溯步骤不可省略，因为在 257 中，使用了临时不可变的变量 String 保存递归前的路径，以保证 “每层递归独享各自的路径”，递归结束时不能带着下层的递归回去，因此完成了回溯的操作。
4. 二刷笔记：添加结果时，一定一定一定！！！！要新 new 一个 list。如果不 new 的话，传入的其实是 list 的地址，当 list 改变时，已经装入 res 的 list 中的值也会跟着改变。



## 二叉树的修改与构造（5）

> **1、利用前序、后序或层序翻转二叉树，父问题依旧是将拿到的结点进行 swap 处理。**
>
> **2、利用数组构建二叉树，通过不断的切割区间来实现。**
>
> **3、将两棵二叉树合并为一棵，使用其中一棵树为标准树，将另一棵树合并到该标准树。也是遍历的思想，只不过递归之后需要接收新的结点。**



### [E226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

1. 主要思想还是遍历，当遍历到某个结点时，就反转该结点的两个孩子。因此可以自由选择遍历的方式。
2. 因此可以使用递归或者迭代法的前序、后序、层序去遍历并反转，不能使用标准的中序去反转，因为会出现某个结点被反转两次的情况。



### [M106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

1. 后序遍历可以确定根结点，中序遍历可以根据根结点切割出左右孩子区间。
2. 首先根据后序遍历确定根结点后，去切割中序遍历，得到中序的左右孩子。然后根据中序的左右孩子区间长度切割出后序遍历的左右孩子区间。其中，中序左孩子的区间长度与后序左孩子的区间长度相同，中序右孩子的区间长度与后序右孩子的长度相同，根据这个性质去切割后序遍历。
3. 因为有根结点存在，中序遍历是最好切割的，然后根据切割好的中序遍历去切割后序遍历。
4. 使用的是 `Arrays.copyOfRange()` 进行数组的切割，因此区间为左闭右开。
5. 递归法：
    1. 确定递归函数的参数和返回值：传入不断切割的左右孩子，返回结点。
    2. 确定递归出口：左孩子区间或右孩子区间长度为 0 时，代表没有左（右）孩子，返回 null。左孩子区间长度为 0 时，表明是叶子结点，返回该结点交给上层。（左孩子区间长度为 0 那么右孩子区间长度也一定为 0）
    3. 确定单层递归逻辑：不断切割左右区间，传递给下层，并接收下层传过来的结点。
6. 注意：切割后序遍历右孩子区间时，需要将最后一位排除在外，因为最后一位是确定的根结点。而后序右孩子区间的起始索引，就是后序左孩子区间的长度
7. 二刷笔记：当该结点为叶子结点（即两个区间长度为 1 时），就需要将结果返回了。



### [M105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

1. 与上题类似，只是在切割前序遍历左孩子区间时，要排除第一位，因为第一位是确定的根结点。
2. 二刷笔记：切割后的区间长度是相等的，因此可以用 to 参数减去 from 参数得到的校验长度是否相同。



### [M654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

1. 与上题类似，不过更简单一点。
2. 注意：因为每次都要切割数组，效率会低一点，但是，我不优化~（优化点是每次在原数组上切割操作，传入切割点，而不是每次都新建数组）。



### [E617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

1. 相当于一棵树覆盖到另一棵树上。可以将树 1 作为标准树，将树 2 合并到 1 上去。
2. 递归法：
    1. 确定递归函数的参数和返回值：传入两个合并的结点，返回合并后的结点。
    2. 确定递归出口：树 1 的结点为空时返回树 2 的结点，反之。
    3. 确定单层递归逻辑：采用前序遍历，首先将两棵树的根结点传入，合并，因为是以树 1 作为标准，因此树 1 的左孩子接收两棵树各自的左孩子合并后的结点，右孩子同理。
3. 相当于同时遍历，因此每次递归传参时，两棵树传的参数是相同的。又因为是以树 1 为标准，因此接收返回值的是树 1 对应的结点。



## 求二叉搜索树的属性（5）

>**1、在 BST 中，有左小右大的性质，因此递归时天然带有方向，迭代时遍历指针只往前即可。在 BST 中，尤其记得前置指针 pre 的使用。**
>
>**2、经常使用中序遍历以及 pre 指针来对比与前者的大小关系，而且中序遍历是递增的数组，根据递增性质去判断结点之间的关系。**



### [E700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

1. 二叉搜索树 BST，左结点的值 < 根结点的值 < 右节点的值，左小右大。
2. 递归法：无难度。。。
3. 迭代法：如果是普通的二叉树，需要栈空间去回溯，但如果是 BST，会天然指定我们前进的方向，因此不需要回溯，查找的路径已经规划好了，不需要去遍历其他的结点就知道其他的结点不合适。



### [M98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

1. 因为 BST 的性质，中序遍历时每个结点的值都会大于前一个结点的值，这样比较的好处是每个结点都间接的进行了比较，不会出现 4 中的情况。
2. 因此采用中序递归遍历，并定义全局变量保存上一个结点，判断是否递增。
3. BST 经过中序遍历后是一个递增的有序数组，也可以判断该中序遍历的数组是否有序来判定是否为 BST。
4. 注意：不能单纯的比较左节点小于中间节点，右节点大于中间节点，因为这样对比只是跟父结点相比，没有跟祖父结点比较，可能会出现某右子树的左孩子比父结点小，同时也比祖父结点小的情况，正常来说是右子树的所有结点都要大于祖父结点。
5. 二刷笔记：严格按照中序遍历，先遍历完左子树之后再处理根结点。这种判断的题型只要在左右子树中发现了不合规的树可以立即返回，不用遍历完整个子树。
6. 注意：一定一定一定！！！！注意，在写递归且返回值是 boolean 时，在步骤中一定既要有返回 true 的语句，也有返回 false 的语句，否则 && 运算时结果不正确。除非左右子树单独返回（在该题中也推荐单独返回，即只要子树不符合结果直接返回，而不用等两棵子树全部遍历完）。



### [E530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

1. 思路同上一题，在中序遍历的过程中一直计算差值，并保留最小的差值。因为是递归执行，因此需要一个全局变量存储最小差值，使该值在全局递归可见并可以修改。
2. 相应的也需要一个全局变量，用来保存上一个结点。
3. 也可以将整个数组收集起来，然后进行差值的计算。
4. 注意：因为遍历第一个结点时，前面没有结点，因此遍历第一个结点时跳过比较。
5. 二刷笔记：需要遍历所有的结点，因此中序遍历递归不需要返回结果。而且在 BST 中，相邻的数要一定比相隔的数的差值要小。



### [E501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

1. 如果是普通的树，需要先遍历并将数据放入集合中，然后再次遍历集合进行处理。但 BST 中序遍历是有序的，因此可以原地处理，只需要遍历一次即可。
2. 与上题相同的思路，保留上一个结点，以便进行数值比对。
3. 当 pre 与 cur 结点数值不同时，直接将计数器 count 重置。如果相同则进行累加，如果超过最大值，则将集合进行清理，并放入该值，如果与最大值想等（众数不只一个），只放入该值，不必清空集合。
4. 注意：
    1. 题目要求返回的只是众数的值，不需要返回众数的数量。
    2. 累加完次数之后就需要判断是否大于 maxCount，大于了就需要更新集合。因为一旦 pre 不等于 cur，就需要重置计数器了。
5. 二刷笔记：pre 与 cur 相比的逻辑只是决定是否重置 count，而对比频率是每次都要做的。



### [M538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

1. 逆中序遍历，然后保存上一个遍历的结点，进行数值的累加即可。
2. 需要一个额外的变量保存上一个结点。



## 二叉树公共祖先问题（2）

> **1、普通二叉树：通过后序不断的遍历结点，当该结点符合其中一个参数时，立即返回该结点，相当于该子树找到了符合条件的解。然后逐层返回。**
>
> **2、搜索二叉树：因为 BST 有序，因此不必每个结点都需要遍历，当遍历到不符合大小关系的结点时，立即返回另一个子树（即去另一棵子树寻找），直到找到相应的参数，直接返回该结点。相比而言，不会搜索所有的结点，但还是要找到对应相等的结点。**



### [M236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

1. 当采用后序遍历时，处理顺序就变成了自下而上处理，正好用于处理祖先问题。因为遍历一定是从上至下的，但二叉树的回溯过程是从下至上的，因此可以通过回溯根据左右结点的情况，进行处理根结点的逻辑。
2. 前中后序递归笔记：处理单层的逻辑时，可以考虑成只有三个结点的满二叉树（而且是最后一层递归），如果是前序，会分别拿到根结点、左结点、右结点，根据根据逻辑去处理。如果是后序，可以考虑成经过递归之后，先拿到了递归后左结点，然后拿到了递归之后的右节点，最后才是拿到了根结点，然后在相应的位置做逻辑处理。
3. 该题总归有三种情况
    1. 得到的左结点是题目的结点之一，得到的右节点是题目的结点之二，那么根结点就是其公共祖先。
    2. 得到的左结点是题目的结点之一，但右节点返回了 null，此时就需要将左结点一层一层的向上返回。而右节点会从另一条路径找，最后的递归结果一定会返回成 1 的情况。
    3. 得到的左结点是 null，右节点是题目结点之一，同 2。
    4. 左右结点都为 null，说明没有公共祖先，但实质是给定的两个结点不在树中。
4. 特殊情况是公共祖先结点是本身，实质是 2 或者 3 演化而来，遍历到最后某子树仍旧为 null，那么此时返回有值的子树，这时返回的就是公共祖先也就是本身。
5. 注意：主要使用了回溯的思想，迭代法不适合回溯，而递归天然带回溯属性。
6. 二刷笔记：实质是使用后序遍历，在树中找两个结点是否出现过，如果出现过就返回该结点，让上层去接收，而且是不断将结果向上传递。
7. 假设两个结点同时出现在左子树，那么最终会将左子树的汇合点返回上来，右子树返回 null，根据处理逻辑会返回非 null 的数据，因此是层层上传的过程。（可以假设同时在右子树或分别两棵子树的情况）



### [M235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

1. 因为是 BST，关键思想在于首次找到一个结点，且该结点首次出现在指定的区间内即可。而且不用关心遍历顺序的问题，BST 数值有序，会自动指引遍历的路径。
2. 先遍历左子树，如果某结点在左区间之内，返回该结点。
3. 然后拿着该节点去遍历右子树，直到某结点在右区间之内，该结点就是目标的公共祖先。
4. 因为不确定 p、q 的大小，因此找比如左区间时需要同时满足大于 p 且 大于 q。
5. 二刷笔记：遍历时，当该结点不符合大小关系，直接返回另一子树，相当于将不符合条件的结点（或者说子树）一一排除在外。



## 二叉搜索树的修改与改造（4）



### [M701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

1. 正常的拿目标值遍历树，当遇到空结点时，就意味着找到了需要被插入的位置。
2. 找到位置后，创建新结点，并使用上层的父结点接住，因为是 BST，所以天然的找到是左孩子分支还是右孩子分支。



### [M450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

1. 如果删除的结点有左右孩子，那么被删除结点的右孩子成为新的根结点并返回给上层，被删除结点的左孩子移到新根结点的最左侧，成为其最左侧结点的左孩子。（因为 BST 中，左孩子一定是比右孩子的左孩子还要小的，其根结点没有之后，肯定是成为右孩子的最小附属，也就是其最左孩子的位置）
2. 递归法：
    1. 确定递归函数的参数和返回值：传入父结点，要删除结点的值，返回删除后要上层接收的结点。
    2. 确定递归出口：如果没有找到结点，则返回空并让上层接收空（也说明上层是叶子结点）
    3. 确定单层递归逻辑：
        1. 删除结点的左右孩子为空，是叶子结点，正常删除，并让父结点接收 null。
        2. 删除结点的左孩子为空，右孩子不为空，右孩子补位，让父结点接收右孩子。
        3. 删除结点的右孩子为空，左孩子不为空，同上
        4. 删除结点的左右孩子都不为空，见 1 的长说明。
3. 注意：长说明的情况中，只是找右子树的最左侧结点即可，不需要找左下方，因为 BST 中最左下的不一定是最小的。
4. 二刷笔记：无难点，主要是考虑的情况要清楚。不必用中序遍历，根据 BST 的特点找到对应的结点并处理即可。



### [M669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

1. 如果当前结点在区间内，则正常去搜寻其左右子树。
2. 如果当前结点小于区间，则需要去其右子树继续寻找是否有符合区间的结点。大于区间同理。
3. 不可以发现该结点不在区间内时，直接删除该结点，因为该结点的子树内可能还会有结点符合区间。因此是向上一层返回下一层的结点（相当于跨了三层，中间一层删除，上接下层）。
4. 二刷笔记：同点 3，如果不在区间内时，继续遍历子树而非直接返回结点，因为返回的结点可能是不符合区间的，但不会再次检查该结点，可能会出现遗漏现象。



### [E108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

1. 由数组构建二叉树，类似中序后序构建二叉树，需要不断的切割数组，找到合适的值创建结点。不同的是构建 BST 时，每次结点找数组的中间数值作为结点即可，切割更简单。
2. 父问题是找到合适的数值构建结点，并将构造的结点返回给上层，交给上层处理。需要处理的逻辑是找到合适的值进行构建。
3. 此次优化了一下，每次传入不断更新的切割点，而数组是共用的数组，没有新建数组。



# 回溯 BackTracking

> **1、回溯算法的本质是穷举，因此效率一般，顶多添加一些剪枝操作稍微提高一下。**
>
> **2、回溯法用来解决的问题：**
>
> ​	**2.1、组合问题：N 个数里面按一定规则找出 k 个数的组合。**
>
> ​	**2.2、切割问题：一个字符串按一定规则有几种切割方式。**
>
> ​	**2.3、子集问题：N 个数的集合里面有多少种符合条件的子集。**
>
> ​	**2.4、排列问题：N 个数按一定规则全排列，有几种排列方式。**
>
> ​	**2.5、棋盘问题：N 皇后、解数独等。**
>
> **3、回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度（每一层的宽度都相同），递归的深度就构成了树的深度。**



### [M77. 组合](https://leetcode.cn/problems/combinations/)

1. 如果采取暴力解决，循环次数就与 k 相关。如 k 为 3 时，外层循环选定一个数，中层循环再选出一个数，内层循环最后选出一个数，构成大小为 3 的组合。因此暴力也没法解决。。。。
2. 与遍历整棵树相同，需要全局变量保存每次计算的临时结果和总结果，当然也可以定义局部变量放到递归参数中传递，但会冗余。在递归参数中，还需要一个变量 startIndex 用来定义下层递归开始时，集合从哪个位置开始 for 循环，避免组合的重复。
3. 而递归的终止条件就是遍历到 “叶子结点” 时，将结果收集起来并返回。在此时，叶子结点就是当 path 数组的大小为 k，进行结果的收集，并终止该层递归。
4. 在单层搜索的过程中（因此实质上每次递归都会用 for 循环来遍历该层的集合），首先从 for 循环中取值并处理该值，然后开始递归处理。递归完成之后进行回溯，撤销上层处理的结果。
5. 可以看出集合的大小 n 构成了树的最大宽度，而结果集的大小也就是递归的最大深度，也是树的最大深度。
6. 注意：局部结果是一直在迭代的，因此收集时需要新 new 一个放入总结果集中。
7. 还会有剪枝操作提高搜索效率，留给二刷的时候优化。



### [M216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

1. 与上题相同，只是限制了集合固定为 [1, 9]，然后在单层搜索逻辑中多一个处理元素的过程。
2. 同样的有剪枝操作，而且比上题好理解，二刷优化。



### [M17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

1. 上述两题中，是求同一个集合中的组合。而该题是求多个不同集合之间的组合，因此每层迭代的集合对象需要更换。
2. 上题中的 startIndex 代表下层开始时从哪里开始，而该题中的 index 则代表下层应该遍历哪个集合。
3. 同时 index 也表示递归层数，当 index 与给定的数字相等时，就意味着递归到了叶子结点，此时收集结果即可。
4. 当然需要同样的全局变量进行局部收集和总体收集。
5. 注意：因为该题收集的是 String 具有不可变性，因此在每次递归之前可以保存该层的 String，将回溯与递归逻辑写在一块。但仅限于不可变的 String，如 List、Array 是不可以用的（不建议回溯递归一块写）。
6. 一定要注意 startIndex 与 index 代表什么意思，传递下去时为了迭代什么。



### [M39. 组合总和](https://leetcode.cn/problems/combination-sum/)

1. 单集合组合问题，需要使用 startIndex 来表示下次遍历时从哪开始，但不用 + 1，因为题中给出了要求可以重复取。
2. 本题中有两个出口，一个是与 target 相等时，记录结果并返回上层。另一个出口是大于 target 时直接返回，而本出口可以在 for 循环中用剪枝来剪掉（同样留给二刷优化）。
3. 注意：第二个出口（未剪枝的情况下）不要写在 for 内，因为是递归的出口而不是跳出 for 循环。



### [M40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

1. 关键在于去重，以 [1, 2A, 2B, 3, 4] 为例，当取 1 时，下层可以继续取 [2, 2, 3, 4]，没有元素重复这个没问题。当取 2A 时，下层可以取 [2B, 3, 4]。当取 2B 时，下层可以取 [3, 4]。这时候就会发现二者存在相同的区间 [3, 4]，就意味着取 2A 时已经将 2B 的结果考虑在内了，因此会出现重复的现象，因为 2A 与 2B 元素不同，但是数值是一样的，构成的集合也存在重复的情况。
2. 注意，2A 与 2B 元素是不同的，只是数值相同而已，可以出现 [2A, 2B, 3] 这样的组合。因此是在同层上进行去重，如果取了 2A，那么就不能再取 2B 了。但是不能在同一树枝上去重，否则就得不到 [2A, 2B, 3] 这种组合了。即同层是不同的组合，而同一树枝是单一组合的内部。
3. 而且去重之前需要先将数组排序，目的是将数值相同的元素挨在一起，在每次同层循环取值时，对比前一个元素是否数值相同了，如果相同则意味着要去重。（即同一层的前一个树枝已经使用过了，因此是在同层的维度上找前一个树枝对比）
4. 去重的两种方式：
    1. 使用 used 数组（全局或传参都可以），初始化为 false。当两个元素相同时，如果 used[前一个元素] 是 false，证明同层已经使用过了（因为每层只能用一个元素，因此为 true 的话有且只有可能是同树枝而非同层，因此取反就是同层）。如果是 true，则说明是同树枝重复使用，且在该树枝的递归内。
    2. 直接用 startIndex，只要是同层内遇到使用过的元素（即排除 startIndex 之后且相等的元素），直接 continue 跳过该元素即可。如 [1A, 1B, 1C]，只使用 1A 就能包括后面其他的 1 元素的情况。
5. 无论哪种去重，首先要将数组内的数值排序，目的是相同的数值相邻，前后两两对比二者是否相同，然后相同的剪枝剪掉。





# 剑指题型 Offer

> **1、线程安全的 LRU**



### [M146. LRU 缓存](https://leetcode.cn/problems/lru-cache)

1. 采用 LinkedHashMap 这种数据结构，该结构的特点是在同一个哈希槽（bucket）中，每个节点之间通过双向链表关联，因此相当于内置了 LRU，方便将节点置顶或沉底
1. LRU 的目的是在访问 key 时，如果命中，则需要将该 key 置顶，也就是通过先 remove 再 put 实现。也就是 LRU 的最经常使用的 key 要放到头部
1. 如果新增 key 时发现容量已满，则需要通过 LinkedHashMap 的自我迭代找到最后面的 key 然后删除，达到最不经常使用的目的

