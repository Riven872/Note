# 数组 Arrays（15）



## 二分查找（5）

> **适用条件：查找元素，且该数组中元素有序、无重复元素，注意区间的开闭**
>
> **时间复杂度 O(n)**
>
> **空间复杂度 O(1)**
>
> **二刷笔记：结束位置一定是 low > high，但要清楚是因为 low 指针右移跳出循环还是因为 high 指针左移跳出了循环**



### E704. 二分查找

1. 适用条件：元素有序、无重复元素、且注意区间的开闭
2. 如果是左闭右闭区间，如 [a, b] 的情况，那么循环条件是 `while(low <= high)`，如果区间换为 [a, b)，相应的循环条件需要更换为 `while(low < high)`，因为在右闭的情况下，low 永远不等于 high，而且如果 `nums[mid] > target` 时，`high = mid`，而非 `high = mid + 1`。
3. 计算中间索引下标时，防止溢出问题。如果 low 与 high 相加大于 MAX_INT 时，会发生溢出。因此可以使用 `mid = low + ((high - low) / 2)` 去解决，几何上的意义就是先计算 low 与 high 距离之间的中间值，然后再加上 0 到 low 的距离即可。



### E35. 搜索插入位置

1. 采用二分法如果没有找到元素时，low 指针指向的就是该元素应该要插入位置的下标。
1. 因为 / 2 采用的是向下取整，因此最后一次循环前，low 与 high 指向同一个元素，且该元素一定比目标值要小（或者相等），最后一轮循环后 low = mid + 1，且 low > high 跳出循环，因此 low 最后停留的位置就是目标值应该在的位置。



### M34. 在排序数组中查找元素的第一个和最后一个位置

1. 二分查找的目的在于找到有序数组中指定元素的下标，那么也可以找到指定元素的前一位或者后一位
2. 因此找左右边界就是找最左侧 target 的前一位下标位置和最右侧 target 的后一位下标位置，在返回时左侧边界 + 1，右侧边界 - 1 即为 target 的第一个出现位置和最后一个出现位置
3. 因此在找左边界时，只要 `target <= nums[mid]` 时，`high = mid - 1`，记录此时 high 的值，如果 `high == target` 则会进入下一轮循环，否则就是 target 第一次出现位置的左边的元素。找右边界时同理。
4. 注意一种特殊情况，就是 target 不在数组中时，此时得出的右边界值 - 左边界值是负数。
5. 二刷笔记：找左边界时，只要 mid 大于或等于 target，就要重新划定边界，直到找不到 mid 与 target 相等的值，就是找到了左边界。（二分查找的思路是只要 mid 大于 target 时，才会重新划定边界）
6. 以左边界为例，最后一次循环时，low 与 high 与 mid 同时指向 target 前一位，循环结束后，high 指针会停留在前一位，而 low 指针会移到后一位去（对应上题，low 指针会指向该元素应该插入的位置）
7. 找左边界时，因为 high 指针左移跳出循环。找右边界时，因为 right 指针右移跳出循环。
8. 三刷笔记：正常二分算法中，如果 target == mid，会直接返回，在找开始索引时，遇到相等的情况会根据找左右边界而移动 low 或 high，区别仅此而已，不难。当循环结束时一定是 low > high，再根据找左右边界的不同进行结果的 + 1、- 1 即可。



### E69. x 的平方根

1. 求某个数的平方根，其解的范围一定是在 `[1, target]` 之中的。因此符合二分查找的元素有序且不重复
2. 当不满足循环条件时，low 和 high 已经互换了位置，因此向下取整的话返回的是 high 的值。
3. 注意第一种特殊情况，如果 target 值接近 MAX_INT，判断时就不能用 mid * mid 与 target 比较，会溢出 int 值，因此需要 mid 与 target / mid 做比较。
4. 注意第二种特殊情况，如果 target 是 0，需要单独处理，以免发生被 0 除的异常
5. 二刷笔记：关键就在于循环结束时，一定（因为是向下取整）是 high 指针左移结束了循环，且左指针位置就是解
6. 三刷笔记：同二刷笔记，向下取整则向前取值，向上取整则向后取值，理解结束循环时的指针位置。



### E367. 有效的完全平方数

1. 思路同上题
2. 因为 int 型的除法是向下取整的，当满足 `mid == num / mid` 时，需要进行 break，将 mid 值进行平方验证（如 mid 为 2，num 为 5 时，`mid == num / mid` 是成立的，但 5 并不是完全平方数，因此需要进行验证）
3. 注意 0 时的特殊情况
4. 三刷笔记：与上题类似，多了一步验证，两题别混淆了。



## 双指针法（5）

> **适用条件：移动或移除数组的元素**
>
> **两个指针从相同的位置出发，可以通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### E27. 移除元素

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，并找到与 target 值相等的元素，慢指针指向的位置用来接收前移的元素，目的是将 target 值覆盖掉。
3. 当快指针指向的元素与 target 相等时，只有快指针后移。当快指针指向的元素与 target 不相等时，慢指针接收快指针的元素，然后慢指针后移。
4. 注意：发生交换后慢指针后后移一位，因此直接返回慢指针就是新数组的长度，不需要再额外 + 1 补足。
5. 二刷笔记：一开始快慢指针是指向头元素的，如果快指针不等于 target 时，快慢指针元素会互换，只不过指向元素是同一个互换没什么区别，只有快指针等于 target 时，快指针才会自己后移。
6. 三刷笔记：快指针的目的在于找出不等于 target 的值并复制到慢指针所指向的位置，慢指针指向的位置是正确的接收位置。



### E26. 删除有序数组中的重复项

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到与慢指针指向元素值不同的元素，因为需要保留唯一的元素，因此慢指针的下一位用来接收前移的元素。
3. 当快指针的元素与慢指针元素相同时，只有快指针后移。当快指针元素与慢指针元素相同时，慢指针后移一位，然后再接收快指针元素。
4. 注意：慢指针是先后移再接收元素，因此返回值需要 + 1 才是新数组的长度
5. 三刷笔记：跟上题类似，比较的是慢指针的值，如果不同，需要慢指针后移一位再复制快指针的元素。



### E283. 移动零

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到不等于 0 的元素。慢指针用来接收非 0 元素。
3. 当快指针指向的元素为 0 时，只有快指针后移。当快指针元素不为 0 时，慢指针接收元素，然后再后移。
4. 思想与 E27 移除元素一毛一样，只不过 target 定死为了 0。
5. 二刷笔记：因为条件是移动而不是移除，因此不能直接移动索引覆盖，而是定义 temp 进行元素的交换。
6. 三刷笔记：因为要求不改变元素顺序，感觉有种冒泡的思想，把 0 不断交换到后面去。同样快指针是遍历元素，慢指针指向位置是接收元素的位置，因此接收完之后需要后移一位。



### E844. 比较含退格的字符串

1. 空间复杂度 1，时间复杂度 n。
2. 使用双指针法分别处理两个字符串，然后再用 `equals()` 去对比
3. 快指针用来遍历整个数组，找到不等于 \# 的元素。慢指针用来接收非 \# 元素。
4. 当快指针为 \# 时，快指针后移一位，慢指针前移一位，相当于退格操作。当快指针不为 \# 时，慢指针接收快指针元素，然后再后移一位。
5. 注意：当慢指针的值为 0 时，就不需要再前移了，否则会发生负越界的情况。
6. 二刷笔记：注意 if 与 else-if 的配合。用 else 时，一定一定一定要看好反转的条件。
7. 三刷笔记：char 数组长度是 final 不可变的，因此需要重新 substring 字符串比较。



### E977. 有序数组的平方

1. 空间复杂度 n，时间复杂度 n。
2. 实际两个指针的作用相同，不算严格意义上的双指针题目。
3. 需要建立新的数组，并逆向添加数据。
4. 条件是递增数组，且数组内有负数和正数，因此头指针可以指向头元素，尾指针指向尾元素。然后头尾元素进行绝对值比较，值比较大的放入新数组的尾部。
5. 也可以处理原始数组，将数组内的所有元素进行平方，但是性能较低，建议还是比较绝对值。
6. 三刷笔记：两个指针一个从头开始一个从尾开始，二者绝对值比较之后相当于降序遍历，因此建立一个数组从尾开始添加数据。而且新数组与旧数组容量一致，完全可以建立数组不用 List 集合去处理。



## 滑动窗口（3）

> **本质上也是一种双指针法，慢指针代表滑动窗口的起始位置，快指针代表滑动窗口的结束位置，不断调节子序列的起始终止位置，达到想要的条件**
>
> **利用了双指针法最核心的思想：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### M209. 长度最小的子数组

1. 空间复杂度 1，时间复杂度 n。
2. 先理解题目：要求的是大于等于 target 即可，不是要最接近。而且要求只返回距离值，不用返回确切的下标。因此只需要每次迭代最短距离，最后返回即可。所以类似一个滑动的窗口将符合要求的值框起来。
3. 快指针代表滑动窗口的终止位置，每次移动时计算滑动窗口内值的总和，当总和大于等于 target 时，迭代滑动窗口的长度，慢指针代表滑动窗口的起始位置，此时向后移一位，并且总和需要减去慢指针原先指向元素的值。
4. 注意：最后需要判断如果最短距离没有赋值，那么直接返回 0 即可。
5. 二刷笔记：当总和 sum >= target 时，需要循环的去移动慢指针，目的是不断的迭代最小长度，直至不满足循环条件，此时快指针会自动后移（即迭代完毕后，快指针会后移而非停止不动，会在 for 循环中自动后移，因此不用单独考虑）。
6. 三刷笔记：当总和 sum >= target 时，需要循环的滑出元素。只要在遍历就可以滑进元素，也可以在 sum >= target 只滑出元素不滑进元素，两种思想都可以，二者只有细小的差别，但是建议使用只要在遍历就可以滑进元素。



### M904. 水果成篮

1. 空间复杂度 n，时间复杂度 n。
2. 慢指针代表第一种水果的起始位置，快指针代表第二种水果的结束位置，因此快指针 - 慢指针 + 1 就是滑动窗口的长度，也就是两种水果所占的长度。（即求最长子序列）。
3. 可以用 `HashMap` 结构存储 `<水果种类, 该水果种类连续的个数>`。快指针进行遍历整个数组，当水果种类不大于 2 时，根据快指针元素进行填装 `HashMap`，当水果种类大于 2（即 `HashMap` 的 size > 2 时），慢指针根据 `HashMap` 中该水果种类的连续个数进行**连续后移**，连续后移完毕后，该水果种类连续的个数的值会变为 0，这时删除 `HashMap` 中该水果的种类。
4. 每当一种水果种类移除之后（也即慢指针连续后移至新种类水果的索引位置），进行滑动窗口长度的迭代。
5. 二刷笔记：当水果种类不大于 2 时，就要进行长度的迭代（也顺手解决了水果只有一种的情况），此时慢指针还未移动，而快指针正好指向第二个水果的结束位置。一旦快指针指向了第三种水果，也就意味着开始往 `HashMap` 里添加水果种类了。也表明了最长子序列的长度是慢慢增加至峰值，而不是一次性计算就得出来的。
6. 三刷笔记：同样的，因为 `HashMap` 容量大于 2 时需要循环后移慢指针，因此只要在遍历就往 `HashMap` 中添加元素。当某个 value 小于 1 时，及时从 `HashMap` 中 remove 掉该 key。



### H76. 最小覆盖子串

1. 空间复杂度 `t.length` ，时间复杂度 `t.length + s.length`。
2. 首先遍历子串，用 `HashMap` 结构存储 `<子串中的字符, 该字符目前的需求量>`。
3. 快指针代表滑动窗口的结束位置，慢指针代表滑动窗口的起始位置，滑动窗口内的子串就是最佳匹配的子串。
4. 快指针遍历字符串，当遇到子串内某个元素时，该元素的需求量就减一（只有当该元素需求量大于 0 减一时，总需求量才减一，否则只是表明需求缺口过多，总需求量已经减过一了）。直到窗口完全包含子串时（即总需求量为 0 时），进行最佳子串的迭代，迭代完成后判断慢指针是否为子串内的某个元素，如果是则该元素的需求量就加一（只有当该元素需求量大于等于 0 加一时，总需求量才加一，否则表明需求盈余过多，总需求量已经加过一了），然后慢指针右移一位。
5. 快指针还代表滑动窗口的右端新增一个字符，这时候需要判断该字符是否是所需要的，如果是需要的继续判断是否需求量 > 0，进而决定总需求量是否发生变化。
6. 同理，慢指针也代表滑动窗口左端滑出一个字符，这时候需要判断该字符是否是所需要的，如果是所需要的继续判断是否需求量 >= 0，进而决定总需求量是否发生变化。
7. 二刷笔记：记住 `HashMap` 中正数代表缺，负数代表不缺，因此需要判断在对正数操作时，才会对 need 总需求操作。而且一定要先判断是否要操作总需求量，然后再进行字符目前需求的加减，顺序反了会影响判断（千万别反了！！！）。迭代新子序列时，判断要么为空串要么比上个串的长度小即可，迭代完之后开始移动慢指针。总结就一句话：滑动窗口新增移除（滑进滑出）元素时，先看自身需求量从而决定是否操作总需求量，然后再新增移除（滑进滑出）。
8. 三刷笔记：滑进滑出元素时的操作几乎一样，但当滑出元素时，此元素的需求量为 0 也需要考虑在内。先判断该元素的存量，再决定总需求量是否变化。



## 螺旋矩阵（2）

> **模拟螺旋矩阵的顺时针的生成过程，不涉及算法。**
>
> **关键在于边界值的寻找。**



### M59. 螺旋矩阵 II

1. 空间复杂度 1，时间复杂度 n²。
2. 采用主流思想，左闭右开区间，即假如生成 5 阶矩阵，以第一圈为例，最上侧从左到右连续生成 4 个元素 [0, 5)，接下来的右侧从上到下连续生成也是 4 个元素。到了第二圈时，变成连续生成 2 个元素。
3. 循环的圈数一定是 n / 2，因为一圈过后，左右、上下同时少了两个元素，因此行或列的一半即可完成循环。
4. 因为是二维矩阵，因此从左到右和从右到左生成元素时，行不变，列进行变化。反之。
5. 可以把二维数组想成两条数轴（一条水平，一条垂直），start 的目的是第 1 圈时，起始位置为 0。一圈过后，只从水平或垂直的角度来看，只是 start 后移了一位而已（因为生成元素时，必定有一维是固定的，因此观感上可以这么看）。
6. 注意特殊情况，如果是奇数矩阵，那么中间的元素需要额外手动填充（循环结束后可以直接拿到行和列的索引以及需要填充的值，直接代入即可）。
7. 二刷笔记：也可以通过 offset 变量来控制，每次循环完一圈后，下次生成元素要减少的偏移量
8. 三刷笔记：start 作用在于每次循环开始时，给定的一个标准，然后 i j 根据每一圈的标准开始生成矩阵。



### M54. 螺旋矩阵

1. 空间复杂度 1，时间复杂度 m * n。
2. 比上题要难，思路相同。新增了一些变量用来理解题目，也可以优化成上题（为了便于理解还是保留了）。因为 loop 是减法迭代，所以新增 offset 表示圈数也正好表示偏移量。mid 用来记录循环次数且不会迭代，用来处理特殊情况。start 仍然表示该次循环从哪个索引下标开始，同时 offset 用来指示循环边界值。
3. 循环的圈数为行或列中最小值的一半。
4. 特殊情况一：单行单列时，loop 为 0，直接打印单行或单列的元素即可。（单行单列也满足行或列最小值为奇数）
5. 特殊情况二：行或列最小值有奇数时，根据 mid（也就是没经过迭代的 loop）去打印上述循环中没有打印的值。保证了即使经过了上面的循环，也因为 mid 值的存在不会打印重复的值。
6. 二刷笔记：主要还是处理特殊情况部分，利用好 start 与 mid 值。start 只需要一个原因是，该 start 点只是用来标记左上角开始的位置，只要确定了开始的位置，每次迭代都是采用左闭右开的区间，因此不必再考虑其他的定位点。循环完一圈后，start 会成为新一轮的定位点，因此只要左上角开始的定位点即可。
7. 三刷笔记：单行或单列跟特殊情况是一致的，都是只剩下某一行或某一列没有打印，区别就是最小奇数行列需要一个标志位来避免打印已经循环的位置，就是 mid（循环次数），减去循环次数即可。



# 链表 Linkedlists（7）

> **处理结点之间的关系，如新增、删除等，常与双指针法结合考察**



## 标准题型（7）

> **无分类题型**



### E203.移除链表元素

1. 空间复杂度 1，时间复杂度 n。
2. 通常建立一个哨兵节点，放置在首节点之前方便遍历。然后再建立一个 pre 节点，用来保留前驱地址。
3. 思想类似于双指针法，遍历指针进行遍历时，若不移除遍历指针节点，那么 pre 节点后移指向遍历节点，然后遍历节点才后移，指向下一个节点。如果移除遍历指针节点，遍历节点后移一位，pre 节点指向新的遍历节点即可。
4. 只有当遍历节点为 null 时，才会停止遍历，而不是遍历节点的 next 为 null 时停止。
5. 二刷笔记：如果发生了移除结点的操作，那么 preNode 结点不会后移。



### M707.设计链表

1. 只实现了单链表结构（了解思想之后一定要实操一下，无难度）
2. 单链表中有两个属性：链表长度，哨兵节点（指向下一个节点），通过构造函数初始化链表
3. 链表方法：
    1. 获取指定索引节点的值。
    2. 在链表头部添加节点。
    3. 在链表尾部添加节点。
    4. 在指定的索引位置添加节点。
    5. 删除指定索引的节点。
4. 二刷笔记：还是要注意边界值，哨兵结点索引算 -1，头结点的索引才算是 0。
5. 三刷笔记：因为哨兵结点是手动加的，因此不算真正的计数结点，索引算 -1。记住一个原则，每次循环结束后，currentNode 指向的就是 index 所在的结点，这样不管是新增还是删除都会更明确。



### E206. 反转链表

1. 使用头插法的话，需要考虑哨兵节点以及最后的返回值，因此直接采用双指针法，真正的**原地**反转。
2. 初始状态：current 指针指向 head 节点，pre 指针指向 current 的前驱节点，那么相应的开始时，**pre 指向 null**（因为最后反转完成后，原先的头指针的 next 指向的是 null）。
3. 终止状态：current 指向 null 不满足循环条件，此时 pre 节点指向新的头结点（无哨兵节点）。
4. 每次反转前，先用 temp 保存 current 的下一节点地址，然后进行正常的节点置换即可。
5. 核心思想就是先保存第三个节点的地址，将前两个节点与后面的节点“剥离”开，然后进行置换、指针的后移等。
6. 三刷笔记：
    1. 因为结束条件是 current 指向 null，因此最后正确的头指针应该是 pre 结点。
    2. 原地反转时会影响三个结点，因此需要三个指针标记。




### M24.两两交换链表中的节点

1. 需要建立哨兵节点，以方便交换时有前驱节点的地址。
2. firstNode：交换的第一个节点，secondNode：交换的第二个节点，temp：交换的两个节点后的一个节点，currentNode：遍历节点，初始时指向哨兵节点。
3. 定义好存放临时节点的变量后，进行节点的置换即可。
4. **置换完毕后，currentNode 遍历节点会指向 firstNode 节点的位置。（因为已经完成了置换，因此 firstNode 节点在位置上是第二个节点，作为下一次交换的前驱节点）。**
5. 注意：返回值应该是哨兵节点的后继节点，而不是给定的 head 节点，因为 head 节点初始就与第二个节点交换了，这也是使用哨兵节点的目的之一，保留初始地址。
6. 二刷笔记：不同于上题，该题需要保存四个结点的地址，上题因为是单个结点反转，不是两个结点置换，因此不需要保存额外的结点地址。
7. 三刷笔记：
    1. 错误点还是在于 head 结点已经更换了位置，因此需要提前用哨兵结点保留开头的地址。
    2. 因为会影响四个结点，所以需要四个指针标记。




### M19. 删除链表的倒数第 N 个结点

1. 也可以采用删除正向为第 size - n + 1 个节点的思想，但是下面的解法也结合了这个思想，而且更巧妙。而且双指针法正是解决了两个循环需要做的事。
2. 使用双指针法。快指针首先移动 n 个节点（也是从哨兵节点开始），然后慢指针从 0 开始（因此需要建立哨兵指针），两个指针同时后移，当快指针到达尾部时（最后一个节点，而不是 null 处），慢指针正好停留在指定的倒数第 n -1 的位置上。
3. 原理：可以继续利用距离来理解，慢指针相当于走了 size - n 的距离，符合正向的思想。快指针首先走了 n 个之后，慢指针才同步移动，而且快指针在 size 时结束，即 size - n。
4. **还是要注意边界值！！！！**
5. 注意：
    1. 循环结束的条件为快指针的 next 不为 null，这样正好解决了特殊情况。
    2. 最后删除节点时，只有慢指针操作，快指针只用来遍历。`slowIndex.next = slowIndex.next.next;`
6. 二刷笔记：不用计算该链表的长度，快结点剩余走的路程 size - n，就是慢结点要走的路程，已经用快结点提前铺好路了。
7. 三刷笔记：快结点需要先走一段距离，然后两个结点同步走即可。



### E160. 相交链表

1. 如果两条链表长度相同，那么依次比较即可。因此核心思想是处理两条链表遍历的长度相同。而且相交的部分是在后面，因此长链表的前部分节点是冗余的，先行遍历掉。
2. 首先遍历出两条链表的长度，得到两条链表的 gap，长链表先遍历 gap 的部分，进行两条链表的对齐。
3. 对齐之后两条链表的节点一一比对即可。
4. 注意：比对的是节点本身，而不是节点存储的数据。
5. 关于 A 与 B 链表的长度对比之后遍历冗余节点有优化方法。（可以看看解析）
6. 二刷笔记：根据两条链表的长度可以灵活更改头指针，可以只写一次遍历即可，思想没变化。
7. 三刷笔记：加不加哨兵结点没有影响。



### M142. 环形链表 II

1. **链表典型题：判定链表内是否有环且找到环的入口**
2. 采用双指针法，慢指针每次移动 1 个节点，快指针每次移动 2 个节点，如果链表有环，那么两个指针一定会在环中相遇。
3. 假定从头结点到环形入口结点之间的结点数为 x，从环形入口结点到相遇结点之间的结点数为 y，从相遇结点到环形入口结点之间的结点数为 z，在环内走了 n 圈两个指针才相遇。
4. 得出 x + y = x + y + (z + y) * n。左边为慢指针走的结点数，右边为快指针走的结点数。因为快指针的速度是大于慢指针的，因此是 x + y 之后才开始在圈内循环。整理之后为：x = (n - 1) (y + z) + z。（求 x 就是环形入口的索引）
5. 从公式可以看出，当 n 为 1 时，x = z，根据假设的定义，相当于**从头结点到环形入口结点之间的结点数 = 从相遇点到环形入口之间的结点数**，因此 n 为 1 时，仅仅是快指针在环内走了一圈，n 大于 1 时多走了几圈而已。
6. 最终，定义一个指针从头结点出发一步步走，定义一个指针从相遇点出发一步步走，二者再次相遇时，就是环形的入口。
7. 思路：
    1. 首先确定是否有环。
    2. 有环时，找到相遇的点。
    3. 从相遇的点出发，每次都只移动一个结点，相遇时就是环形入口。
8. 二刷笔记：该题不能建立哨兵结点，会超时，没懂为啥TnT。
9. 三刷笔记：
    1. 不能以 `slowNode == fastNode` 作为循环条件，会超时。
    2. 应该在循环内判断只要两个指针重合就进行找入口的操作。


# 哈希表 HashTables（11）

> **哈希法使用空间换时间，适用于快速判断一个元素是否出现在集合中，搜索量级为 O(1)**
>
> **主要方法会手写哈希数据结构，进行数据与索引的映射**



## 字母异位词（4）

> **该题型隐性的规则就是，字母及其个数相同的词，不管词中字母顺序如何，哈希值是相同的。**
>
> **题目中说明了只有小写字母，因此可以采用简单数组作为哈希容器，大小为 26，数组中的值为字母出现的次数，适用于低时间复杂度。**
>
> **也可以采用标准的 HashMap，因为每个异位词排序后的词是相同的，因此可以将串转换为 char 数组排序后作为 key，value 作为相同哈希值共同的桶，适用于低空间复杂度。**
>
> **注意：如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费！**



### E242. 有效的字母异位词

1. 使用数组当做简单的哈希表。数组下标为元素映射的索引，数组内存的数据为该元素的映射次数。
2. 因为是小写字母比较，因此建立长度为 26 的数组，映射关系为 "元素 char 值取模 26"。不必使元素 a 一定处于下标 0 的位置，只需要一个相对的位置即可，查询时会通过映射关系找到对应的下标，再通过下标找到数组内的数值，即可表示出当前元素出现的次数。
3. 将第一个字符串放入数组后，另一个字符串通过相同的映射关系，每有一个元素映射，数组值就减一。当所有元素映射完毕后，再遍历哈希数组，如果数组内的所有值都为 0，说明二者包含的元素个数和种类是相同的。
4. 此类型的题目给出了条件：字符串只有小写英文字母，因此建立的哈希表大小为 26。



### E383. 赎金信

1. 思路与上题完全一致，但是可以优化一下步骤（可以不用所有元素映射完之后再去遍历，可以映射一个就判断一下是否为负数）。



### M49. 字母异位词分组

1. 思路相同，但是容器采用标准库的 HashMap。
2. 题目要求含字母相同的词作为统一映射，因此得出映射关系，只要含有相同的词且个数相同即可，顺序忽略，故可以将候选词汇转换成 char 数组之后排序，这样有相同字母的词就会有相同的哈希值。
3. 关键还是找映射关系（即找相同点，有相同点的词放入一个 “桶” 中，也即哈希值相同），哈希容器采用标准库。
4. 也可以采用数组建立简单的哈希容器，建立容器思想也相通。
5. 三刷笔记：字符串排序之后就是 HashMap 中的 key 。



### M438. 找到字符串中所有字母异位词

1. 滑动窗口 + 哈希表，依然是对比两串的哈希值是否相同。
2. 首先将标准串中的字母及其个数放入一个自定义的 26 大小的哈希数组中。
3. 然后建立一个子串数组用来对比标准数据。快指针每次遍历，都会滑进元素，因此需要增加新元素的个数，每次新增完毕后，对比两个哈希数组是否相同，如果相同则记录慢指针的位置就是子串的起始索引。
4. 标准串是给定的，因此滑动窗口的大小也是固定的，当窗口大小不符合要求时，才会移动慢指针，此时会滑出元素，因此需要减少滑出元素的个数。
5. 注意：不建议使用上题的通过排序来找到相同哈希值的方法，因为库函数的排序在大数据量下会超时，而手动建立简单哈希数组会牺牲空间换时间。
6. 二刷笔记：快指针遍历时用的是 for 循环，因此可以先判断是否滑动窗口过长移动慢指针然后再比较两个数组，也可以先假定快指针移动后是否大于滑动窗口大小。注意滑动窗口大小的计算。也会用到对比两个数组的库函数  `Arrays.equals()`
7. 三刷笔记：遗忘点还是在于要使用 `Arrays.equals()`，如果采用字符串排序的话选哈希槽的话，会超时。



## 两个数组的交集（2）

> **HashSet 有其元素唯一的性质，因此可以采用标准的 HashSet 来完成找出交集元素且返回值唯一的操作。**
>
> **简单哈希数组效率依然高于 HashSet，但是仅限于哈希值比较少的情况。**



### E349. 两个数组的交集

1. 本题使用标准的 `HashSet` 解决，因为题目修正限制 1000 个元素（哈希值较少），所以也可以建立大小为 1000 的哈希数组，采用数组解决。
2. 使用 `HashSet` 存放 A 数组的值，然后遍历 B 数组，只要 `HashSet` 中也包含 B 数组中的元素，就往返回值 `HashSet` 中添加该元素即可。
3. 因为 `HashSet` 本身的性质，因此返回值 `HashSet` 中的值也是唯一的。
4. 二刷笔记：第一次用 `HashSet` 用来筛选出标准数组中唯一的元素，第二次用 `HashSet` 的 contains 时，使对比数组中相同的元素，加入返回 `HashSet` 中。不能用 `!add()` 去判断。



### E350. 两个数组的交集 II

1. 可以使用 `HashMap` 或者简单数组作为哈希容器，本次解决使用 `HashMap`。
2. 首先使用 `HashMap` 存储数组 A 内的数字及其出现的频次。然后遍历数组 B，若数组  B 的元素也为 key 且频次大于 0，就将该元素放入返回值列表中，并将频次减一。
3. **频次减一是为了返回出现次数较少的频次**
4. 也可以将两个数组排序，然后使用双指针法。
5. 二刷笔记：`HashMap` 中首次放入标准数组频次，当遍历对比数组时，如果有相同的 key 则会消耗频次，如果对比数组频次消耗至 0 则说明标准数组的频次是最低的，如果还未消耗至 0 则会因为标准数组的频次先消耗完毕无法添加返回值。
6. 三刷笔记：
    1. 遇到相同的元素，放一次减一次即可，大于 0 的数量就是在二者出现中较少的一次。
    2. 核心是找一个元素是否在另一个数组中也出现过，而且要求统计出现次数，因此还是 `HashMap` 的问题，与 HashSet 关系不大。




## 标准题型（5）



### E202. 快乐数

1. 根据规律，**一个数如果不是快乐数，那么在有限次的循环后，会变成原先的值**，因此适用哈希法的特性，快速判断一个元素是否在集合中出现过。
2. **另一个难点是求每一位的平方值**。需要单独写一个方法，用来计算每一位平方值的和，然后加入到 `HashSet` 中。
3. 当某一次循环后的和为 1 或在 `HashSet` 中出现过时，跳出循环，进而判断 n 是否为 1，从而确定是否为快乐数。
4. 二刷笔记：不需要考虑 n 为 1 的情况，不是特殊情况。



### E1. 两数之和

1. 假设 A  = target - B，因此相当于快速判断 A 元素在集合中出现的位置，适用于哈希表去解决。
2. `HashMap` 的 key 用来存放元素值，value 用来存放该值的索引。元素值可能会相同，但相同时意味着一定二者相加为 target，此时已经返回了结果，而不会向 `HashMap` 中继续添加元素，因此不用担心**重复添加 key 相同的情况**。
3. 遍历数组时往 `HashMap` 中添加数据，同时判断另一个整数是否在 `HashMap` 中，如果在则可以直接返回二者的索引，否则就将该元素添加到 `HashMap` 中。
4. `HashMap` 初始时元素较少不太会匹配到另一个整数，当数据多起来时，自然会找到前面放入 `HashMap` 的元素进行匹配。



### M454. 四数相加 II

1. 时间复杂度: O(n^2)，空间复杂度: O(n^2)。
2. 数组 A、B 看作一个大数组，数组 C、D 看作一个大数组，进而简化成类似两数之和的思想（A + B + C + D = 0，也就是 sum ）。
3. 首先用双循环将 A、B 数组内的值相加并放入 `HashMap` 中，key 为两数之和 sum，value 为该和出现的次数。
4. 然后再用双循环遍历 C、D 数组，取 - sum 为 key，取 `HashMap` 中的 value，value 的次数，就是符合要求的四元组的个数。
5. 注意：不需要为 A、B 两个大数组和 C、D 两个大数组都建立 `HashMap`，只需要用一个 `HashMap` 存放 A、B 大数组的记录即可，C、D 大数组中的值可以一边遍历一边比对。
6. 二刷笔记：vlaue 的值就是匹配的数量，累加即可，不需要再减次数。
7. 三刷笔记：因为比较的是四个数组而且是无序的，因此无法用剪枝捡掉多余的循环。



### M15. 三数之和

1. 时间复杂度: O(n^2)，空间复杂度: 1（如果使用哈希法会增加空间复杂度用于去重）。
2. 不同于上题中，是四个独立的数组中去找四元组，该题只有一个数组，使用双循环哈希判断元组存在并不难，但是无法进行去重处理，因此使用双循环双指针解决该题。
3. 相应的，用双指针法时，先要将数组排序，而且题目要求的是返回数组内的数值而非索引值，这也是可以用双指针法的一个原因。
4. 分为三个指针，外循环遍历指针 i，从 0 开始，慢指针从 0 开始，快指针从数组尾部开始，相当于固定 i 然后找合适的快慢指针的元素。
5. 重要的操作是去重（去重时不用三个元素都取出来之后去重，而是自己与自己比较）：
    1. 去重 i，对比 i 是否与左边的一个元素相同，如果相同则直接开始下一轮循环。
    2. 去重慢指针，慢指针与右边的元素相同时，右移慢指针。
    3. 去重快指针，快指针与左边的元素相同时，左移快指针。
6. 内循环条件是慢指针与指针没有相遇，也达成了三个指针索引不同的条件。当三者之和不为 0 时，视情况移动快慢指针即可。
7. 注：该题也是体现了双指针的优势，将暴力的立方级复杂度降低为平方级。
8. 二刷笔记：注意什么时候需要同时移动快慢指针和各自移动指针。
9. 三刷笔记：
    1. 慢指针从遍历指针的后一位、快指针从尾开始移动可以提高循环效率。
    2. 总和大于 0 时，移动快指针。总和小于 0 时移动慢指针。
    3. 总和为 0 时符合条件，记录坐标，然后在去重双指针的之后移动双指针。




### M18. 四数之和 :star:

1. 时间复杂度: O(n^3)，空间复杂度: 1
2. 思路与上题一样，因为是四个数求和，因此需要在外面再套一层循环。
3. 一级剪枝部分：当首位大于 0 且尾部元素大于 target 时，进行剪枝。二级剪枝部分：两个循环固定的元素相加时大于 target，则没必要再继续进行。
4. 注意：二次循环的初始循环指针，从一层循环的循环指针 +1 开始。并在去重时，避免与一层循环的循环指针重复，从而造成不必要的去重。
5. 利用双指针的优势，将四次方级复杂度降低为了立方级。
6. 二刷笔记：二级去重时，注意不要把一级的也给去了，注意去重的边界值，比一级多一位即可。同样在二级剪枝时，需要同时满足 `nums[i] + nums[j] > target && nums[i] + nums[j] > 0` 时要 break，而非直接 return（原因是还有快慢指针没有进行计算，且快指针是可以在循环变量的左边，而慢指针只能在循环指针的右边，因此该结果并不能直接否定全盘，只是本次不符合条件，因此要用 break，而上题中剪枝是全盘肯定的，因此可以直接 return）。
7. 三刷笔记：
    1. 只要不是最外层循环，去重时要进行 break 而非直接 return。
    2. 因为 target 是不定的，因此剪枝时需要判断是否已经大于 0，然后才大于 target。否则前负后正相加仍然可能等于 target。




# 字符串 Strings（7）



## 标准题型（5）



### E344. 反转字符串

1. 双指针原地反转，无难度。



### E541. 反转字符串 II

1. 首先利用上题作为内置的 API，使字符串在指定位置范围内进行互换。
2. 主要思想：每次循环时，步进不再是 `i++`，而是 `i += 2 * k`，这样**每次循环后，都会划定大小为 2k 的空间**，然后在此空间内进行字符串操作即可。
3. 根据特殊情况总结出，只要满足 k 个字符时，就反转，不管是否剩余总量是否小于 2k 个。因此反转时，先判断 i + k 是否超出了数组长度，如果超出时，那么反转 i 到 length 的元素即可，否则正常反转。
4. 注意：判断内的操作完成之后需要 break（因为 i + k >= length 时，i 仍然小于 length 而在循环中继续操作），否则会重复反转。
5. 注意：边界值要写对，因为索引下标是从 0 开始的。



### O05. 替换空格

1. 要求原地替换不用额外空间，那么需要对原字符串扩容。将该字符串转换为 StringBuilder 后，遍历该字符串，遇到空格时，就 append 两个空格，作为扩容的方法。
2. 设置双指针，旧指针指向扩容前的尾部索引，新指针指向扩容后的尾部索引。
3. 旧指针开始遍历，并将旧指针指向的元素移动到新指针指向的位置，旧指针遇到空格时，新指针添加新元素并单独左移。
4. 双指针都指向结尾元素是因为数组地址是连续地址，从前往后的话会移动大片的元素。



### M151. 反转字符串中的单词

1. 因为使用 `StringBuilder` 申请了额外的空间，不算原地反转。
2. 比较综合的题，不用内部的库函数，自己写三个 API 调用即可。
3. 首先去除原字符串中前导尾随的空格，即可以找到字符串新的起始索引和结束索引。然后利用新的索引进行 `StringBuilder` 的拼接。遍历字符串时，**字符串没有遇到空格或 `StringBuilder` 的结尾不为空格时，即可将遍历到的字符拼接进去**，这样就解决了多个空格转化成一个空格的问题。（因为当字符串为空格，且 `StringBuilder` 的结尾也不为空格时，意味着此时需要拼接一个空格，此时字符串正好遍历到空格，就可以将空格拼接进去。当字符串不为空格而 `StringBuilder` 的结尾为空格时，意味着已经有一个空格了，无须再拼接多个空格，此时就可以跳过原字符串的空格不用拼接进去）。
4. 然后反转整一个已经去除空格的 `StringBuilder`。
5. 最后反转 `StringBuilder` 中的每一个单词即可。（因为空格已经处理完毕，因此以空格为分界线分辨是否为一整个单词）。
6. 注意：因为是先拼接的字符串（原字符串不可变，且数组扩容性能较低，因此采用 `StringBuilder` 拼接来代替扩容），因此其他的私有方法接收的参数都是 `StringBuilder` 类型，而且操作是同一个 `StringBuilder`，因此也不需要返回值。
7. 主要思想：先全部反转，再局部反转。因为字符串是顺序表存储，移动元素会牵扯到后面地址内的元素，性能低，因此采用局部移动降低性能消耗。



### O58.左旋转字符串 II

1. 没有原地反转，申请空间之后无难度，简单拼接字符串即可。



## KMP 算法（2）

> **主要是为了解决：在一个串中是否出现过另外一个串，也就是在文本串中查找是否出现过模式串的串匹配问题。**
>
> 1、构造 Next 数组：（例子：文本串 aabaabaaf，模式串 aabaa）
>
> 1. next 数组的目的是文本串和模式串的某个字符匹配失败时，模式串应回退的**索引下标**位置。
> 2. 在表示回退索引下标的同时，next 数组中的值也表示到该索引所在的元素时，最长相等前后缀的长度。
> 3. 最长相等前后缀的目的在于，当能匹配到 f，就说明 f 之前的 aa 是已经匹配成功的，因此找最长相等前后缀，即找 aa（上一个已经匹配成功的前后缀）的下一个元素进行匹配，如果匹配成功则可以**复用**前后缀，否则继续回退。
> 4. 因为 next 数组要统计所有元素下的最长相等前后缀，因此给 next 赋值时不会因为两字符的相等或不相等跳过赋值。
> 5. 总的来说，目的是为了更好的复用以前已经匹配过的字符，减少匹配次数，因此采用相等前后缀来解决。
>
> 2、文本串与模式串匹配：
>
> 1. 构造 next 数组时，相当于模式串自己与自己匹配，建立数组。
> 2. 文本串与模式串匹配时，不会建立数组。
> 3. 当模式串的指针遍历结束时，**数值正好等于模式串的长度**，此时匹配成功，否则匹配失败。
>
> 3、注意：构造 next 数组时，可能有减一法等，不管任何方法，都注意对比时文本串与模式串开始的位置。一定要注意对比的位置！！！



### M28. 找出字符串中第一个匹配项的下标

1. 不能用滑动窗口+哈希，因为要求的是第一个匹配项的下标，排序后索引会混乱。可以单独用滑动窗口+库函数，此题使用 KMP。
2. KMP 时间复杂度为 O(m + n)，滑动窗口为 O(m * n*)。
3. 构造 next 数组时，j 指针是从 1 开始，而 i 指针是从 0 开始的。但在匹配时，两个指针指向不同的字符串，因此都是从 0 开始。
4. 在两串匹配不相同时，回退的是指向模式串指针前一个元素为索引的 next 数组中的元素位置。且回退是连续回退，而不是只回退一次。
5. 当出现不匹配时，尝试寻找回退位置是否匹配，如果回退位置匹配，则意味着回退之前的元素也匹配，不必从头开始匹配。
6. 与前缀减一的方法区别是：
    1. i 初始为 -1，j 初始为 0，从 0 开始遍历文本串。
    2. 回退时，直接返回指向模式串为索引的 next 数组中的元素位置，而非前一个。




### E459. 重复的子字符串

1. 使用 KMP 算法思想解决。
2. 如果一个串中有重复的子串，那么该串的 next 数组一定是：设重复子串的长度为 x，总长度为 y，索引从 0 到 x 存放的元素都是 0，也就是最长相等前后缀是0，之后索引从 x + 1 到 y 存放的元素数值开始递增。
3. 因此可以得出串的总长度对重复子串取模为 0 时，那么该串是由重复子串组成的。
4. 因为最长相等前后缀是不包括串本身的，因此**重复子串的长度 = 串总长度 - 最长相等前后缀的长度**。其中最长相等前后缀的长度保存在 next 数组的尾部。
5. 注意特殊情况：当 next 数组尾部元素为 0 时，需要直接返回 false。



# 栈与队列 Stacks And Queues（7）



> **栈：**
>
> **1、Stack 类的底层实现基于动态数组，继承自 Vector 类，因此也有线程安全的特性。**
>
> **2、 `Stack` 类使用一个数组来存储元素，并使用一个指针（称为栈顶指针）来指示栈顶元素的位置。当新元素被入栈时，栈顶指针向上移动；当元素被出栈时，栈顶指针向下移动。**
>
> **3、底层数组的大小是动态调整的，当元素数量超过数组大小时，会自动进行扩容。扩容时，`Stack` 类会创建一个更大的数组，并将原数组中的元素复制到新数组中。**
>
> **队列：**
>
> **1、与栈不同，`Queue` 是一个接口，继承自 `Collection`，常用的实现类有 `LinkedList`、`ConcurrentLinkedQueue`、`LinkedBlockingQueue` 、`PriorityQueue`。**
>
> **2、因此实际中，根据性能、线程安全、元素顺序等使用合适的实现类，接口只提供基本的队列操作。**



## 标准题型（5）



### E232. 用栈实现队列

1. **模拟入队时，正常入栈即可**，主要是在模拟出队也就是出栈的时候做文章。
2. 需要实例化两个栈对象，一个作为输入栈，一个作为输出栈。入队时将值压入输入栈中，出队时，将所有输入栈内的值先弹出，然后压入输出栈内，最后输出栈弹栈即可。
3. 新建私有方法，当输出栈为空时，将输入栈内的所有元素压入输出栈内，其中当输出栈内还有元素时，无法将新元素压栈。
4. 其中 pop 弹栈会将栈顶元素返回并删除栈内的元素，而 peek 只是返回栈顶元素并不影响栈内的元素。
5. Stack 自带的基本操作：
    1. `push(E element)`: 将元素压入栈顶。将指定元素添加到栈顶。
    2. `pop()`: 弹出栈顶元素。移除并返回栈顶的元素。
    3. `peek()`: 查看栈顶元素。返回栈顶的元素，但不移除它。
    4. `empty()`: 判断栈是否为空。如果栈为空，返回 true；否则，返回 false。
    5. `search(Object o)`: 查找元素位置。从栈顶开始，返回指定元素相对于栈顶的位置索引。如果元素不在栈中，返回 -1。
    6. Stack 类还继承了 Vector 类的其他方法，比如 `size()`、`isEmpty()`、`contains(Object o)` 等。



### E225. 用队列实现栈

1. **模拟入栈时，正常入队即可**，主要是在模拟出栈也就是出队的时候做文章。
2. 实现类使用 LinkedList
3. 新建私有方法，栈出队时，除了最后一个元素之外，全部重新入队，然后再出队一个元素，就完成了一次模拟出栈的操作。
4. Queue 自带的基本操作：
    1. `boolean add(E e)`: 向队列尾部插入一个元素，如果队列已满则抛出异常。类似于 push。
    2. `boolean offer(E e)`: 向队列尾部插入一个元素，如果队列已满则返回 `false`。
    3. `E remove()`: 移除头部元素并返回，如果队列为空则抛出异常。类似于 pop。
    4. `E poll()`: 移除头部元素并返回，如果队列为空则返回 `null`。
    5. `E element()`: 返回队列头部的元素但不移除，如果队列为空则抛出异常。类似于 peek。
    6. `E peek()`: 返回队列头部的元素但不移除，如果队列为空则返回 `null`。
    7. `boolean isEmpty()`: 判断队列是否为空。
    8. `int size()`: 返回队列中元素的个数。
    9. `boolean contains(Object o)`: 判断队列是否包含指定元素。
    10. `boolean remove(Object o)`: 从队列中移除指定元素。
    11. `void clear()`: 清空队列中的所有元素。



### E20. 有效的括号

1. 需要明白的是：(){} 是合法的，但 ({)} 是不合法的。
2. 遍历整个字符串，是左括号是则入栈，如果遇到右括号，则直接弹栈进行比较，如果不匹配则直接返回 false。
3. 注意特殊情况：
    1. 还没有遍历完成时，栈空，则说明右括号是多余的，此时匹配失败。
    2. 已经遍历完成，栈不空，则说明左括号是多余的，此时也匹配失败。



### E1047. 删除字符串中的所有相邻重复项

1. 思路类似上题，可以采用栈去解决，但栈是反向输出，如果需要正向输出且需要栈的比对方法的话，采用双端队列 Deque 解决。
2. 遍历字符串，将字符从尾部放入队列中。当队列不空时，比较遍历元素与队列尾部元素，如果相同，则该元素出队且 continue 循环，如果不相同则将该元素从尾部放入队列中。
3. 最后使用 StringBuilder 将双端队列中的元素按顺序拼接即可。
4. 注意：不能用双端队列重写的 `toString()` 方法，格式不符合题意。



### M150. 逆波兰表达式求值

1. **栈适用情况：成对的元素需要去匹配时，逆波兰式也是数字与运算符成对的去运算，因此用栈处理。**
2. 思路类似上题，用栈去解决，遇见数字时压栈，遇见运算符时弹栈并运算。
3. 平常使用的表达式是中缀表达式，题目中给的格式为逆波兰表达式。其优点一个是去掉括号后无歧义，一个是适用于栈操作，利于计算机进行运算。
4. 注意：减法与除法运算时，注意两个数字的顺序。



## 单调队列（1）

> **1、优先级队列是将队列中的值进行升序或降序排序，而单调队列是从每个元素入队开始，就要手动维护队列的单调性，使队列的值为单调增或单调减，并使队首元素恒为规定范围内的最大值或最小值。**
>
> **2、与优先级队列的区别是：单调队列在维护单调性时，每次出列的不一定是队列里的最大值或者最小值，而优先级队列因为是堆的缘故，每次出列时只能是队列中的最大值或者最小值**



### H239. 滑动窗口最大值

1. **单调队列需要手动的去维护队列内的顺序**，因此需要根据不同的题目手动写出 push 与 pop 时维护队列的过程。而**优先级队列是堆，会自动排序队列内的元素**
2. 求最大值，因此需要维护一个单调减的单调队列，又因为是滑动的窗口，因此需要考虑元素滑进滑出的情况。该题使用双端队列数据结构解决。
3. 滑进元素时，首先将该元素与队尾元素进行比较，如果该元素较小则直接从尾部入队，如果该元素较大，需要先将队尾元素出队，直至对内元素大于该元素时，才将该元素从尾部加入队列中。
4. 当到达滑动窗口固定值时，首先将队首元素加入最大值数组中，因为此时达成固定滑动窗口值且队首元素经过处理已经是滑动窗口内的最大值。
5. 记录最大值之后，开始滑出元素，如果滑出的该元素恰好是队首元素，那么相应的需要从队列中移除队首元素。
6. **先滑进元素 -> 达成滑动窗口固定值并进行处理 -> 之后滑出元素 -> 最后双索引后移一位，开始下一个窗口**。总是在滑进一个元素后达成指定窗口宽度的条件，而非滑出元素之后。
7. 注意：因为是单调队列，因此滑进元素时，如果该元素等于队首元素，并不会达成该元素大于队首元素的条件，因此不会“清理队列”，直接加入即可。
8. 该题不能用优先级队列的一个原因是，窗口是滑动的，每次滑出的元素是不固定的，而优先级队列每次弹出的元素一定是队列内最大的元素或者是最小的元素。



## 优先级队列（1）

> **1、其实就是堆，因为优先级队列对外就是队首出元素，队尾进元素，看起来跟队列相同，但实质还是堆，利用堆本身的重建让队列有序。但实际使用时，还是 poll、offer 等队列的操作**
>
> **2、无论是大顶堆还是小顶堆，都遵守左大右小的规则，且大顶堆的根结点是大于所有子节点，相应的小顶堆的根结点小于所有的子节点，也就是每个堆的堆头，都是堆内最大的或者是最小的结点。**
>
> **3、具体实现可以使用 PriorityQueue，逻辑上是小顶堆（树形结构），按照自然排序，也可以通过 Comparator 接口进行自定义排序，物理存储是用数组来实现的。**



### M347. 前 K 个高频元素

1. 要取前 K 个元素时，考虑使用大小顶堆（优先级队列）去处理。
2. 首先建立 `HashMap`，将频次与元素一一对应起来。
3. 然后建立优先级队列 `PriorityQueue<int[]>`，并重写 `Comparator` 接口以指定优先级队列按从小到大排序（也就是建立的是小顶堆）。其中优先级队列中每个结点的元素是 int 数组，作用见下。
4. 之后遍历 `HashMap` 中的键值对，并将 K-V 放入临时数组，然后将该数组依次入堆（开始建立小顶堆）。
5. 因为**优先级队列是无界的**，因此容量到 k 时，就开始从队头出队（小顶堆开始弹出最小的元素）。
6. 最后优先级队列内剩下的，就是前 K 大的元素，然后依次遍历，装满 k 个即可。
7. 注意：堆中结点存放的元素根据实际情况来定，本题放入 EntrySet 也行，但是 API 比较复杂，因此转换成 int[2] 数组可以简化操作。所以一定要清楚，堆中的结点要存放什么。
