## 数组 Arrays

### E704. 二分查找

1. 适用条件：元素有序、无重复元素、且注意区间的开闭
2. 如果是左闭右闭区间，如 [a, b] 的情况，那么循环条件是 `while(low <= high)`，如果区间换为 [a, b)，相应的循环条件需要更换为 `while(low < high)`，因为在右闭的情况下，low 永远不等于 high，而且如果 `nums[mid] > target` 时，`high = mid`，而非 `high = mid + 1`。
3. 计算中间索引下标时，防止溢出问题。如果 low 与 high 相加大于 MAX_INT 时，会发生溢出。因此可以使用 `mid = low + ((high - low) / 2)` 去解决，几何上的意义就是先计算 low 与 high 距离之间的中间值，然后再加上 0 到 low 的距离即可。



### E35. 搜索插入位置

1. 采用二分法如果没有找到元素时，low 指针指向的就是该元素应该要插入位置的下标



### M34. 在排序数组中查找元素的第一个和最后一个位置

1. 二分查找的目的在于找到有序数组中指定元素的下标，那么也可以找到指定元素的前一位或者后一位
2. 因此找左右边界就是找最左侧 target 的前一位下标位置和最右侧 target 的后一位下标位置，在返回时左侧边界 + 1，右侧边界 - 1 即为 target 的第一个出现位置和最后一个出现位置
3. 因此在找左边界时，只要 `target <= nums[mid]` 时，`high = mid - 1`，记录此时 high 的值，如果 `high == target` 则会进入下一轮循环，否则就是 target 第一次出现位置的左边的元素。找右边界时同理。
4. 注意一种特殊情况，就是 target 不在数组中时，此时得出的右边界值 - 左边界值是负数



### E69. x 的平方根

1. 求某个数的平方根，其解的范围一定是在 `[0, target]` 之中的。因此符合二分查找的元素有序且不重复
2. 当不满足循环条件时，low 和 high 已经互换了位置，因此向下取整的话返回的是 high 的值
3. 注意第一种特殊情况，如果 target 值接近 MAX_INT，判断时就不能用 mid * mid 与 target 比较，会溢出 int 值，因此需要 mid 与 target / mid 做比较。
4. 注意第二种特殊情况，如果 target 是 0，需要单独处理，以免发生被 0 除的异常



### E367. 有效的完全平方数

1. 思路同上题
2. 因为 int 型的除法是向下取整的，当满足 `mid == num / mid` 时，需要进行 break，将 mid 值进行平方验证（如 mid 为 2，num 为 5 时，`mid == num / mid` 是成立的，但 5 并不是完全平方数，因此需要进行验证）
3. 注意 0 时的特殊情况