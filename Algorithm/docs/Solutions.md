# 数组 Arrays



## 二分查找

> **适用条件：查找元素，且该数组中元素有序、无重复元素，注意区间的开闭**
>
> **时间复杂度 O(n)**
>
> **空间复杂度 O(1)**
>
> **二刷笔记：结束位置一定是 low > high，但要清楚是因为 low 指针右移跳出循环还是因为 high 指针左移跳出了循环**



### E704. 二分查找

1. 适用条件：元素有序、无重复元素、且注意区间的开闭
2. 如果是左闭右闭区间，如 [a, b] 的情况，那么循环条件是 `while(low <= high)`，如果区间换为 [a, b)，相应的循环条件需要更换为 `while(low < high)`，因为在右闭的情况下，low 永远不等于 high，而且如果 `nums[mid] > target` 时，`high = mid`，而非 `high = mid + 1`。
3. 计算中间索引下标时，防止溢出问题。如果 low 与 high 相加大于 MAX_INT 时，会发生溢出。因此可以使用 `mid = low + ((high - low) / 2)` 去解决，几何上的意义就是先计算 low 与 high 距离之间的中间值，然后再加上 0 到 low 的距离即可。



### E35. 搜索插入位置

1. 采用二分法如果没有找到元素时，low 指针指向的就是该元素应该要插入位置的下标。
1. 因为 / 2 采用的是向下取整，因此最后一次循环前，low 与 high 指向同一个元素，且该元素一定比目标值要小（或者相等），最后一轮循环后 low = mid + 1，且 low > high 跳出循环，因此 low 最后停留的位置就是目标值应该在的位置。



### M34. 在排序数组中查找元素的第一个和最后一个位置

1. 二分查找的目的在于找到有序数组中指定元素的下标，那么也可以找到指定元素的前一位或者后一位
2. 因此找左右边界就是找最左侧 target 的前一位下标位置和最右侧 target 的后一位下标位置，在返回时左侧边界 + 1，右侧边界 - 1 即为 target 的第一个出现位置和最后一个出现位置
3. 因此在找左边界时，只要 `target <= nums[mid]` 时，`high = mid - 1`，记录此时 high 的值，如果 `high == target` 则会进入下一轮循环，否则就是 target 第一次出现位置的左边的元素。找右边界时同理。
4. 注意一种特殊情况，就是 target 不在数组中时，此时得出的右边界值 - 左边界值是负数。
5. 二刷笔记：找左边界时，只要 mid 大于或等于 target，就要重新划定边界，直到找不到 mid 与 target 相等的值，就是找到了左边界。（二分查找的思路是只要 mid 大于 target 时，才会重新划定边界）
6. 以左边界为例，最后一次循环时，low 与 high 与 mid 同时指向 target 前一位，循环结束后，high 指针会停留在前一位，而 low 指针会移到后一位去（对应上题，low 指针会指向该元素应该插入的位置）
7. 找左边界时，因为 high 指针左移跳出循环。找右边界时，因为 right 指针右移跳出循环。



### E69. x 的平方根

1. 求某个数的平方根，其解的范围一定是在 `[1, target]` 之中的。因此符合二分查找的元素有序且不重复
2. 当不满足循环条件时，low 和 high 已经互换了位置，因此向下取整的话返回的是 high 的值。
3. 注意第一种特殊情况，如果 target 值接近 MAX_INT，判断时就不能用 mid * mid 与 target 比较，会溢出 int 值，因此需要 mid 与 target / mid 做比较。
4. 注意第二种特殊情况，如果 target 是 0，需要单独处理，以免发生被 0 除的异常
5. 二刷笔记：关键就在于循环结束时，一定（因为是向下取整）是 high 指针左移结束了循环，且左指针位置就是解



### E367. 有效的完全平方数

1. 思路同上题
2. 因为 int 型的除法是向下取整的，当满足 `mid == num / mid` 时，需要进行 break，将 mid 值进行平方验证（如 mid 为 2，num 为 5 时，`mid == num / mid` 是成立的，但 5 并不是完全平方数，因此需要进行验证）
3. 注意 0 时的特殊情况



## 双指针法

> **适用条件：移动或移除数组的元素**
>
> **两个指针从相同的位置出发，可以通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### E27. 移除元素

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，并找到与 target 值相等的元素，慢指针指向的位置用来接收前移的元素，目的是将 target 值覆盖掉。
3. 当快指针指向的元素与 target 相等时，只有快指针后移。当快指针指向的元素与 target 不相等时，慢指针接收快指针的元素，然后慢指针后移。
4. 注意：发生交换后慢指针后后移一位，因此直接返回慢指针就是新数组的长度，不需要再额外 + 1 补足。
5. 二刷笔记：一开始快慢指针是指向头元素的，如果快指针不等于 target 时，快慢指针元素会互换，只不过指向元素是同一个互换没什么区别，只有快指针等于 target 时，快指针才会自己后移。



### E26. 删除有序数组中的重复项

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到与慢指针指向元素值不同的元素，因为需要保留唯一的元素，因此慢指针的下一位用来接收前移的元素。
3. 当快指针的元素与慢指针元素相同时，只有快指针后移。当快指针元素与慢指针元素相同时，慢指针后移一位，然后再接收快指针元素。
4. 注意：慢指针是先后移再接收元素，因此返回值需要 + 1 才是新数组的长度



### E283. 移动零

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到不等于 0 的元素。慢指针用来接收非 0 元素。
3. 当快指针指向的元素为 0 时，只有快指针后移。当快指针元素不为 0 时，慢指针接收元素，然后再后移。
4. 思想与 E27 移除元素一毛一样，只不过 target 定死为了 0。
5. 二刷笔记：因为条件是移动而不是移除，因此不能直接移动索引覆盖，而是定义 temp 进行元素的交换。



### E844. 比较含退格的字符串

1. 空间复杂度 1，时间复杂度 n。
2. 使用双指针法分别处理两个字符串，然后再用 `equals()` 去对比
3. 快指针用来遍历整个数组，找到不等于 \# 的元素。慢指针用来接收非 \# 元素。
4. 当快指针为 \# 时，快指针后移一位，慢指针前移一位，相当于退格操作。当快指针不为 \# 时，慢指针接收快指针元素，然后再后移一位。
5. 注意：当慢指针的值为 0 时，就不需要再前移了，否则会发生负越界的情况。
6. 二刷笔记：注意 if 与 else-if 的配合。用 else 时，一定一定一定要看好反转的条件。



### E977. 有序数组的平方

1. 空间复杂度 n，时间复杂度 n。
2. 实际两个指针的作用相同，不算严格意义上的双指针题目。
3. 需要建立新的数组，并逆向添加数据。
4. 条件是递增数组，且数组内有负数和正数，因此头指针可以指向头元素，尾指针指向尾元素。然后头尾元素进行绝对值比较，值比较大的放入新数组的尾部。
5. 也可以处理原始数组，将数组内的所有元素进行平方，但是性能较低，建议还是比较绝对值。



## 滑动窗口

> **本质上也是一种双指针法，慢指针代表滑动窗口的起始位置，快指针代表滑动窗口的结束位置，不断调节子序列的起始终止位置，达到想要的条件**
>
> **利用了双指针法最核心的思想：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### M209. 长度最小的子数组

1. 空间复杂度 1，时间复杂度 n。
2. 先理解题目：要求的是大于等于 target 即可，不是要最接近。而且要求只返回距离值，不用返回确切的下标。因此只需要每次迭代最短距离，最后返回即可。所以类似一个滑动的窗口将符合要求的值框起来。
3. 快指针代表滑动窗口的终止位置，每次移动时计算滑动窗口内值的总和，当总和大于等于 target 时，迭代滑动窗口的长度，慢指针代表滑动窗口的起始位置，此时向后移一位，并且总和需要减去慢指针原先指向元素的值。
4. 注意：最后需要判断如果最短距离没有赋值，那么直接返回 0 即可。
5. 二刷笔记：当总和 sum >= target 时，需要循环的去移动慢指针，目的是不断的迭代最小长度，直至不满足循环条件，此时快指针会自动后移（即迭代完毕后，快指针会后移而非停止不动，会在 for 循环中自动后移，因此不用单独考虑）。



### M904. 水果成篮

1. 空间复杂度 n，时间复杂度 n。
2. 慢指针代表第一种水果的起始位置，快指针代表第二种水果的结束位置，因此快指针 - 慢指针 + 1 就是滑动窗口的长度，也就是两种水果所占的长度。（即求最长子序列）。
3. 可以用 `HashMap` 结构存储 `<水果种类, 该水果种类连续的个数>`。快指针进行遍历整个数组，当水果种类不大于 2 时，根据快指针元素进行填装 `HashMap`，当水果种类大于 2（即 `HashMap` 的 size > 2 时），慢指针根据 `HashMap` 中该水果种类的连续个数进行**连续后移**，连续后移完毕后，该水果种类连续的个数的值会变为 0，这时删除 `HashMap` 中该水果的种类。
4. 每当一种水果种类移除之后（也即慢指针连续后移至新种类水果的索引位置），进行滑动窗口长度的迭代。
5. 二刷笔记：当水果种类不大于 2 时，就要进行长度的迭代（也顺手解决了水果只有一种的情况），此时慢指针还未移动，而快指针正好指向第二个水果的结束位置。一旦快指针指向了第三种水果，也就意味着开始往 `HashMap` 里添加水果种类了。也表明了最长子序列的长度是慢慢增加至峰值，而不是一次性计算就得出来的。



### H76. 最小覆盖子串

1. 空间复杂度 `t.length` ，时间复杂度 `t.length + s.length`。
2. 首先遍历子串，用 `HashMap` 结构存储 `<子串中的字符, 该字符目前的需求量>`。
3. 快指针代表滑动窗口的结束位置，慢指针代表滑动窗口的起始位置，滑动窗口内的子串就是最佳匹配的子串。
4. 快指针遍历字符串，当遇到子串内某个元素时，该元素的需求量就减一（只有当该元素需求量大于 0 减一时，总需求量才减一，否则只是表明需求缺口过多，总需求量已经减过一了）。直到窗口完全包含子串时（即总需求量为 0 时），进行最佳子串的迭代，迭代完成后判断慢指针是否为子串内的某个元素，如果是则该元素的需求量就加一（只有当该元素需求量大于等于 0 加一时，总需求量才加一，否则表明需求盈余过多，总需求量已经加过一了），然后慢指针右移一位。
5. 快指针还代表滑动窗口的右端新增一个字符，这时候需要判断该字符是否是所需要的，如果是需要的继续判断是否需求量 > 0，进而决定总需求量是否发生变化。
6. 同理，慢指针也代表滑动窗口左端滑出一个字符，这时候需要判断该字符是否是所需要的，如果是所需要的继续判断是否需求量 >= 0，进而决定总需求量是否发生变化。
7. 二刷笔记：记住 `HashMap` 中正数代表缺，负数代表不缺，因此需要判断在对正数操作时，才会对 need 总需求操作。而且一定要先判断是否要操作总需求量，然后再进行字符目前需求的加减，顺序反了会影响判断（千万别反了！！！）。迭代新子序列时，判断要么为空串要么比上个串的长度小即可，迭代完之后开始移动慢指针。总结就一句话：滑动窗口新增移除（滑进滑出）元素时，先看自身需求量从而决定是否操作总需求量，然后再新增移除（滑进滑出）。



## 螺旋矩阵

> **模拟螺旋矩阵的顺时针的生成过程，不涉及算法。**
>
> **关键在于边界值的寻找。**



### M59. 螺旋矩阵 II

1. 空间复杂度 1，时间复杂度 n²。
2. 采用主流思想，左闭右开区间，即假如生成 5 阶矩阵，以第一圈为例，最上侧从左到右连续生成 4 个元素 [0, 5)，接下来的右侧从上到下连续生成也是 4 个元素。到了第二圈时，变成连续生成 2 个元素。
3. 循环的圈数一定是 n / 2，因为一圈过后，左右、上下同时少了两个元素，因此行或列的一半即可完成循环。
4. 因为是二维矩阵，因此从左到右和从右到左生成元素时，行不变，列进行变化。反之。
5. 可以把二维数组想成两条数轴（一条水平，一条垂直），start 的目的是第 1 圈时，起始位置为 0。一圈过后，只从水平或垂直的角度来看，只是 start 后移了一位而已（因为生成元素时，必定有一维是固定的，因此观感上可以这么看）。
6. 注意特殊情况，如果是奇数矩阵，那么中间的元素需要额外手动填充（循环结束后可以直接拿到行和列的索引以及需要填充的值，直接代入即可）。
7. 二刷笔记：也可以通过 offset 变量来控制，每次循环完一圈后，下次生成元素要减少的偏移量



### M54. 螺旋矩阵

1. 空间复杂度 1，时间复杂度 m * n。
2. 比上题要难，思路相同。新增了一些变量用来理解题目，也可以优化成上题（为了便于理解还是保留了）。因为 loop 是减法迭代，所以新增 offset 表示圈数也正好表示偏移量。mid 用来记录循环次数且不会迭代，用来处理特殊情况。start 仍然表示该次循环从哪个索引下标开始，同时 offset 用来指示循环边界值。
3. 循环的圈数为行或列中最小值的一半。
4. 特殊情况一：单行单列时，loop 为 0，直接打印单行或单列的元素即可。（单行单列也满足行或列最小值为奇数）
5. 特殊情况二：行或列最小值有奇数时，根据 mid（也就是没经过迭代的 loop）去打印上述循环中没有打印的值。保证了即使经过了上面的循环，也因为 mid 值的存在不会打印重复的值。
6. 二刷笔记：主要还是处理特殊情况部分，利用好 start 与 mid 值。start 只需要一个原因是，该 start 点只是用来标记左上角开始的位置，只要确定了开始的位置，每次迭代都是采用左闭右开的区间，因此不必再考虑其他的定位点。循环完一圈后，start 会成为新一轮的定位点，因此只要左上角开始的定位点即可。



# 链表 Linkedlists

> **处理结点之间的关系，如新增、删除等，常与双指针法结合考察**



## 标准题型

> **无分类题型**



### E203.移除链表元素

1. 空间复杂度 1，时间复杂度 n。
2. 通常建立一个哨兵节点，放置在首节点之前方便遍历。然后再建立一个 pre 节点，用来保留前驱地址。
3. 思想类似于双指针法，遍历指针进行遍历时，若不移除遍历指针节点，那么 pre 节点后移指向遍历节点，然后遍历节点才后移，指向下一个节点。如果移除遍历指针节点，遍历节点后移一位，pre 节点指向新的遍历节点即可。
4. 只有当遍历节点为 null 时，才会停止遍历，而不是遍历节点的 next 为 null 时停止。



### M707.设计链表

1. 只实现了单链表结构（了解思想之后一定要实操一下，无难度）
2. 单链表中有两个属性：链表长度，哨兵节点（指向下一个节点），通过构造函数初始化链表
3. 链表方法：
    1. 获取指定索引节点的值。
    2. 在链表头部添加节点。
    3. 在链表尾部添加节点。
    4. 在指定的索引位置添加节点。
    5. 删除指定索引的节点。



### E206. 反转链表

1. 使用头插法的话，需要考虑哨兵节点以及最后的返回值，因此直接采用双指针法，真正的**原地**反转。
2. 初始状态：current 指针指向 head 节点，pre 指针指向 current 的前驱节点，那么相应的开始时，**pre 指向 null**（因为最后反转完成后，原先的头指针的 next 指向的是 null）。
3. 终止状态：current 指向 null 不满足循环条件，此时 pre 节点指向新的头结点（无哨兵节点）。
4. 每次反转前，先用 temp 保存 current 的下一节点地址，然后进行正常的节点置换即可。
5. 核心思想就是先保存第三个节点的地址，将前两个节点与后面的节点“剥离”开，然后进行置换、指针的后移等。



### M24.两两交换链表中的节点

1. 需要建立哨兵节点，以方便交换时有前驱节点的地址。
2. firstNode：交换的第一个节点，secondNode：交换的第二个节点，temp：交换的两个节点后的一个节点，currentNode：遍历节点，初始时指向哨兵节点。
3. 定义好存放临时节点的变量后，进行节点的置换即可。
4. **置换完毕后，currentNode 遍历节点会指向 firstNode 节点的位置。（因为已经完成了置换，因此 firstNode 节点在位置上是第二个节点，作为下一次交换的前驱节点）。**
5. 注意：返回值应该是哨兵节点的后继节点，而不是给定的 head 节点，因为 head 节点初始就与第二个节点交换了，这也是使用哨兵节点的目的之一，保留初始地址。



### M19. 删除链表的倒数第 N 个结点

1. 也可以采用删除正向为第 size - n + 1 个节点的思想，但是下面的解法也结合了这个思想，而且更巧妙。而且双指针法正是解决了两个循环需要做的事。
2. 使用双指针法。快指针首先移动 n 个节点（也是从哨兵节点开始），然后慢指针从 0 开始（因此需要建立哨兵指针），两个指针同时后移，当快指针到达尾部时（最后一个节点，而不是 null 处），慢指针正好停留在指定的倒数第 n -1 的位置上。
3. 原理：可以继续利用距离来理解，慢指针相当于走了 size - n 的距离，符合正向的思想。快指针首先走了 n 个之后，慢指针才同步移动，而且快指针在 size 时结束，即 size - n。
4. **还是要注意边界值！！！！**
5. 注意：
    1. 循环结束的条件为快指针的 next 不为 null，这样正好解决了特殊情况。
    2. 最后删除节点时，只有慢指针操作，快指针只用来遍历。`slowIndex.next = slowIndex.next.next;`



### E160. 相交链表

1. 如果两条链表长度相同，那么依次比较即可。因此核心思想是处理两条链表遍历的长度相同。而且相交的部分是在后面，因此长链表的前部分节点是冗余的，先行遍历掉。
2. 首先遍历出两条链表的长度，得到两条链表的 gap，长链表先遍历 gap 的部分，进行两条链表的对齐。
3. 对齐之后两条链表的节点一一比对即可。
4. 注意：比对的是节点本身，而不是节点存储的数据。
5. 关于 A 与 B 链表的长度对比之后遍历冗余节点有优化方法。（可以看看解析）



### M142. 环形链表 II

1. **链表典型题：判定链表内是否有环且找到环的入口**
2. 采用双指针法，慢指针每次移动 1 个节点，快指针每次移动 2 个节点，如果链表有环，那么两个指针一定会在环中相遇。
3. 假定从头结点到环形入口结点之间的结点数为 x，从环形入口结点到相遇结点之间的结点数为 y，从相遇结点到环形入口结点之间的结点数为 z，在环内走了 n 圈两个指针才相遇。
4. 得出 x + y = x + y + (z + y) * n。左边为慢指针走的结点数，右边为快指针走的结点数。因为快指针的速度是大于慢指针的，因此是 x + y 之后才开始在圈内循环。整理之后为：x = (n - 1) (y + z) + z。（求 x 就是环形入口的索引）
5. 从公式可以看出，当 n 为 1 时，x = z，根据假设的定义，相当于**从头结点到环形入口结点之间的结点数 = 从相遇点到环形入口之间的结点数**，因此 n 为 1 时，仅仅是快指针在环内走了一圈，n 大于 1 时多走了几圈而已。
6. 最终，定义一个指针从头结点出发一步步走，定义一个指针从相遇点出发一步步走，二者再次相遇时，就是环形的入口。
7. 思路：
    1. 首先确定是否有环。
    2. 有环时，找到相遇的点。
    3. 从相遇的点出发，每次都只移动一个结点，相遇时就是环形入口。



# 哈希表 HashTables

> **哈希法使用空间换时间，适用于快速判断一个元素是否出现在集合中，搜索量级为 O(1)**
>
> **主要方法会手写哈希数据结构，进行数据与索引的映射**



## 字母异位词

> **该题型隐性的规则就是，字母及其个数相同的词，不管词中字母顺序如何，哈希值是相同的。**
>
> **题目中说明了只有小写字母，因此可以采用简单数组作为哈希容器，大小为 26，数组中的值为字母出现的次数，适用于低时间复杂度。**
>
> **也可以采用标准的 HashMap，因为每个异位词排序后的词是相同的，因此可以将串转换为 char 数组排序后作为 key，value 作为相同哈希值共同的桶，适用于低空间复杂度。**
>
> **注意：如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费！**



### E242. 有效的字母异位词

1. 使用数组当做简单的哈希表。数组下标为元素映射的索引，数组内存的数据为该元素的映射次数。
2. 因为是小写字母比较，因此建立长度为 26 的数组，映射关系为 "元素 char 值取模 26"。不必使元素 a 一定处于下标 0 的位置，只需要一个相对的位置即可，查询时会通过映射关系找到对应的下标，再通过下标找到数组内的数值，即可表示出当前元素出现的次数。
3. 将第一个字符串放入数组后，另一个字符串通过相同的映射关系，每有一个元素映射，数组值就减一。当所有元素映射完毕后，再遍历哈希数组，如果数组内的所有值都为 0，说明二者包含的元素个数和种类是相同的。
4. 此类型的题目给出了条件：字符串只有小写英文字母，因此建立的哈希表大小为 26。



### E383. 赎金信

1. 思路与上题完全一致，但是可以优化一下步骤（可以不用所有元素映射完之后再去遍历，可以映射一个就判断一下是否为负数）。



### M49. 字母异位词分组

1. 思路相同，但是容器采用标准库的 HashMap。
2. 题目要求含字母相同的词作为统一映射，因此得出映射关系，只要含有相同的词且个数相同即可，顺序忽略，故可以将候选词汇转换成 char 数组之后排序，这样有相同字母的词就会有相同的哈希值。
3. 关键还是找映射关系（即找相同点，有相同点的词放入一个 “桶” 中，也即哈希值相同），哈希容器采用标准库。
4. 也可以采用数组建立简单的哈希容器，建立容器思想也想通。



### M438. 找到字符串中所有字母异位词

1. 滑动窗口 + 哈希表，依然是对比两串的哈希值是否相同。
2. 首先将标准串中的字母及其个数放入一个自定义的 26 大小的哈希数组中。
3. 然后建立一个子串数组用来对比标准数据。快指针每次遍历，都会滑进元素，因此需要增加新元素的个数，每次新增完毕后，对比两个哈希数组是否相同，如果相同则记录慢指针的位置就是子串的起始索引。
4. 标准串是给定的，因此滑动窗口的大小也是固定的，当窗口大小不符合要求时，才会移动慢指针，此时会滑出元素，因此需要减少滑出元素的个数。
5. 注意：不建议使用上题的通过排序来找到相同哈希值的方法，因为库函数的排序在大数据量下会超时，而手动建立简单哈希数组会牺牲空间换时间。



## 两个数组的交集

> **HashSet 有其元素唯一的性质，因此可以采用标准的 HashSet 来完成找出交集元素且返回值唯一的操作。**
>
> **简单哈希数组效率依然高于 HashSet，但是仅限于哈希值比较少的情况。**



### E349. 两个数组的交集

1. 本题使用标准的 `HashSet` 解决，因为题目修正限制 1000 个元素（哈希值较少），所以也可以建立大小为 1000 的哈希数组，采用数组解决。
2. 使用 `HashSet` 存放 A 数组的值，然后遍历 B 数组，只要 `HashSet` 中也包含 B 数组中的元素，就往返回值 `HashSet` 中添加该元素即可。
3. 因为 `HashSet` 本身的性质，因此返回值 `HashSet` 中的值也是唯一的。



### E350. 两个数组的交集 II

1. 可以使用 `HashMap` 或者简单数组作为哈希容器，本次解决使用 `HashMap`。
2. 首先使用 `HashMap` 存储数组 A 内的数字及其出现的频次。然后遍历数组 B，若数组  B 的元素也为 key 且频次大于 0，就将该元素放入返回值列表中，并将频次减一。
3. **频次减一是为了返回出现次数较少的频次**
4. 也可以将两个数组排序，然后使用双指针法。