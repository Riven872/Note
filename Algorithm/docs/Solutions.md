# 数组 Arrays

## 二分查找

> **适用条件：查找元素，且该数组中元素有序、无重复元素，注意区间的开闭**
>
> **时间复杂度 O(n)**
>
> **空间复杂度 O(1)**



### E704. 二分查找

1. 适用条件：元素有序、无重复元素、且注意区间的开闭
2. 如果是左闭右闭区间，如 [a, b] 的情况，那么循环条件是 `while(low <= high)`，如果区间换为 [a, b)，相应的循环条件需要更换为 `while(low < high)`，因为在右闭的情况下，low 永远不等于 high，而且如果 `nums[mid] > target` 时，`high = mid`，而非 `high = mid + 1`。
3. 计算中间索引下标时，防止溢出问题。如果 low 与 high 相加大于 MAX_INT 时，会发生溢出。因此可以使用 `mid = low + ((high - low) / 2)` 去解决，几何上的意义就是先计算 low 与 high 距离之间的中间值，然后再加上 0 到 low 的距离即可。



### E35. 搜索插入位置

1. 采用二分法如果没有找到元素时，low 指针指向的就是该元素应该要插入位置的下标



### M34. 在排序数组中查找元素的第一个和最后一个位置

1. 二分查找的目的在于找到有序数组中指定元素的下标，那么也可以找到指定元素的前一位或者后一位
2. 因此找左右边界就是找最左侧 target 的前一位下标位置和最右侧 target 的后一位下标位置，在返回时左侧边界 + 1，右侧边界 - 1 即为 target 的第一个出现位置和最后一个出现位置
3. 因此在找左边界时，只要 `target <= nums[mid]` 时，`high = mid - 1`，记录此时 high 的值，如果 `high == target` 则会进入下一轮循环，否则就是 target 第一次出现位置的左边的元素。找右边界时同理。
4. 注意一种特殊情况，就是 target 不在数组中时，此时得出的右边界值 - 左边界值是负数



### E69. x 的平方根

1. 求某个数的平方根，其解的范围一定是在 `[0, target]` 之中的。因此符合二分查找的元素有序且不重复
2. 当不满足循环条件时，low 和 high 已经互换了位置，因此向下取整的话返回的是 high 的值
3. 注意第一种特殊情况，如果 target 值接近 MAX_INT，判断时就不能用 mid * mid 与 target 比较，会溢出 int 值，因此需要 mid 与 target / mid 做比较。
4. 注意第二种特殊情况，如果 target 是 0，需要单独处理，以免发生被 0 除的异常



### E367. 有效的完全平方数

1. 思路同上题
2. 因为 int 型的除法是向下取整的，当满足 `mid == num / mid` 时，需要进行 break，将 mid 值进行平方验证（如 mid 为 2，num 为 5 时，`mid == num / mid` 是成立的，但 5 并不是完全平方数，因此需要进行验证）
3. 注意 0 时的特殊情况



## 双指针法

> **适用条件：移动或移除数组的元素**
>
> **两个指针从相同的位置出发，可以通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作**
>
> **时间复杂度 O(n)**



### E27. 移除元素

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，并找到与 target 值相等的元素，慢指针指向的位置用来接收前移的元素，目的是将 target 值覆盖掉。
3. 当快指针指向的元素与 target 相等时，只有快指针后移。当快指针指向的元素与 target 不相等时，慢指针接收快指针的元素，然后慢指针后移。
4. 注意：发生交换后慢指针后后移一位，因此直接返回慢指针就是新数组的长度，不需要再额外 + 1 补足。



### E26. 删除有序数组中的重复项

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到与慢指针指向元素值不同的元素，因为需要保留唯一的元素，因此慢指针的下一位用来接收前移的元素。
3. 当快指针的元素与慢指针元素相同时，只有快指针后移。当快指针元素与慢指针元素相同时，慢指针后移一位，然后再接收快指针元素。
4. 注意：慢指针是先后移再接收元素，因此返回值需要 + 1 才是新数组的长度



### E283. 移动零

1. 空间复杂度 1，时间复杂度 n。
2. 快指针用来遍历整个数组，找到不等于 0 的元素。慢指针用来接收非 0 元素。
3. 当快指针指向的元素为 0 时，只有快指针后移。当快指针元素不为 0 时，慢指针接收元素，然后再后移。
4. 思想与 E27 移除元素一毛一样，只不过 target 定死为了 0。



### E844. 比较含退格的字符串

1. 空间复杂度 1，时间复杂度 n。
2. 使用双指针法分别处理两个字符串，然后再用 `equals()` 去对比
3. 快指针用来遍历整个数组，找到不等于 \# 的元素。慢指针用来接收非 \# 元素。
4. 当快指针为 \# 时，快指针后移一位，慢指针前移一位，相当于退格操作。当快指针不为 \# 时，慢指针接收快指针元素，然后再后移一位。
5. 注意：当慢指针的值为 0 时，就不需要再前移了，否则会发生负越界的情况。



### E977. 有序数组的平方

1. 空间复杂度 n，时间复杂度 n。
2. 实际两个指针的作用相同，不算严格意义上的双指针题目。
3. 需要建立新的数组，并逆向添加数据。
4. 条件是递增数组，且数组内有负数和正数，因此头指针可以指向头元素，尾指针指向尾元素。然后头尾元素进行绝对值比较，值比较大的放入新数组的尾部。
5. 也可以处理原始数组，将数组内的所有元素进行平方，但是性能较低，建议还是比较绝对值。